diff --git a/Source/WTF/wtf/StdLibExtras.h b/Source/WTF/wtf/StdLibExtras.h
index 25b0f86eafa..951121022ea 100644
--- a/Source/WTF/wtf/StdLibExtras.h
+++ b/Source/WTF/wtf/StdLibExtras.h
@@ -130,7 +130,6 @@ enum CheckMoveParameterTag { CheckMoveParameter };
 
 static const size_t KB = 1024;
 static const size_t MB = 1024 * 1024;
-static const size_t GB = 1024 * 1024 * 1024;
 
 inline bool isPointerAligned(void* p)
 {
diff --git a/Source/WebCore/CMakeLists.txt b/Source/WebCore/CMakeLists.txt
index 477682fe2bc..4b864404b0f 100644
--- a/Source/WebCore/CMakeLists.txt
+++ b/Source/WebCore/CMakeLists.txt
@@ -2262,10 +2262,7 @@ set(WebCore_SOURCES
     platform/graphics/ISOVTTCue.cpp
     platform/graphics/Image.cpp
     platform/graphics/ImageBuffer.cpp
-    platform/graphics/ImageFrame.cpp
-    platform/graphics/ImageFrameCache.cpp
     platform/graphics/ImageOrientation.cpp
-    platform/graphics/ImageSource.cpp
     platform/graphics/IntPoint.cpp
     platform/graphics/IntRect.cpp
     platform/graphics/IntSize.cpp
@@ -2809,7 +2806,7 @@ set(WebCore_SOURCES
     svg/SVGPolyElement.cpp
     svg/SVGPolygonElement.cpp
     svg/SVGPolylineElement.cpp
-    svg/SVGPreserveAspectRatioValue.cpp
+    svg/SVGPreserveAspectRatio.cpp
     svg/SVGRadialGradientElement.cpp
     svg/SVGRectElement.cpp
     svg/SVGSVGElement.cpp
diff --git a/Source/WebCore/PlatformEfl.cmake b/Source/WebCore/PlatformEfl.cmake
index c6b2ccc640c..34d31d3dce6 100644
--- a/Source/WebCore/PlatformEfl.cmake
+++ b/Source/WebCore/PlatformEfl.cmake
@@ -127,6 +127,7 @@ list(APPEND WebCore_SOURCES
     platform/graphics/PlatformDisplay.cpp
 
     platform/graphics/cairo/BackingStoreBackendCairoImpl.cpp
+    platform/graphics/cairo/BitmapImageCairo.cpp
     platform/graphics/cairo/CairoUtilities.cpp
     platform/graphics/cairo/FontCairo.cpp
     platform/graphics/cairo/FontCairoHarfbuzzNG.cpp
@@ -135,7 +136,6 @@ list(APPEND WebCore_SOURCES
     platform/graphics/cairo/ImageBufferCairo.cpp
     platform/graphics/cairo/ImageCairo.cpp
     platform/graphics/cairo/IntRectCairo.cpp
-    platform/graphics/cairo/NativeImageCairo.cpp
     platform/graphics/cairo/PathCairo.cpp
     platform/graphics/cairo/PatternCairo.cpp
     platform/graphics/cairo/PlatformContextCairo.cpp
@@ -185,9 +185,10 @@ list(APPEND WebCore_SOURCES
     platform/graphics/x11/XErrorTrapper.cpp
     platform/graphics/x11/XUniqueResource.cpp
 
-    platform/image-decoders/cairo/ImageBackingStoreCairo.cpp
     platform/image-encoders/JPEGImageEncoder.cpp
 
+    platform/image-decoders/cairo/ImageDecoderCairo.cpp
+
     platform/network/efl/NetworkStateNotifierEfl.cpp
 
     platform/network/soup/AuthenticationChallengeSoup.cpp
diff --git a/Source/WebCore/PlatformGTK.cmake b/Source/WebCore/PlatformGTK.cmake
index bace466db6e..1709fdd7a58 100644
--- a/Source/WebCore/PlatformGTK.cmake
+++ b/Source/WebCore/PlatformGTK.cmake
@@ -108,6 +108,7 @@ list(APPEND WebCore_SOURCES
 
     platform/graphics/cairo/BackingStoreBackendCairoImpl.cpp
     platform/graphics/cairo/BackingStoreBackendCairoX11.cpp
+    platform/graphics/cairo/BitmapImageCairo.cpp
     platform/graphics/cairo/CairoUtilities.cpp
     platform/graphics/cairo/FloatRectCairo.cpp
     platform/graphics/cairo/FontCairo.cpp
@@ -118,7 +119,6 @@ list(APPEND WebCore_SOURCES
     platform/graphics/cairo/ImageBufferCairo.cpp
     platform/graphics/cairo/ImageCairo.cpp
     platform/graphics/cairo/IntRectCairo.cpp
-    platform/graphics/cairo/NativeImageCairo.cpp
     platform/graphics/cairo/PathCairo.cpp
     platform/graphics/cairo/PatternCairo.cpp
     platform/graphics/cairo/PlatformContextCairo.cpp
@@ -164,7 +164,7 @@ list(APPEND WebCore_SOURCES
     platform/gtk/TemporaryLinkStubs.cpp
     platform/gtk/UserAgentGtk.cpp
 
-    platform/image-decoders/cairo/ImageBackingStoreCairo.cpp
+    platform/image-decoders/cairo/ImageDecoderCairo.cpp
 
     platform/mediastream/SDPProcessorScriptResource.cpp
 
diff --git a/Source/WebCore/PlatformMac.cmake b/Source/WebCore/PlatformMac.cmake
index 4fd01ed201b..f322c836d3d 100644
--- a/Source/WebCore/PlatformMac.cmake
+++ b/Source/WebCore/PlatformMac.cmake
@@ -389,6 +389,7 @@ list(APPEND WebCore_SOURCES
     platform/graphics/ca/cocoa/WebSystemBackdropLayer.mm
     platform/graphics/ca/cocoa/WebTiledBackingLayer.mm
 
+    platform/graphics/cg/BitmapImageCG.cpp
     platform/graphics/cg/ColorCG.cpp
     platform/graphics/cg/FloatPointCG.cpp
     platform/graphics/cg/FloatRectCG.cpp
@@ -401,11 +402,11 @@ list(APPEND WebCore_SOURCES
     platform/graphics/cg/ImageBufferDataCG.cpp
     platform/graphics/cg/ImageCG.cpp
     platform/graphics/cg/ImageDecoderCG.cpp
+    platform/graphics/cg/ImageSourceCG.cpp
     platform/graphics/cg/ImageSourceCGMac.mm
     platform/graphics/cg/IntPointCG.cpp
     platform/graphics/cg/IntRectCG.cpp
     platform/graphics/cg/IntSizeCG.cpp
-    platform/graphics/cg/NativeImageCG.cpp
     platform/graphics/cg/PDFDocumentImage.cpp
     platform/graphics/cg/PathCG.cpp
     platform/graphics/cg/PatternCG.cpp
diff --git a/Source/WebCore/PlatformWPE.cmake b/Source/WebCore/PlatformWPE.cmake
index 1564aec9ab6..7e7e752e080 100644
--- a/Source/WebCore/PlatformWPE.cmake
+++ b/Source/WebCore/PlatformWPE.cmake
@@ -81,7 +81,7 @@ list(APPEND WebCore_SOURCES
     platform/graphics/cairo/ImageBufferCairo.cpp
     platform/graphics/cairo/ImageCairo.cpp
     platform/graphics/cairo/IntRectCairo.cpp
-    platform/graphics/cairo/NativeImageCairo.cpp
+    platform/graphics/cairo/BitmapImageCairo.cpp
     platform/graphics/cairo/PathCairo.cpp
     platform/graphics/cairo/PatternCairo.cpp
     platform/graphics/cairo/PlatformContextCairo.cpp
@@ -114,7 +114,7 @@ list(APPEND WebCore_SOURCES
 
     platform/image-encoders/JPEGImageEncoder.cpp
 
-    platform/image-decoders/cairo/ImageBackingStoreCairo.cpp
+    platform/image-decoders/cairo/ImageDecoderCairo.cpp
 
     platform/network/soup/AuthenticationChallengeSoup.cpp
     platform/network/soup/CertificateInfo.cpp
diff --git a/Source/WebCore/PlatformWinCairo.cmake b/Source/WebCore/PlatformWinCairo.cmake
index 953922dae04..4864a5668ef 100644
--- a/Source/WebCore/PlatformWinCairo.cmake
+++ b/Source/WebCore/PlatformWinCairo.cmake
@@ -21,6 +21,7 @@ list(APPEND WebCore_SOURCES
     platform/graphics/GLContext.cpp
     platform/graphics/PlatformDisplay.cpp
 
+    platform/graphics/cairo/BitmapImageCairo.cpp
     platform/graphics/cairo/CairoUtilities.cpp
     platform/graphics/cairo/FloatRectCairo.cpp
     platform/graphics/cairo/FontCairo.cpp
@@ -30,7 +31,6 @@ list(APPEND WebCore_SOURCES
     platform/graphics/cairo/ImageBufferCairo.cpp
     platform/graphics/cairo/ImageCairo.cpp
     platform/graphics/cairo/IntRectCairo.cpp
-    platform/graphics/cairo/NativeImageCairo.cpp
     platform/graphics/cairo/PathCairo.cpp
     platform/graphics/cairo/PatternCairo.cpp
     platform/graphics/cairo/PlatformContextCairo.cpp
@@ -46,7 +46,7 @@ list(APPEND WebCore_SOURCES
     platform/graphics/win/MediaPlayerPrivateMediaFoundation.cpp
     platform/graphics/win/SimpleFontDataCairoWin.cpp
 
-    platform/image-decoders/cairo/ImageBackingStoreCairo.cpp
+    platform/image-decoders/cairo/ImageDecoderCairo.cpp
 
     platform/network/NetworkStorageSessionStub.cpp
 
diff --git a/Source/WebCore/WebCore.xcodeproj/project.pbxproj b/Source/WebCore/WebCore.xcodeproj/project.pbxproj
index 4ffb3276996..85c29774d93 100644
--- a/Source/WebCore/WebCore.xcodeproj/project.pbxproj
+++ b/Source/WebCore/WebCore.xcodeproj/project.pbxproj
@@ -2349,10 +2349,6 @@
 		550A0BCA085F6039007353D6 /* QualifiedName.h in Headers */ = {isa = PBXBuildFile; fileRef = 550A0BC8085F6039007353D6 /* QualifiedName.h */; settings = {ATTRIBUTES = (Private, ); }; };
 		555B87EC1CAAF0AB00349425 /* ImageDecoderCG.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 555B87EA1CAAF0AB00349425 /* ImageDecoderCG.cpp */; };
 		555B87ED1CAAF0AB00349425 /* ImageDecoderCG.h in Headers */ = {isa = PBXBuildFile; fileRef = 555B87EB1CAAF0AB00349425 /* ImageDecoderCG.h */; };
-		5576A5641D88A70800CCC04C /* ImageFrame.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 5576A5621D88A70800CCC04C /* ImageFrame.cpp */; };
-		5576A5651D88A70800CCC04C /* ImageFrame.h in Headers */ = {isa = PBXBuildFile; fileRef = 5576A5631D88A70800CCC04C /* ImageFrame.h */; settings = {ATTRIBUTES = (Private, ); }; };
-		5597F8261D91C3130066BC21 /* ImageFrameCache.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 5597F8241D91C3130066BC21 /* ImageFrameCache.cpp */; };
-		5597F8271D91C3130066BC21 /* ImageFrameCache.h in Headers */ = {isa = PBXBuildFile; fileRef = 5597F8251D91C3130066BC21 /* ImageFrameCache.h */; settings = {ATTRIBUTES = (Private, ); }; };
 		55A336F71D8209F40022C4C7 /* NativeImage.h in Headers */ = {isa = PBXBuildFile; fileRef = 55A336F61D8209F40022C4C7 /* NativeImage.h */; };
 		55A336F91D821E3C0022C4C7 /* ImageBackingStore.h in Headers */ = {isa = PBXBuildFile; fileRef = 55A336F81D821E3C0022C4C7 /* ImageBackingStore.h */; settings = {ATTRIBUTES = (Private, ); }; };
 		5709E8CD1D413D47003244AC /* WebKitSubtleCrypto.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 5709E8CA1D413CE3003244AC /* WebKitSubtleCrypto.cpp */; };
@@ -2879,7 +2875,6 @@
 		7C7941E51C56C29300A4C58E /* DataDetectorsCoreSoftLink.h in Headers */ = {isa = PBXBuildFile; fileRef = 7C7941E31C56C29300A4C58E /* DataDetectorsCoreSoftLink.h */; };
 		7C83DE861D04CC5D00FEBCF3 /* SpringSolver.h in Headers */ = {isa = PBXBuildFile; fileRef = 7C83DE851D04CBD400FEBCF3 /* SpringSolver.h */; };
 		7C8F22441DD3C2F600E92DA3 /* SVGAngleValue.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 7C8F22421DD3B3B900E92DA3 /* SVGAngleValue.cpp */; };
-		7C8F22471DD3D1CA00E92DA3 /* SVGPreserveAspectRatioValue.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 7C8F22451DD3D1C500E92DA3 /* SVGPreserveAspectRatioValue.cpp */; };
 		7C93F3491AA6BA5E00A98BAB /* CompiledContentExtension.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 7C93F3471AA6BA5E00A98BAB /* CompiledContentExtension.cpp */; };
 		7C93F34A1AA6BA5E00A98BAB /* CompiledContentExtension.h in Headers */ = {isa = PBXBuildFile; fileRef = 7C93F3481AA6BA5E00A98BAB /* CompiledContentExtension.h */; settings = {ATTRIBUTES = (Private, ); }; };
 		7C93F34D1AA6BF0700A98BAB /* ContentExtensionCompiler.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 7C93F34B1AA6BF0700A98BAB /* ContentExtensionCompiler.cpp */; };
@@ -4661,6 +4656,7 @@
 		B2227A910D00BF220071B782 /* SVGPolygonElement.h in Headers */ = {isa = PBXBuildFile; fileRef = B22278FB0D00BF210071B782 /* SVGPolygonElement.h */; };
 		B2227A930D00BF220071B782 /* SVGPolylineElement.cpp in Sources */ = {isa = PBXBuildFile; fileRef = B22278FD0D00BF210071B782 /* SVGPolylineElement.cpp */; };
 		B2227A940D00BF220071B782 /* SVGPolylineElement.h in Headers */ = {isa = PBXBuildFile; fileRef = B22278FE0D00BF210071B782 /* SVGPolylineElement.h */; };
+		B2227A960D00BF220071B782 /* SVGPreserveAspectRatio.cpp in Sources */ = {isa = PBXBuildFile; fileRef = B22279000D00BF210071B782 /* SVGPreserveAspectRatio.cpp */; };
 		B2227A970D00BF220071B782 /* SVGPreserveAspectRatio.h in Headers */ = {isa = PBXBuildFile; fileRef = B22279010D00BF210071B782 /* SVGPreserveAspectRatio.h */; settings = {ATTRIBUTES = (Private, ); }; };
 		B2227A990D00BF220071B782 /* SVGRadialGradientElement.cpp in Sources */ = {isa = PBXBuildFile; fileRef = B22279030D00BF210071B782 /* SVGRadialGradientElement.cpp */; };
 		B2227A9A0D00BF220071B782 /* SVGRadialGradientElement.h in Headers */ = {isa = PBXBuildFile; fileRef = B22279040D00BF210071B782 /* SVGRadialGradientElement.h */; };
@@ -4741,6 +4737,7 @@
 		B275355A0B053814002CE64F /* FloatRectCG.cpp in Sources */ = {isa = PBXBuildFile; fileRef = B275352C0B053814002CE64F /* FloatRectCG.cpp */; };
 		B275355B0B053814002CE64F /* FloatSizeCG.cpp in Sources */ = {isa = PBXBuildFile; fileRef = B275352D0B053814002CE64F /* FloatSizeCG.cpp */; };
 		B275355E0B053814002CE64F /* ImageCG.cpp in Sources */ = {isa = PBXBuildFile; fileRef = B27535300B053814002CE64F /* ImageCG.cpp */; };
+		B275355F0B053814002CE64F /* ImageSourceCG.cpp in Sources */ = {isa = PBXBuildFile; fileRef = B27535310B053814002CE64F /* ImageSourceCG.cpp */; };
 		B27535600B053814002CE64F /* IntPointCG.cpp in Sources */ = {isa = PBXBuildFile; fileRef = B27535320B053814002CE64F /* IntPointCG.cpp */; };
 		B27535610B053814002CE64F /* IntRectCG.cpp in Sources */ = {isa = PBXBuildFile; fileRef = B27535330B053814002CE64F /* IntRectCG.cpp */; };
 		B27535620B053814002CE64F /* IntSizeCG.cpp in Sources */ = {isa = PBXBuildFile; fileRef = B27535340B053814002CE64F /* IntSizeCG.cpp */; };
@@ -9561,10 +9558,6 @@
 		550A0BC8085F6039007353D6 /* QualifiedName.h */ = {isa = PBXFileReference; fileEncoding = 30; indentWidth = 4; lastKnownFileType = sourcecode.c.h; path = QualifiedName.h; sourceTree = "<group>"; tabWidth = 8; usesTabs = 0; };
 		555B87EA1CAAF0AB00349425 /* ImageDecoderCG.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = ImageDecoderCG.cpp; sourceTree = "<group>"; };
 		555B87EB1CAAF0AB00349425 /* ImageDecoderCG.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ImageDecoderCG.h; sourceTree = "<group>"; };
-		5576A5621D88A70800CCC04C /* ImageFrame.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = ImageFrame.cpp; sourceTree = "<group>"; };
-		5576A5631D88A70800CCC04C /* ImageFrame.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ImageFrame.h; sourceTree = "<group>"; };
-		5597F8241D91C3130066BC21 /* ImageFrameCache.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = ImageFrameCache.cpp; sourceTree = "<group>"; };
-		5597F8251D91C3130066BC21 /* ImageFrameCache.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ImageFrameCache.h; sourceTree = "<group>"; };
 		55A336F61D8209F40022C4C7 /* NativeImage.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = NativeImage.h; sourceTree = "<group>"; };
 		55A336F81D821E3C0022C4C7 /* ImageBackingStore.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ImageBackingStore.h; sourceTree = "<group>"; };
 		55D408F71A7C631800C78450 /* SVGImageClients.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = SVGImageClients.h; sourceTree = "<group>"; };
@@ -10312,8 +10305,6 @@
 		7C83DE851D04CBD400FEBCF3 /* SpringSolver.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = SpringSolver.h; sourceTree = "<group>"; };
 		7C8F22421DD3B3B900E92DA3 /* SVGAngleValue.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = SVGAngleValue.cpp; sourceTree = "<group>"; };
 		7C8F22431DD3B3B900E92DA3 /* SVGAngleValue.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = SVGAngleValue.h; sourceTree = "<group>"; };
-		7C8F22451DD3D1C500E92DA3 /* SVGPreserveAspectRatioValue.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = SVGPreserveAspectRatioValue.cpp; sourceTree = "<group>"; };
-		7C8F22461DD3D1C500E92DA3 /* SVGPreserveAspectRatioValue.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = SVGPreserveAspectRatioValue.h; sourceTree = "<group>"; };
 		7C93F3471AA6BA5E00A98BAB /* CompiledContentExtension.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = CompiledContentExtension.cpp; sourceTree = "<group>"; };
 		7C93F3481AA6BA5E00A98BAB /* CompiledContentExtension.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = CompiledContentExtension.h; sourceTree = "<group>"; };
 		7C93F34B1AA6BF0700A98BAB /* ContentExtensionCompiler.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = ContentExtensionCompiler.cpp; sourceTree = "<group>"; };
@@ -12419,6 +12410,7 @@
 		B22278FD0D00BF210071B782 /* SVGPolylineElement.cpp */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.cpp.cpp; path = SVGPolylineElement.cpp; sourceTree = "<group>"; };
 		B22278FE0D00BF210071B782 /* SVGPolylineElement.h */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.h; path = SVGPolylineElement.h; sourceTree = "<group>"; };
 		B22278FF0D00BF210071B782 /* SVGPolylineElement.idl */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = text; path = SVGPolylineElement.idl; sourceTree = "<group>"; };
+		B22279000D00BF210071B782 /* SVGPreserveAspectRatio.cpp */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.cpp.cpp; path = SVGPreserveAspectRatio.cpp; sourceTree = "<group>"; };
 		B22279010D00BF210071B782 /* SVGPreserveAspectRatio.h */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.h; path = SVGPreserveAspectRatio.h; sourceTree = "<group>"; };
 		B22279020D00BF210071B782 /* SVGPreserveAspectRatio.idl */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = text; path = SVGPreserveAspectRatio.idl; sourceTree = "<group>"; };
 		B22279030D00BF210071B782 /* SVGRadialGradientElement.cpp */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.cpp.cpp; path = SVGRadialGradientElement.cpp; sourceTree = "<group>"; };
@@ -12530,6 +12522,7 @@
 		B275352C0B053814002CE64F /* FloatRectCG.cpp */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.cpp.cpp; path = FloatRectCG.cpp; sourceTree = "<group>"; };
 		B275352D0B053814002CE64F /* FloatSizeCG.cpp */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.cpp.cpp; path = FloatSizeCG.cpp; sourceTree = "<group>"; };
 		B27535300B053814002CE64F /* ImageCG.cpp */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.cpp.cpp; path = ImageCG.cpp; sourceTree = "<group>"; };
+		B27535310B053814002CE64F /* ImageSourceCG.cpp */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.cpp.cpp; path = ImageSourceCG.cpp; sourceTree = "<group>"; };
 		B27535320B053814002CE64F /* IntPointCG.cpp */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.cpp.cpp; path = IntPointCG.cpp; sourceTree = "<group>"; };
 		B27535330B053814002CE64F /* IntRectCG.cpp */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.cpp.cpp; path = IntRectCG.cpp; sourceTree = "<group>"; };
 		B27535340B053814002CE64F /* IntSizeCG.cpp */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.cpp.cpp; path = IntSizeCG.cpp; sourceTree = "<group>"; };
@@ -21168,10 +21161,9 @@
 				B22278FD0D00BF210071B782 /* SVGPolylineElement.cpp */,
 				B22278FE0D00BF210071B782 /* SVGPolylineElement.h */,
 				B22278FF0D00BF210071B782 /* SVGPolylineElement.idl */,
+				B22279000D00BF210071B782 /* SVGPreserveAspectRatio.cpp */,
 				B22279010D00BF210071B782 /* SVGPreserveAspectRatio.h */,
 				B22279020D00BF210071B782 /* SVGPreserveAspectRatio.idl */,
-				7C8F22451DD3D1C500E92DA3 /* SVGPreserveAspectRatioValue.cpp */,
-				7C8F22461DD3D1C500E92DA3 /* SVGPreserveAspectRatioValue.h */,
 				B22279030D00BF210071B782 /* SVGRadialGradientElement.cpp */,
 				B22279040D00BF210071B782 /* SVGRadialGradientElement.h */,
 				B22279050D00BF210071B782 /* SVGRadialGradientElement.idl */,
@@ -21317,6 +21309,7 @@
 				B27535300B053814002CE64F /* ImageCG.cpp */,
 				555B87EA1CAAF0AB00349425 /* ImageDecoderCG.cpp */,
 				555B87EB1CAAF0AB00349425 /* ImageDecoderCG.h */,
+				B27535310B053814002CE64F /* ImageSourceCG.cpp */,
 				4B3480920EEF50D400AC1B41 /* ImageSourceCG.h */,
 				4B3480910EEF50D400AC1B41 /* ImageSourceCGMac.mm */,
 				B27535320B053814002CE64F /* IntPointCG.cpp */,
@@ -21484,10 +21477,6 @@
 				43D2597613C816F400608559 /* ImageBuffer.cpp */,
 				B2A10B910B3818BD00099AA4 /* ImageBuffer.h */,
 				22BD9F7D1353625C009BD102 /* ImageBufferData.h */,
-				5576A5621D88A70800CCC04C /* ImageFrame.cpp */,
-				5576A5631D88A70800CCC04C /* ImageFrame.h */,
-				5597F8241D91C3130066BC21 /* ImageFrameCache.cpp */,
-				5597F8251D91C3130066BC21 /* ImageFrameCache.h */,
 				BC7F44A70B9E324E00A9D081 /* ImageObserver.h */,
 				A8748D7412CC3F89001FBA41 /* ImageOrientation.cpp */,
 				A8748D6612CC3763001FBA41 /* ImageOrientation.h */,
@@ -28680,7 +28669,6 @@
 				1C0939EA1A13E12900B788E5 /* CachedSVGFont.cpp in Sources */,
 				0753860214489E9800B78452 /* CachedTextTrack.cpp in Sources */,
 				BCB16C270979C3BD00467741 /* CachedXSLStyleSheet.cpp in Sources */,
-				7C8F22471DD3D1CA00E92DA3 /* SVGPreserveAspectRatioValue.cpp in Sources */,
 				E43AF8E61AC5B7E800CA717E /* CacheValidation.cpp in Sources */,
 				49AE2D96134EE5F90072920A /* CalculationValue.cpp in Sources */,
 				B1827493134CA4C100B98C2D /* CallbackFunction.cpp in Sources */,
@@ -29451,6 +29439,7 @@
 				2D5A592F152525230036EE51 /* ImageOrientation.cpp in Sources */,
 				B51A2F4117D7D5DE0072517A /* ImageQualityController.cpp in Sources */,
 				0F3C725E1974874B00AEDD0C /* ImageSource.cpp in Sources */,
+				B275355F0B053814002CE64F /* ImageSourceCG.cpp in Sources */,
 				4B3480930EEF50D400AC1B41 /* ImageSourceCGMac.mm in Sources */,
 				316FE1170E6E1DA700BF6088 /* ImplicitAnimation.cpp in Sources */,
 				BE961C5418AD338500D07DC5 /* InbandDataTextTrack.cpp in Sources */,
@@ -31249,6 +31238,7 @@
 				B2227A8E0D00BF220071B782 /* SVGPolyElement.cpp in Sources */,
 				B2227A900D00BF220071B782 /* SVGPolygonElement.cpp in Sources */,
 				B2227A930D00BF220071B782 /* SVGPolylineElement.cpp in Sources */,
+				B2227A960D00BF220071B782 /* SVGPreserveAspectRatio.cpp in Sources */,
 				B543B85717EB758F003BE93A /* SVGPropertyInfo.cpp in Sources */,
 				B2227A990D00BF220071B782 /* SVGRadialGradientElement.cpp in Sources */,
 				B2227A9D0D00BF220071B782 /* SVGRectElement.cpp in Sources */,
diff --git a/Source/WebCore/bindings/scripts/CodeGenerator.pm b/Source/WebCore/bindings/scripts/CodeGenerator.pm
index e1eccce23cc..641aca6df87 100644
--- a/Source/WebCore/bindings/scripts/CodeGenerator.pm
+++ b/Source/WebCore/bindings/scripts/CodeGenerator.pm
@@ -127,6 +127,7 @@ my %svgTypeNeedingTearOff = (
     "SVGPathSegList" => "SVGPathSegListPropertyTearOff",
     "SVGPoint" => "SVGPropertyTearOff<SVGPoint>",
     "SVGPointList" => "SVGListPropertyTearOff<SVGPointList>",
+    "SVGPreserveAspectRatio" => "SVGPropertyTearOff<SVGPreserveAspectRatio>",
     "SVGRect" => "SVGPropertyTearOff<FloatRect>",
     "SVGStringList" => "SVGStaticListPropertyTearOff<SVGStringList>",
     "SVGTransform" => "SVGPropertyTearOff<SVGTransform>",
@@ -1126,16 +1127,14 @@ sub GenerateCompileTimeCheckForEnumsIfNeeded
 
     return () if $interface->extendedAttributes->{"DoNotCheckConstants"} || !@{$interface->constants};
 
-    my $baseScope = $interface->extendedAttributes->{"ConstantsScope"} || $interface->type->name;
-
     my @checks = ();
     foreach my $constant (@{$interface->constants}) {
-        my $scope = $constant->extendedAttributes->{"ImplementedBy"} || $baseScope;
+        my $className = $constant->extendedAttributes->{"ImplementedBy"} || $interface->type->name;
         my $name = $constant->extendedAttributes->{"Reflect"} || $constant->name;
         my $value = $constant->value;
         my $conditional = $constant->extendedAttributes->{"Conditional"};
         push(@checks, "#if " . $generator->GenerateConditionalStringFromAttributeValue($conditional) . "\n") if $conditional;
-        push(@checks, "static_assert(${scope}::${name} == ${value}, \"${name} in ${scope} does not match value from IDL\");\n");
+        push(@checks, "static_assert(${className}::$name == $value, \"$name in $className does not match value from IDL\");\n");
         push(@checks, "#endif\n") if $conditional;
     }
     push(@checks, "\n");
diff --git a/Source/WebCore/bindings/scripts/IDLAttributes.txt b/Source/WebCore/bindings/scripts/IDLAttributes.txt
index 24307bae0b8..aa0e767ab63 100644
--- a/Source/WebCore/bindings/scripts/IDLAttributes.txt
+++ b/Source/WebCore/bindings/scripts/IDLAttributes.txt
@@ -29,7 +29,6 @@ CheckSecurity
 CheckSecurityForNode
 Clamp
 Conditional=*
-ConstantsScope=*
 Constructor
 ConstructorCallWith=Document|ScriptExecutionContext|ScriptState
 ConstructorMayThrowException
diff --git a/Source/WebCore/dom/DataTransferMac.mm b/Source/WebCore/dom/DataTransferMac.mm
index 94711a06d72..7e8d967f50f 100644
--- a/Source/WebCore/dom/DataTransferMac.mm
+++ b/Source/WebCore/dom/DataTransferMac.mm
@@ -49,7 +49,7 @@ DragImageRef DataTransfer::createDragImage(IntPoint& location) const
             location.setY(imageRect.height() - (elementRect.y() - imageRect.y() + m_dragLocation.y()));
         }
     } else if (m_dragImage) {
-        result = m_dragImage->image()->snapshotNSImage();
+        result = m_dragImage->image()->getNSImage();
         
         location = m_dragLocation;
         location.setY([result size].height - location.y());
diff --git a/Source/WebCore/editing/cocoa/HTMLConverter.mm b/Source/WebCore/editing/cocoa/HTMLConverter.mm
index b4fe42dcda4..f543fc97660 100644
--- a/Source/WebCore/editing/cocoa/HTMLConverter.mm
+++ b/Source/WebCore/editing/cocoa/HTMLConverter.mm
@@ -2444,7 +2444,7 @@ static RetainPtr<NSFileWrapper> fileWrapperForElement(HTMLImageElement& element)
     if (is<RenderImage>(renderer)) {
         auto* image = downcast<RenderImage>(*renderer).cachedImage();
         if (image && !image->errorOccurred()) {
-            RetainPtr<NSFileWrapper> wrapper = adoptNS([[NSFileWrapper alloc] initRegularFileWithContents:(NSData *)image->imageForRenderer(renderer)->tiffRepresentation()]);
+            RetainPtr<NSFileWrapper> wrapper = adoptNS([[NSFileWrapper alloc] initRegularFileWithContents:(NSData *)image->imageForRenderer(renderer)->getTIFFRepresentation()]);
             [wrapper setPreferredFilename:@"image.tiff"];
             return wrapper;
         }
diff --git a/Source/WebCore/html/canvas/CanvasRenderingContext2D.cpp b/Source/WebCore/html/canvas/CanvasRenderingContext2D.cpp
index a7f673e8e06..1df14742539 100644
--- a/Source/WebCore/html/canvas/CanvasRenderingContext2D.cpp
+++ b/Source/WebCore/html/canvas/CanvasRenderingContext2D.cpp
@@ -2444,7 +2444,7 @@ void CanvasRenderingContext2D::drawTextInternal(const String& text, float x, flo
             fontProxy.drawBidiText(*c, textRun, location + offset, FontCascade::UseFallbackIfFontNotReady);
         }
 
-        auto maskImage = ImageBuffer::createCompatibleBuffer(maskRect.size(), ColorSpaceSRGB, *c);
+        std::unique_ptr<ImageBuffer> maskImage = c->createCompatibleBuffer(maskRect.size());
         if (!maskImage)
             return;
 
diff --git a/Source/WebCore/loader/FrameLoader.cpp b/Source/WebCore/loader/FrameLoader.cpp
index a23ae331006..7866da024c3 100644
--- a/Source/WebCore/loader/FrameLoader.cpp
+++ b/Source/WebCore/loader/FrameLoader.cpp
@@ -101,6 +101,7 @@
 #include "SVGDocument.h"
 #include "SVGLocatable.h"
 #include "SVGNames.h"
+#include "SVGPreserveAspectRatio.h"
 #include "SVGViewElement.h"
 #include "SVGViewSpec.h"
 #include "SchemeRegistry.h"
diff --git a/Source/WebCore/loader/cache/CachedImage.cpp b/Source/WebCore/loader/cache/CachedImage.cpp
index 2939e4dee1e..65836371163 100644
--- a/Source/WebCore/loader/cache/CachedImage.cpp
+++ b/Source/WebCore/loader/cache/CachedImage.cpp
@@ -89,12 +89,6 @@ void CachedImage::load(CachedResourceLoader& loader)
         CachedResource::load(loader);
     else
         setLoading(false);
-
-    if (m_loader) {
-        m_allowSubsampling = m_loader->frameLoader()->frame().settings().imageSubsamplingEnabled();
-        m_allowAsyncImageDecoding = m_loader->frameLoader()->frame().settings().asyncImageDecodingEnabled();
-        m_showDebugBackground = m_loader->frameLoader()->frame().settings().showDebugBorders();
-    }
 }
 
 void CachedImage::setBodyDataFrom(const CachedResource& resource)
@@ -266,14 +260,22 @@ LayoutSize CachedImage::imageSizeForRenderer(const RenderElement* renderer, floa
     if (!m_image)
         return LayoutSize();
 
-    LayoutSize imageSize;
+    LayoutSize imageSize(m_image->size());
 
-    if (is<BitmapImage>(*m_image) && renderer && renderer->shouldRespectImageOrientation() == RespectImageOrientation)
+#if ENABLE(CSS_IMAGE_ORIENTATION)
+    if (renderer && is<BitmapImage>(*m_image)) {
+        ImageOrientationDescription orientationDescription(renderer->shouldRespectImageOrientation(), renderer->style().imageOrientation());
+        if (orientationDescription.respectImageOrientation() == RespectImageOrientation)
+            imageSize = LayoutSize(downcast<BitmapImage>(*m_image).sizeRespectingOrientation(orientationDescription));
+    }
+#else
+    if (is<BitmapImage>(*m_image) && (renderer && renderer->shouldRespectImageOrientation() == RespectImageOrientation))
         imageSize = LayoutSize(downcast<BitmapImage>(*m_image).sizeRespectingOrientation());
-    else if (is<SVGImage>(*m_image) && sizeType == UsedSize)
+#endif // ENABLE(CSS_IMAGE_ORIENTATION)
+
+    else if (is<SVGImage>(*m_image) && sizeType == UsedSize) {
         imageSize = LayoutSize(m_svgImageCache->imageSizeForRenderer(renderer));
-    else
-        imageSize = LayoutSize(m_image->size());
+    }
 
     if (multiplier == 1.0f)
         return imageSize;
@@ -331,8 +333,10 @@ inline void CachedImage::createImage()
         auto svgImage = SVGImage::create(*this, url());
         m_svgImageCache = std::make_unique<SVGImageCache>(svgImage.ptr());
         m_image = WTFMove(svgImage);
-    } else
+    } else {
         m_image = BitmapImage::create(this);
+        downcast<BitmapImage>(*m_image).setAllowSubsampling(m_loader && m_loader->frameLoader()->frame().settings().imageSubsamplingEnabled());
+    }
 
     if (m_image) {
         // Send queued container size requests.
@@ -455,13 +459,13 @@ void CachedImage::destroyDecodedData()
         m_image->destroyDecodedData();
 }
 
-void CachedImage::decodedSizeChanged(const Image* image, long long delta)
+void CachedImage::decodedSizeChanged(const Image* image, int delta)
 {
     if (!image || image != m_image)
         return;
 
-    ASSERT(delta >= 0 || decodedSize() + delta >= 0);
     setDecodedSize(static_cast<unsigned>(decodedSize() + delta));
+
 }
 
 void CachedImage::didDraw(const Image* image)
@@ -485,11 +489,11 @@ void CachedImage::animationAdvanced(const Image* image)
         client->newImageAnimationFrameAvailable(*this);
 }
 
-void CachedImage::changedInRect(const Image* image, const IntRect* rect)
+void CachedImage::changedInRect(const Image* image, const IntRect& rect)
 {
     if (!image || image != m_image)
         return;
-    notifyObservers(rect);
+    notifyObservers(&rect);
 }
 
 bool CachedImage::currentFrameKnownToBeOpaque(const RenderElement* renderer)
diff --git a/Source/WebCore/loader/cache/CachedImage.h b/Source/WebCore/loader/cache/CachedImage.h
index 106e392fdab..259e7f15118 100644
--- a/Source/WebCore/loader/cache/CachedImage.h
+++ b/Source/WebCore/loader/cache/CachedImage.h
@@ -117,14 +117,11 @@ private:
     bool stillNeedsLoad() const override { return !errorOccurred() && status() == Unknown && !isLoading(); }
 
     // ImageObserver
-    bool allowSubsampling() const override { return m_allowSubsampling; }
-    bool allowAsyncImageDecoding() const override { return m_allowAsyncImageDecoding; }
-    bool showDebugBackground() const override { return m_showDebugBackground; }
-    void decodedSizeChanged(const Image*, long long delta) override;
+    void decodedSizeChanged(const Image*, int delta) override;
     void didDraw(const Image*) override;
 
     void animationAdvanced(const Image*) override;
-    void changedInRect(const Image*, const IntRect* changeRect = nullptr) override;
+    void changedInRect(const Image*, const IntRect&) override;
 
     void addIncrementalDataBuffer(SharedBuffer&);
 
@@ -138,15 +135,6 @@ private:
     std::unique_ptr<SVGImageCache> m_svgImageCache;
     bool m_isManuallyCached { false };
     bool m_shouldPaintBrokenImage { true };
-
-    // The default value of m_allowSubsampling should be the same as defaultImageSubsamplingEnabled in Settings.cpp
-#if PLATFORM(IOS)
-    bool m_allowSubsampling { true };
-#else
-    bool m_allowSubsampling { false };
-#endif
-    bool m_allowAsyncImageDecoding { true };
-    bool m_showDebugBackground { false };
 };
 
 } // namespace WebCore
diff --git a/Source/WebCore/loader/cache/CachedResource.cpp b/Source/WebCore/loader/cache/CachedResource.cpp
index e07938c9f75..22a0ab0e425 100644
--- a/Source/WebCore/loader/cache/CachedResource.cpp
+++ b/Source/WebCore/loader/cache/CachedResource.cpp
@@ -567,13 +567,13 @@ void CachedResource::setDecodedSize(unsigned size)
     if (size == m_decodedSize)
         return;
 
-    long long delta = static_cast<long long>(size) - m_decodedSize;
+    int delta = size - m_decodedSize;
 
     // The object must be moved to a different queue, since its size has been changed.
     // Remove before updating m_decodedSize, so we find the resource in the correct LRU list.
     if (allowsCaching() && inCache())
         MemoryCache::singleton().removeFromLRUList(*this);
-
+    
     m_decodedSize = size;
    
     if (allowsCaching() && inCache()) {
@@ -604,7 +604,7 @@ void CachedResource::setEncodedSize(unsigned size)
     if (size == m_encodedSize)
         return;
 
-    long long delta = static_cast<long long>(size) - m_encodedSize;
+    int delta = size - m_encodedSize;
 
     // The object must be moved to a different queue, since its size has been changed.
     // Remove before updating m_encodedSize, so we find the resource in the correct LRU list.
diff --git a/Source/WebCore/loader/cache/MemoryCache.cpp b/Source/WebCore/loader/cache/MemoryCache.cpp
index 066f47e0b19..935af5a1a49 100644
--- a/Source/WebCore/loader/cache/MemoryCache.cpp
+++ b/Source/WebCore/loader/cache/MemoryCache.cpp
@@ -71,7 +71,6 @@ MemoryCache::MemoryCache()
     , m_deadSize(0)
     , m_pruneTimer(*this, &MemoryCache::prune)
 {
-    static_assert(sizeof(long long) > sizeof(unsigned), "Numerical overflow can happen when adjusting the size of the cached memory.");
 }
 
 auto MemoryCache::sessionResourceMap(SessionID sessionID) const -> CachedResourceMap*
@@ -154,7 +153,7 @@ void MemoryCache::revalidationSucceeded(CachedResource& revalidatingResource, co
     resource.setInCache(true);
     resource.updateResponseAfterRevalidation(response);
     insertInLRUList(resource);
-    long long delta = resource.size();
+    int delta = resource.size();
     if (resource.decodedSize() && resource.hasClients())
         insertInLiveDecodedResourcesList(resource);
     if (delta)
@@ -456,7 +455,7 @@ void MemoryCache::remove(CachedResource& resource)
             // Remove from the appropriate LRU list.
             removeFromLRUList(resource);
             removeFromLiveDecodedResourcesList(resource);
-            adjustSize(resource.hasClients(), -static_cast<long long>(resource.size()));
+            adjustSize(resource.hasClients(), -static_cast<int>(resource.size()));
         } else
             ASSERT(resources->get(key) != &resource);
     }
@@ -649,13 +648,13 @@ void MemoryCache::removeFromLiveResourcesSize(CachedResource& resource)
     m_deadSize += resource.size();
 }
 
-void MemoryCache::adjustSize(bool live, long long delta)
+void MemoryCache::adjustSize(bool live, int delta)
 {
     if (live) {
-        ASSERT(delta >= 0 || (static_cast<long long>(m_liveSize) + delta >= 0));
+        ASSERT(delta >= 0 || ((int)m_liveSize + delta >= 0));
         m_liveSize += delta;
     } else {
-        ASSERT(delta >= 0 || (static_cast<long long>(m_deadSize) + delta >= 0));
+        ASSERT(delta >= 0 || ((int)m_deadSize + delta >= 0));
         m_deadSize += delta;
     }
 }
diff --git a/Source/WebCore/loader/cache/MemoryCache.h b/Source/WebCore/loader/cache/MemoryCache.h
index 1836c2bf100..bf085d056d2 100644
--- a/Source/WebCore/loader/cache/MemoryCache.h
+++ b/Source/WebCore/loader/cache/MemoryCache.h
@@ -24,7 +24,7 @@
 
 #pragma once
 
-#include "NativeImage.h"
+#include "NativeImagePtr.h"
 #include "SecurityOriginHash.h"
 #include "SessionID.h"
 #include "Timer.h"
@@ -133,7 +133,7 @@ public:
     void removeFromLRUList(CachedResource&);
 
     // Called to adjust the cache totals when a resource changes size.
-    void adjustSize(bool live, long long delta);
+    void adjustSize(bool live, int delta);
 
     // Track decoded resources that are in the cache and referenced by a Web page.
     void insertInLiveDecodedResourcesList(CachedResource&);
diff --git a/Source/WebCore/loader/icon/IconDatabaseBase.h b/Source/WebCore/loader/icon/IconDatabaseBase.h
index 986d4d96f57..611cfc10d85 100644
--- a/Source/WebCore/loader/icon/IconDatabaseBase.h
+++ b/Source/WebCore/loader/icon/IconDatabaseBase.h
@@ -25,7 +25,7 @@
  
 #pragma once
 
-#include "NativeImage.h"
+#include "NativeImagePtr.h"
 #include <wtf/Forward.h>
 #include <wtf/Noncopyable.h>
 #include <wtf/PassRefPtr.h>
diff --git a/Source/WebCore/page/mac/TextIndicatorWindow.mm b/Source/WebCore/page/mac/TextIndicatorWindow.mm
index e4e20d22768..b4c73c78d04 100644
--- a/Source/WebCore/page/mac/TextIndicatorWindow.mm
+++ b/Source/WebCore/page/mac/TextIndicatorWindow.mm
@@ -162,9 +162,9 @@ static bool indicatorWantsManualAnimation(const TextIndicator& indicator)
     contentsImageLogicalSize.scale(1 / _textIndicator->contentImageScaleFactor());
     RetainPtr<CGImageRef> contentsImage;
     if (indicatorWantsContentCrossfade(*_textIndicator))
-        contentsImage = _textIndicator->contentImageWithHighlight()->nativeImage();
+        contentsImage = _textIndicator->contentImageWithHighlight()->getCGImageRef();
     else
-        contentsImage = _textIndicator->contentImage()->nativeImage();
+        contentsImage = _textIndicator->contentImage()->getCGImageRef();
 
     RetainPtr<NSMutableArray> bounceLayers = adoptNS([[NSMutableArray alloc] init]);
 
@@ -265,7 +265,7 @@ static RetainPtr<CAKeyframeAnimation> createBounceAnimation(CFTimeInterval durat
 static RetainPtr<CABasicAnimation> createContentCrossfadeAnimation(CFTimeInterval duration, TextIndicator& textIndicator)
 {
     RetainPtr<CABasicAnimation> crossfadeAnimation = [CABasicAnimation animationWithKeyPath:@"contents"];
-    RetainPtr<CGImageRef> contentsImage = textIndicator.contentImage()->nativeImage();
+    RetainPtr<CGImageRef> contentsImage = textIndicator.contentImage()->getCGImageRef();
     [crossfadeAnimation setToValue:(id)contentsImage.get()];
     [crossfadeAnimation setFillMode:kCAFillModeForwards];
     [crossfadeAnimation setRemovedOnCompletion:NO];
diff --git a/Source/WebCore/platform/Cursor.cpp b/Source/WebCore/platform/Cursor.cpp
index 9c592f374b3..60a619acda1 100644
--- a/Source/WebCore/platform/Cursor.cpp
+++ b/Source/WebCore/platform/Cursor.cpp
@@ -44,10 +44,10 @@ IntPoint determineHotSpot(Image* image, const IntPoint& specifiedHotSpot)
         return specifiedHotSpot;
 
     // If hot spot is not specified externally, it can be extracted from some image formats (e.g. .cur).
-    if (auto intrinsicHotSpot = image->hotSpot()) {
-        if (imageRect.contains(intrinsicHotSpot.value()))
-            return intrinsicHotSpot.value();
-    }
+    IntPoint intrinsicHotSpot;
+    bool imageHasIntrinsicHotSpot = image->getHotSpot(intrinsicHotSpot);
+    if (imageHasIntrinsicHotSpot && imageRect.contains(intrinsicHotSpot))
+        return intrinsicHotSpot;
 
     return IntPoint();
 }
diff --git a/Source/WebCore/platform/graphics/BitmapImage.cpp b/Source/WebCore/platform/graphics/BitmapImage.cpp
index 5ee9765180e..8d2ef6e4fa3 100644
--- a/Source/WebCore/platform/graphics/BitmapImage.cpp
+++ b/Source/WebCore/platform/graphics/BitmapImage.cpp
@@ -21,7 +21,7 @@
  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
  */
 
 #include "config.h"
@@ -48,13 +48,34 @@ namespace WebCore {
 
 BitmapImage::BitmapImage(ImageObserver* observer)
     : Image(observer)
-    , m_source(this)
-{
-}
-
-BitmapImage::BitmapImage(NativeImagePtr&& image, ImageObserver* observer)
-    : Image(observer)
-    , m_source(WTFMove(image))
+    , m_minimumSubsamplingLevel(0)
+    , m_imageOrientation(OriginTopLeft)
+    , m_shouldRespectImageOrientation(false)
+    , m_currentFrame(0)
+    , m_repetitionCount(cAnimationNone)
+    , m_repetitionCountStatus(Unknown)
+    , m_repetitionsComplete(0)
+    , m_desiredFrameStartTime(0)
+    , m_decodedSize(0)
+    , m_decodedPropertiesSize(0)
+    , m_frameCount(0)
+#if PLATFORM(IOS)
+    // FIXME: We should expose a setting to enable/disable progressive loading remove the PLATFORM(IOS)-guard.
+    , m_progressiveLoadChunkTime(0)
+    , m_progressiveLoadChunkCount(0)
+    , m_allowSubsampling(true)
+#else
+    , m_allowSubsampling(false)
+#endif
+    , m_isSolidColor(false)
+    , m_checkedForSolidColor(false)
+    , m_animationFinished(false)
+    , m_allDataReceived(false)
+    , m_haveSize(false)
+    , m_sizeAvailable(false)
+    , m_hasUniformFrameSize(true)
+    , m_haveFrameCount(false)
+    , m_animationFinishedWhenCatchingUp(false)
 {
 }
 
@@ -64,273 +85,509 @@ BitmapImage::~BitmapImage()
     stopAnimation();
 }
 
-void BitmapImage::destroyDecodedData(bool destroyAll)
+void BitmapImage::clearTimer()
 {
-    m_source.destroyDecodedData(data(), destroyAll, m_currentFrame);
-    invalidatePlatformData();
+    m_frameTimer = nullptr;
 }
 
-void BitmapImage::destroyDecodedDataIfNecessary(bool destroyAll)
+void BitmapImage::startTimer(double delay)
 {
-    m_source.destroyDecodedDataIfNecessary(data(), destroyAll, m_currentFrame);
+    ASSERT(!m_frameTimer);
+    m_frameTimer = std::make_unique<Timer>(*this, &BitmapImage::advanceAnimation);
+    m_frameTimer->startOneShot(delay);
 }
 
-bool BitmapImage::dataChanged(bool allDataReceived)
+bool BitmapImage::haveFrameImageAtIndex(size_t index)
 {
-    return m_source.dataChanged(data(), allDataReceived);
-}
+    if (index >= frameCount())
+        return false;
 
-NativeImagePtr BitmapImage::frameImageAtIndex(size_t index, SubsamplingLevel subsamplingLevel, const GraphicsContext* targetContext)
-{
-    if (!frameHasValidNativeImageAtIndex(index, subsamplingLevel)) {
-        LOG(Images, "BitmapImage %p %s - subsamplingLevel was %d, resampling", this, __FUNCTION__, static_cast<int>(frameSubsamplingLevelAtIndex(index)));
-        invalidatePlatformData();
-    }
+    if (index >= m_frames.size())
+        return false;
 
-    return m_source.frameImageAtIndex(index, subsamplingLevel, targetContext);
+    return m_frames[index].m_image;
 }
 
-NativeImagePtr BitmapImage::nativeImage(const GraphicsContext* targetContext)
+bool BitmapImage::hasSingleSecurityOrigin() const
 {
-    return frameImageAtIndex(0, SubsamplingLevel::Default, targetContext);
+    return true;
 }
 
-NativeImagePtr BitmapImage::nativeImageForCurrentFrame(const GraphicsContext* targetContext)
+void BitmapImage::destroyDecodedData(bool destroyAll)
 {
-    return frameImageAtIndex(m_currentFrame, SubsamplingLevel::Default, targetContext);
+    unsigned frameBytesCleared = 0;
+    const size_t clearBeforeFrame = destroyAll ? m_frames.size() : m_currentFrame;
+
+    // Because we can advance frames without always needing to decode the actual
+    // bitmap data, |m_currentFrame| may be larger than m_frames.size();
+    // make sure not to walk off the end of the container in this case.
+    for (size_t i = 0; i <  std::min(clearBeforeFrame, m_frames.size()); ++i) {
+        // The underlying frame isn't actually changing (we're just trying to
+        // save the memory for the framebuffer data), so we don't need to clear
+        // the metadata.
+        unsigned frameBytes = m_frames[i].m_frameBytes;
+        if (m_frames[i].clear(false))
+            frameBytesCleared += frameBytes;
+    }
+
+    m_source.clear(destroyAll, clearBeforeFrame, data(), m_allDataReceived);
+    destroyMetadataAndNotify(frameBytesCleared, ClearedSource::Yes);
 }
 
-#if USE(CG)
-NativeImagePtr BitmapImage::nativeImageOfSize(const IntSize& size, const GraphicsContext* targetContext)
+void BitmapImage::destroyDecodedDataIfNecessary(bool destroyAll)
 {
-    size_t count = frameCount();
+    // Animated images over a certain size are considered large enough that we'll only hang on
+    // to one frame at a time.
+#if PLATFORM(IOS)
+    const unsigned largeAnimationCutoff = 2097152;
+#else
+    const unsigned largeAnimationCutoff = 5242880;
+#endif
 
-    for (size_t i = 0; i < count; ++i) {
-        auto image = frameImageAtIndex(i, SubsamplingLevel::Default, targetContext);
-        if (image && nativeImageSize(image) == size)
-            return image;
-    }
+    // If we have decoded frames but there is no encoded data, we shouldn't destroy
+    // the decoded image since we won't be able to reconstruct it later.
+    if (!data() && m_frames.size())
+        return;
+
+    unsigned allFrameBytes = 0;
+    for (size_t i = 0; i < m_frames.size(); ++i)
+        allFrameBytes += m_frames[i].m_frameBytes;
 
-    // Fallback to the first frame image if we can't find the right size
-    return frameImageAtIndex(0, SubsamplingLevel::Default, targetContext);
+    if (allFrameBytes > largeAnimationCutoff) {
+        LOG(Images, "BitmapImage %p destroyDecodedDataIfNecessary destryingData: allFrameBytes=%u cutoff=%u", this, allFrameBytes, largeAnimationCutoff);
+        destroyDecodedData(destroyAll);
+    }
 }
 
-Vector<NativeImagePtr> BitmapImage::framesNativeImages()
+void BitmapImage::destroyMetadataAndNotify(unsigned frameBytesCleared, ClearedSource clearedSource)
 {
-    Vector<NativeImagePtr> images;
-    size_t count = frameCount();
+    m_isSolidColor = false;
+    m_checkedForSolidColor = false;
+    invalidatePlatformData();
 
-    for (size_t i = 0; i < count; ++i) {
-        if (auto image = frameImageAtIndex(i))
-            images.append(image);
+    ASSERT(m_decodedSize >= frameBytesCleared);
+    m_decodedSize -= frameBytesCleared;
+
+    // Clearing the ImageSource destroys the extra decoded data used for determining image properties.
+    if (clearedSource == ClearedSource::Yes) {
+        frameBytesCleared += m_decodedPropertiesSize;
+        m_decodedPropertiesSize = 0;
     }
 
-    return images;
+    if (frameBytesCleared && imageObserver())
+        imageObserver()->decodedSizeChanged(this, -safeCast<int>(frameBytesCleared));
 }
-#endif
 
-#if !ASSERT_DISABLED
-bool BitmapImage::notSolidColor()
+void BitmapImage::cacheFrame(size_t index, SubsamplingLevel subsamplingLevel, ImageFrameCaching frameCaching)
 {
-    return size().width() != 1 || size().height() != 1 || frameCount() > 1;
+    size_t numFrames = frameCount();
+    ASSERT(m_decodedSize == 0 || numFrames > 1);
+    
+    if (m_frames.size() < numFrames)
+        m_frames.grow(numFrames);
+
+    if (frameCaching == CacheMetadataAndFrame) {
+        m_frames[index].m_image = m_source.createFrameImageAtIndex(index, subsamplingLevel);
+        m_frames[index].m_subsamplingLevel = subsamplingLevel;
+        if (numFrames == 1 && m_frames[index].m_image)
+            checkForSolidColor();
+    }
+
+    m_frames[index].m_orientation = m_source.orientationAtIndex(index);
+    m_frames[index].m_haveMetadata = true;
+    m_frames[index].m_isComplete = m_source.frameIsCompleteAtIndex(index);
+
+    if (repetitionCount(false) != cAnimationNone)
+        m_frames[index].m_duration = m_source.frameDurationAtIndex(index);
+
+    m_frames[index].m_hasAlpha = m_source.frameHasAlphaAtIndex(index);
+    m_frames[index].m_frameBytes = m_source.frameBytesAtIndex(index, subsamplingLevel);
+
+    const IntSize frameSize(index ? m_source.frameSizeAtIndex(index, subsamplingLevel) : m_size);
+    if (!subsamplingLevel && frameSize != m_size)
+        m_hasUniformFrameSize = false;
+
+    LOG(Images, "BitmapImage %p cacheFrame %lu (%s%u bytes, complete %d)", this, index, frameCaching == CacheMetadataOnly ? "metadata only, " : "", m_frames[index].m_frameBytes, m_frames[index].m_isComplete);
+
+    if (m_frames[index].m_image) {
+        int deltaBytes = safeCast<int>(m_frames[index].m_frameBytes);
+        m_decodedSize += deltaBytes;
+        // The fully-decoded frame will subsume the partially decoded data used
+        // to determine image properties.
+        deltaBytes -= m_decodedPropertiesSize;
+        m_decodedPropertiesSize = 0;
+        if (imageObserver())
+            imageObserver()->decodedSizeChanged(this, deltaBytes);
+    }
 }
-#endif
 
-void BitmapImage::draw(GraphicsContext& context, const FloatRect& destRect, const FloatRect& srcRect, CompositeOperator op, BlendMode mode, ImageOrientationDescription description)
+void BitmapImage::didDecodeProperties() const
 {
-    if (destRect.isEmpty() || srcRect.isEmpty())
+    if (m_decodedSize)
         return;
 
-    StartAnimationResult result = internalStartAnimation();
+    size_t updatedSize = m_source.bytesDecodedToDetermineProperties();
+    if (m_decodedPropertiesSize == updatedSize)
+        return;
 
-    Color color;
-    if (result == StartAnimationResult::DecodingActive && showDebugBackground())
-        color = Color::yellow;
-    else
-        color = singlePixelSolidColor();
+    int deltaBytes = updatedSize - m_decodedPropertiesSize;
+#if !ASSERT_DISABLED
+    bool overflow = updatedSize > m_decodedPropertiesSize && deltaBytes < 0;
+    bool underflow = updatedSize < m_decodedPropertiesSize && deltaBytes > 0;
+    ASSERT(!overflow && !underflow);
+#endif
+    m_decodedPropertiesSize = updatedSize;
+    if (imageObserver())
+        imageObserver()->decodedSizeChanged(this, deltaBytes);
+}
 
-    if (color.isValid()) {
-        fillWithSolidColor(context, destRect, color, op);
+void BitmapImage::updateSize(ImageOrientationDescription description) const
+{
+    if (!m_sizeAvailable || m_haveSize)
         return;
-    }
 
-    float scale = subsamplingScale(context, destRect, srcRect);
-    m_currentSubsamplingLevel = allowSubsampling() ? m_source.subsamplingLevelForScale(scale) : SubsamplingLevel::Default;
-    LOG(Images, "BitmapImage %p draw - subsamplingLevel %d at scale %.4f", this, static_cast<int>(m_currentSubsamplingLevel), scale);
+    m_size = m_source.size(description);
+    m_sizeRespectingOrientation = m_source.size(ImageOrientationDescription(RespectImageOrientation, description.imageOrientation()));
 
-    auto image = frameImageAtIndex(m_currentFrame, m_currentSubsamplingLevel, &context);
-    if (!image) // If it's too early we won't have an image yet.
-        return;
+    m_imageOrientation = static_cast<unsigned>(description.imageOrientation());
+    m_shouldRespectImageOrientation = static_cast<unsigned>(description.respectImageOrientation());
 
-    ImageOrientation orientation(description.imageOrientation());
-    if (description.respectImageOrientation() == RespectImageOrientation)
-        orientation = frameOrientationAtIndex(m_currentFrame);
+    m_haveSize = true;
 
-    drawNativeImage(image, context, destRect, srcRect, IntSize(size()), op, mode, orientation);
+    determineMinimumSubsamplingLevel();
+    didDecodeProperties();
+}
 
-    if (imageObserver())
-        imageObserver()->didDraw(this);
+FloatSize BitmapImage::size() const
+{
+    updateSize();
+    return m_size;
 }
 
-void BitmapImage::drawPattern(GraphicsContext& ctxt, const FloatRect& destRect, const FloatRect& tileRect, const AffineTransform& transform, const FloatPoint& phase, const FloatSize& spacing, CompositeOperator op, BlendMode blendMode)
+IntSize BitmapImage::sizeRespectingOrientation(ImageOrientationDescription description) const
 {
-    if (tileRect.isEmpty())
-        return;
+    updateSize(description);
+    return m_sizeRespectingOrientation;
+}
 
-    if (!ctxt.drawLuminanceMask()) {
-        Image::drawPattern(ctxt, destRect, tileRect, transform, phase, spacing, op, blendMode);
-        return;
+bool BitmapImage::getHotSpot(IntPoint& hotSpot) const
+{
+    bool result = m_source.getHotSpot(hotSpot);
+    didDecodeProperties();
+    return result;
+}
+
+bool BitmapImage::dataChanged(bool allDataReceived)
+{
+    // Because we're modifying the current frame, clear its (now possibly
+    // inaccurate) metadata as well.
+#if !PLATFORM(IOS)
+    // Clear all partially-decoded frames. For most image formats, there is only
+    // one frame, but at least GIF and ICO can have more. With GIFs, the frames
+    // come in order and we ask to decode them in order, waiting to request a
+    // subsequent frame until the prior one is complete. Given that we clear
+    // incomplete frames here, this means there is at most one incomplete frame
+    // (even if we use destroyDecodedData() -- since it doesn't reset the
+    // metadata), and it is after all the complete frames.
+    //
+    // With ICOs, on the other hand, we may ask for arbitrary frames at
+    // different times (e.g. because we're displaying a higher-resolution image
+    // in the content area and using a lower-resolution one for the favicon),
+    // and the frames aren't even guaranteed to appear in the file in the same
+    // order as in the directory, so an arbitrary number of the frames might be
+    // incomplete (if we ask for frames for which we've not yet reached the
+    // start of the frame data), and any or none of them might be the particular
+    // frame affected by appending new data here. Thus we have to clear all the
+    // incomplete frames to be safe.
+    unsigned frameBytesCleared = 0;
+    for (size_t i = 0; i < m_frames.size(); ++i) {
+        // NOTE: Don't call frameIsCompleteAtIndex() here, that will try to
+        // decode any uncached (i.e. never-decoded or
+        // cleared-on-a-previous-pass) frames!
+        unsigned frameBytes = m_frames[i].m_frameBytes;
+        if (m_frames[i].m_haveMetadata && !m_frames[i].m_isComplete)
+            frameBytesCleared += (m_frames[i].clear(true) ? frameBytes : 0);
+    }
+    destroyMetadataAndNotify(frameBytesCleared, ClearedSource::No);
+#else
+    // FIXME: why is this different for iOS?
+    int deltaBytes = 0;
+    if (!m_frames.isEmpty()) {
+        int bytes = m_frames[m_frames.size() - 1].m_frameBytes;
+        if (m_frames[m_frames.size() - 1].clear(true)) {
+            deltaBytes += bytes;
+            deltaBytes += m_decodedPropertiesSize;
+            m_decodedPropertiesSize = 0;
+        }
+    }
+    destroyMetadataAndNotify(deltaBytes, ClearedSource::No);
+#endif
+    
+    // Feed all the data we've seen so far to the image decoder.
+    m_allDataReceived = allDataReceived;
+#if PLATFORM(IOS)
+    // FIXME: We should expose a setting to enable/disable progressive loading and make this
+    // code conditional on it. Then we can remove the PLATFORM(IOS)-guard.
+    static const double chunkLoadIntervals[] = {0, 1, 3, 6, 15};
+    double interval = chunkLoadIntervals[std::min(m_progressiveLoadChunkCount, static_cast<uint16_t>(4))];
+
+    bool needsUpdate = false;
+    if (currentTime() - m_progressiveLoadChunkTime > interval) { // The first time through, the chunk time will be 0 and the image will get an update.
+        needsUpdate = true;
+        m_progressiveLoadChunkTime = currentTime();
+        ASSERT(m_progressiveLoadChunkCount <= std::numeric_limits<uint16_t>::max());
+        ++m_progressiveLoadChunkCount;
     }
+    if (needsUpdate || allDataReceived)
+        m_source.setData(data(), allDataReceived);
+#else
+    m_source.setData(data(), allDataReceived);
+#endif
 
-    if (!m_cachedImage) {
-        auto buffer = ImageBuffer::createCompatibleBuffer(expandedIntSize(tileRect.size()), ColorSpaceSRGB, ctxt);
-        if (!buffer)
-            return;
+    m_haveFrameCount = false;
+    m_hasUniformFrameSize = true;
+    return isSizeAvailable();
+}
 
-        ImageObserver* observer = imageObserver();
+String BitmapImage::filenameExtension() const
+{
+    return m_source.filenameExtension();
+}
 
-        // Temporarily reset image observer, we don't want to receive any changeInRect() calls due to this relayout.
-        setImageObserver(nullptr);
+size_t BitmapImage::frameCount()
+{
+    if (!m_haveFrameCount) {
+        m_frameCount = m_source.frameCount();
+        // If decoder is not initialized yet, m_source.frameCount() returns 0.
+        if (m_frameCount) {
+            didDecodeProperties();
+            m_haveFrameCount = true;
+        }
+    }
+    return m_frameCount;
+}
 
-        draw(buffer->context(), tileRect, tileRect, op, blendMode, ImageOrientationDescription());
+bool BitmapImage::isSizeAvailable()
+{
+    if (m_sizeAvailable)
+        return true;
 
-        setImageObserver(observer);
-        buffer->convertToLuminanceMask();
+    m_sizeAvailable = m_source.isSizeAvailable();
+    didDecodeProperties();
 
-        m_cachedImage = buffer->copyImage(DontCopyBackingStore, Unscaled);
-        if (!m_cachedImage)
-            return;
+    return m_sizeAvailable;
+}
+
+bool BitmapImage::ensureFrameIsCached(size_t index, ImageFrameCaching frameCaching)
+{
+    if (index >= frameCount())
+        return false;
+
+    if (index >= m_frames.size()
+        || (frameCaching == CacheMetadataAndFrame && !m_frames[index].m_image)
+        || (frameCaching == CacheMetadataOnly && !m_frames[index].m_haveMetadata))
+        cacheFrame(index, 0, frameCaching);
+
+    return true;
+}
+
+NativeImagePtr BitmapImage::frameImageAtIndex(size_t index, float presentationScaleHint)
+{
+    if (index >= frameCount())
+        return nullptr;
+
+    SubsamplingLevel subsamplingLevel = std::min(m_source.subsamplingLevelForScale(presentationScaleHint), m_minimumSubsamplingLevel);
+
+    // We may have cached a frame with a higher subsampling level, in which case we need to
+    // re-decode with a lower level.
+    if (index < m_frames.size() && m_frames[index].m_image && subsamplingLevel < m_frames[index].m_subsamplingLevel) {
+        LOG(Images, "  subsamplingLevel was %d, resampling", static_cast<int>(m_frames[index].m_subsamplingLevel));
+
+        // If the image is already cached, but at too small a size, re-decode a larger version.
+        int sizeChange = -m_frames[index].m_frameBytes;
+        m_frames[index].clear(true);
+        invalidatePlatformData();
+        m_decodedSize += sizeChange;
+        if (imageObserver())
+            imageObserver()->decodedSizeChanged(this, sizeChange);
     }
 
-    ctxt.setDrawLuminanceMask(false);
-    m_cachedImage->drawPattern(ctxt, destRect, tileRect, transform, phase, spacing, op, blendMode);
+    // If we haven't fetched a frame yet, do so.
+    if (index >= m_frames.size() || !m_frames[index].m_image)
+        cacheFrame(index, subsamplingLevel, CacheMetadataAndFrame);
+
+    return m_frames[index].m_image;
 }
 
-bool BitmapImage::shouldAnimate()
+bool BitmapImage::frameIsCompleteAtIndex(size_t index)
 {
-    return repetitionCount() && !m_animationFinished && imageObserver();
+    if (!ensureFrameIsCached(index, CacheMetadataOnly))
+        return false;
+
+    return m_frames[index].m_isComplete;
 }
 
-bool BitmapImage::canAnimate()
+float BitmapImage::frameDurationAtIndex(size_t index)
 {
-    return shouldAnimate() && frameCount() > 1;
+    if (!ensureFrameIsCached(index, CacheMetadataOnly))
+        return 0;
+
+    return m_frames[index].m_duration;
 }
 
-void BitmapImage::clearTimer()
+NativeImagePtr BitmapImage::nativeImageForCurrentFrame()
 {
-    m_frameTimer = nullptr;
+    return frameImageAtIndex(currentFrame());
 }
 
-void BitmapImage::startTimer(double delay)
+bool BitmapImage::frameHasAlphaAtIndex(size_t index)
 {
-    ASSERT(!m_frameTimer);
-    m_frameTimer = std::make_unique<Timer>(*this, &BitmapImage::advanceAnimation);
-    m_frameTimer->startOneShot(delay);
+    if (!ensureFrameIsCached(index, CacheMetadataOnly))
+        return true;
+
+    if (m_frames[index].m_haveMetadata)
+        return m_frames[index].m_hasAlpha;
+
+    return m_source.frameHasAlphaAtIndex(index);
 }
 
-BitmapImage::StartAnimationResult BitmapImage::internalStartAnimation()
+bool BitmapImage::currentFrameKnownToBeOpaque()
 {
-    if (!canAnimate())
-        return StartAnimationResult::CannotStart;
+    return !frameHasAlphaAtIndex(currentFrame());
+}
 
-    if (m_frameTimer)
-        return StartAnimationResult::TimerActive;
-    
-    // Don't start a new animation until we draw the frame that is currently being decoded.
-    size_t nextFrame = (m_currentFrame + 1) % frameCount();
-    if (frameIsBeingDecodedAtIndex(nextFrame))
-        return StartAnimationResult::DecodingActive;
+ImageOrientation BitmapImage::frameOrientationAtIndex(size_t index)
+{
+    if (!ensureFrameIsCached(index, CacheMetadataOnly))
+        return ImageOrientation();
 
-    if (m_currentFrame >= frameCount() - 1) {
-        // Don't advance past the last frame if we haven't decoded the whole image
-        // yet and our repetition count is potentially unset. The repetition count
-        // in a GIF can potentially come after all the rest of the image data, so
-        // wait on it.
-        if (!m_source.isAllDataReceived() && repetitionCount() == RepetitionCountOnce)
-            return StartAnimationResult::IncompleteData;
+    if (m_frames[index].m_haveMetadata)
+        return m_frames[index].m_orientation;
 
-        ++m_repetitionsComplete;
+    return m_source.orientationAtIndex(index);
+}
 
-        // Check for the end of animation.
-        if (repetitionCount() != RepetitionCountInfinite && m_repetitionsComplete > repetitionCount()) {
-            m_animationFinished = true;
-            destroyDecodedDataIfNecessary(false);
-            return StartAnimationResult::CannotStart;
-        }
+#if !ASSERT_DISABLED
+bool BitmapImage::notSolidColor()
+{
+    return size().width() != 1 || size().height() != 1 || frameCount() > 1;
+}
+#endif
+
+int BitmapImage::repetitionCount(bool imageKnownToBeComplete)
+{
+    if ((m_repetitionCountStatus == Unknown) || ((m_repetitionCountStatus == Uncertain) && imageKnownToBeComplete)) {
+        // Snag the repetition count. If |imageKnownToBeComplete| is false, the
+        // repetition count may not be accurate yet for GIFs; in this case the
+        // decoder will default to cAnimationLoopOnce, and we'll try and read
+        // the count again once the whole image is decoded.
+        m_repetitionCount = m_source.repetitionCount();
+        didDecodeProperties();
+        m_repetitionCountStatus = (imageKnownToBeComplete || m_repetitionCount == cAnimationNone) ? Certain : Uncertain;
     }
+    return m_repetitionCount;
+}
 
-    // When looping on an animation, destroy de decoded data when in the first frame instead of the last one.
-    // If it's done in the last one and a redraw happens before the animation advances, we need to decode all
-    // the animation frames to get the last one again, which causes a delay in the animation. If this happens
-    // while in the first one, we only need to decode a single frame.
-    if (m_currentFrame == 0)
-        destroyDecodedDataIfNecessary(true);
+bool BitmapImage::shouldAnimate()
+{
+    return (repetitionCount(false) != cAnimationNone && !m_animationFinished && imageObserver());
+}
 
+void BitmapImage::startAnimation(CatchUpAnimation catchUpIfNecessary)
+{
+    if (m_frameTimer || !shouldAnimate() || frameCount() <= 1)
+        return;
+
+    // If we aren't already animating, set now as the animation start time.
+    const double time = monotonicallyIncreasingTime();
+    if (!m_desiredFrameStartTime)
+        m_desiredFrameStartTime = time;
 
     // Don't advance the animation to an incomplete frame.
-    if (!m_source.isAllDataReceived() && !frameIsCompleteAtIndex(nextFrame))
-        return StartAnimationResult::IncompleteData;
+    size_t nextFrame = (m_currentFrame + 1) % frameCount();
+    if (!m_allDataReceived && !frameIsCompleteAtIndex(nextFrame))
+        return;
+
+    // Don't advance past the last frame if we haven't decoded the whole image
+    // yet and our repetition count is potentially unset. The repetition count
+    // in a GIF can potentially come after all the rest of the image data, so
+    // wait on it.
+    if (!m_allDataReceived && repetitionCount(false) == cAnimationLoopOnce && m_currentFrame >= (frameCount() - 1))
+        return;
 
-    double time = monotonicallyIncreasingTime();
+    // Determine time for next frame to start. By ignoring paint and timer lag
+    // in this calculation, we make the animation appear to run at its desired
+    // rate regardless of how fast it's being repainted.
+    const double currentDuration = frameDurationAtIndex(m_currentFrame);
+    m_desiredFrameStartTime += currentDuration;
+
+#if !PLATFORM(IOS)
+    // When an animated image is more than five minutes out of date, the
+    // user probably doesn't care about resyncing and we could burn a lot of
+    // time looping through frames below. Just reset the timings.
+    const double cAnimationResyncCutoff = 5 * 60;
+    if ((time - m_desiredFrameStartTime) > cAnimationResyncCutoff)
+        m_desiredFrameStartTime = time + currentDuration;
+#else
+    // Maintaining frame-to-frame delays is more important than
+    // maintaining absolute animation timing, so reset the timings each frame.
+    m_desiredFrameStartTime = time + currentDuration;
+#endif
 
-    // Handle initial state.
-    if (!m_desiredFrameStartTime)
+    // The image may load more slowly than it's supposed to animate, so that by
+    // the time we reach the end of the first repetition, we're well behind.
+    // Clamp the desired frame start time in this case, so that we don't skip
+    // frames (or whole iterations) trying to "catch up". This is a tradeoff:
+    // It guarantees users see the whole animation the second time through and
+    // don't miss any repetitions, and is closer to what other browsers do; on
+    // the other hand, it makes animations "less accurate" for pages that try to
+    // sync an image and some other resource (e.g. audio), especially if users
+    // switch tabs (and thus stop drawing the animation, which will pause it)
+    // during that initial loop, then switch back later.
+    if (nextFrame == 0 && m_repetitionsComplete == 0 && m_desiredFrameStartTime < time)
         m_desiredFrameStartTime = time;
 
-    // Setting 'm_desiredFrameStartTime' to 'time' means we are late; otherwise we are early.
-    m_desiredFrameStartTime = std::max(time, m_desiredFrameStartTime + frameDurationAtIndex(m_currentFrame));
-
-    // Request async decoding for nextFrame only if this is required. If nextFrame is not in the frameCache,
-    // it will be decoded on a separate work queue. When decoding nextFrame finishes, we will be notified
-    // through the callback newFrameNativeImageAvailableAtIndex(). Otherwise, advanceAnimation() will be called
-    // when the timer fires and m_currentFrame will be advanced to nextFrame since it is not being decoded.
-    if ((allowAsyncImageDecoding() && m_source.isAsyncDecodingRequired()) || isAsyncDecodingForcedForTesting()) {
-        if (!m_source.requestFrameAsyncDecodingAtIndex(nextFrame, m_currentSubsamplingLevel))
-            LOG(Images, "BitmapImage %p %s - cachedFrameCount %ld nextFrame %ld", this, __FUNCTION__, ++m_cachedFrameCount, nextFrame);
-        m_desiredFrameDecodeTimeForTesting = time + std::max(m_frameDecodingDurationForTesting, 0.0f);
+    if (catchUpIfNecessary == DoNotCatchUp || time < m_desiredFrameStartTime) {
+        // Haven't yet reached time for next frame to start; delay until then.
+        startTimer(std::max<double>(m_desiredFrameStartTime - time, 0));
+        return;
     }
 
     ASSERT(!m_frameTimer);
-    startTimer(m_desiredFrameStartTime - time);
-    return StartAnimationResult::Started;
-}
 
-void BitmapImage::advanceAnimation()
-{
-    clearTimer();
+    // We've already reached or passed the time for the next frame to start.
+    // See if we've also passed the time for frames after that to start, in
+    // case we need to skip some frames entirely. Remember not to advance
+    // to an incomplete frame.
 
-    // Pretend as if decoding nextFrame has taken m_frameDecodingDurationForTesting from
-    // the time this decoding was requested.
-    if (isAsyncDecodingForcedForTesting()) {
-        double time = monotonicallyIncreasingTime();
-        // Start a timer with the remaining time from now till the m_desiredFrameDecodeTime.
-        if (m_desiredFrameDecodeTimeForTesting > std::max(time, m_desiredFrameStartTime)) {
-            startTimer(m_desiredFrameDecodeTimeForTesting - time);
+#if !LOG_DISABLED
+    size_t startCatchupFrameIndex = nextFrame;
+#endif
+
+    for (size_t frameAfterNext = (nextFrame + 1) % frameCount(); frameIsCompleteAtIndex(frameAfterNext); frameAfterNext = (nextFrame + 1) % frameCount()) {
+        // Should we skip the next frame?
+        double frameAfterNextStartTime = m_desiredFrameStartTime + frameDurationAtIndex(nextFrame);
+        if (time < frameAfterNextStartTime)
+            break;
+
+        // Yes; skip over it without notifying our observers. If we hit the end while catching up,
+        // tell the observer asynchronously.
+        if (!internalAdvanceAnimation(SkippingFramesToCatchUp)) {
+            m_animationFinishedWhenCatchingUp = true;
+            startTimer(0);
+            LOG(Images, "BitmapImage %p startAnimation catching up from frame %lu, ended", this, startCatchupFrameIndex);
             return;
         }
+        m_desiredFrameStartTime = frameAfterNextStartTime;
+        nextFrame = frameAfterNext;
     }
-    
-    // Don't advance to nextFrame unless its decoding has finished or was not required.
-    size_t nextFrame = (m_currentFrame + 1) % frameCount();
-    if (!frameIsBeingDecodedAtIndex(nextFrame))
-        internalAdvanceAnimation();
-    else {
-        // Force repaint if showDebugBackground() is on.
-        if (showDebugBackground())
-            imageObserver()->changedInRect(this);
-        LOG(Images, "BitmapImage %p %s - lateFrameCount %ld nextFrame %ld", this, __FUNCTION__, ++m_lateFrameCount, nextFrame);
-    }
-}
 
-void BitmapImage::internalAdvanceAnimation()
-{
-    m_currentFrame = (m_currentFrame + 1) % frameCount();
-    ASSERT(!frameIsBeingDecodedAtIndex(m_currentFrame));
+    LOG(Images, "BitmapImage %p startAnimation catching up jumped from from frame %lu to %d", this, startCatchupFrameIndex, (int)nextFrame - 1);
 
-    destroyDecodedDataIfNecessary(false);
-
-    if (imageObserver())
-        imageObserver()->animationAdvanced(this);
+    // Draw the next frame as soon as possible. Note that m_desiredFrameStartTime
+    // may be in the past, meaning the next time through this function we'll
+    // kick off the next advancement sooner than this frame's duration would suggest.
+    startTimer(0);
 }
 
 void BitmapImage::stopAnimation()
@@ -338,41 +595,143 @@ void BitmapImage::stopAnimation()
     // This timer is used to animate all occurrences of this image. Don't invalidate
     // the timer unless all renderers have stopped drawing.
     clearTimer();
-    m_source.stopAsyncDecodingQueue();
 }
 
 void BitmapImage::resetAnimation()
 {
     stopAnimation();
     m_currentFrame = 0;
-    m_repetitionsComplete = RepetitionCountNone;
+    m_repetitionsComplete = 0;
     m_desiredFrameStartTime = 0;
     m_animationFinished = false;
-
+    
     // For extremely large animations, when the animation is reset, we just throw everything away.
     destroyDecodedDataIfNecessary(true);
 }
 
-void BitmapImage::newFrameNativeImageAvailableAtIndex(size_t index)
+void BitmapImage::drawPattern(GraphicsContext& ctxt, const FloatRect& tileRect, const AffineTransform& transform,
+    const FloatPoint& phase, const FloatSize& spacing, CompositeOperator op, const FloatRect& destRect, BlendMode blendMode)
+{
+    if (tileRect.isEmpty())
+        return;
+
+    if (!ctxt.drawLuminanceMask()) {
+        Image::drawPattern(ctxt, tileRect, transform, phase, spacing, op, destRect, blendMode);
+        return;
+    }
+    if (!m_cachedImage) {
+        std::unique_ptr<ImageBuffer> buffer = ctxt.createCompatibleBuffer(expandedIntSize(tileRect.size()));
+        if (!buffer)
+            return;
+
+        ImageObserver* observer = imageObserver();
+        ASSERT(observer);
+
+        // Temporarily reset image observer, we don't want to receive any changeInRect() calls due to this relayout.
+        setImageObserver(nullptr);
+
+        draw(buffer->context(), tileRect, tileRect, op, blendMode, ImageOrientationDescription());
+
+        setImageObserver(observer);
+        buffer->convertToLuminanceMask();
+
+        m_cachedImage = buffer->copyImage(DontCopyBackingStore, Unscaled);
+        if (!m_cachedImage)
+            return;
+    }
+
+    ctxt.setDrawLuminanceMask(false);
+    m_cachedImage->drawPattern(ctxt, tileRect, transform, phase, spacing, op, destRect, blendMode);
+}
+
+
+void BitmapImage::advanceAnimation()
+{
+    internalAdvanceAnimation();
+    // At this point the image region has been marked dirty, and if it's
+    // onscreen, we'll soon make a call to draw(), which will call
+    // startAnimation() again to keep the animation moving.
+}
+
+bool BitmapImage::internalAdvanceAnimation(AnimationAdvancement advancement)
 {
-    UNUSED_PARAM(index);
-    ASSERT(index == (m_currentFrame + 1) % frameCount());
+    clearTimer();
+
+    if (m_animationFinishedWhenCatchingUp) {
+        imageObserver()->animationAdvanced(this);
+        m_animationFinishedWhenCatchingUp = false;
+        return false;
+    }
+    
+    ++m_currentFrame;
+    bool advancedAnimation = true;
+    bool destroyAll = false;
+    if (m_currentFrame >= frameCount()) {
+        ++m_repetitionsComplete;
 
-    // Don't advance to nextFrame unless the timer was fired before its decoding finishes.
-    if (canAnimate() && !m_frameTimer)
-        internalAdvanceAnimation();
-    else
-        LOG(Images, "BitmapImage %p %s - earlyFrameCount %ld nextFrame %ld", this, __FUNCTION__, ++m_earlyFrameCount, index);
+        // Get the repetition count again. If we weren't able to get a
+        // repetition count before, we should have decoded the whole image by
+        // now, so it should now be available.
+        // Note that we don't need to special-case cAnimationLoopOnce here
+        // because it is 0 (see comments on its declaration in ImageSource.h).
+        if (repetitionCount(true) != cAnimationLoopInfinite && m_repetitionsComplete > m_repetitionCount) {
+            m_animationFinished = true;
+            m_desiredFrameStartTime = 0;
+            --m_currentFrame;
+            advancedAnimation = false;
+        } else {
+            m_currentFrame = 0;
+            destroyAll = true;
+        }
+    }
+    destroyDecodedDataIfNecessary(destroyAll);
+
+    // We need to draw this frame if we advanced to it while not skipping, or if
+    // while trying to skip frames we hit the last frame and thus had to stop.
+    if (advancement == Normal && advancedAnimation)
+        imageObserver()->animationAdvanced(this);
+
+    return advancedAnimation;
+}
+
+bool BitmapImage::mayFillWithSolidColor()
+{
+    if (!m_checkedForSolidColor && frameCount() > 0) {
+        checkForSolidColor();
+        ASSERT(m_checkedForSolidColor);
+    }
+    return m_isSolidColor && !m_currentFrame;
+}
+
+Color BitmapImage::solidColor() const
+{
+    return m_solidColor;
+}
+    
+bool BitmapImage::canAnimate()
+{
+    return shouldAnimate() && frameCount() > 1;
 }
 
 void BitmapImage::dump(TextStream& ts) const
 {
     Image::dump(ts);
-    
-    if (isAnimated())
+
+    ts.dumpProperty("type", m_source.filenameExtension());
+
+    if (isAnimated()) {
+        ts.dumpProperty("frame-count", m_frameCount);
+        ts.dumpProperty("repetitions", m_repetitionCount);
         ts.dumpProperty("current-frame", m_currentFrame);
+    }
+    
+    if (allowSubsampling())
+        ts.dumpProperty("allow-subsampling", allowSubsampling());
+    if (m_isSolidColor)
+        ts.dumpProperty("solid-color", m_isSolidColor);
     
-    m_source.dump(ts);
+    if (m_imageOrientation != OriginTopLeft)
+        ts.dumpProperty("orientation", m_imageOrientation);
 }
 
 }
diff --git a/Source/WebCore/platform/graphics/BitmapImage.h b/Source/WebCore/platform/graphics/BitmapImage.h
index 89032dca4b1..00fba33ba41 100644
--- a/Source/WebCore/platform/graphics/BitmapImage.h
+++ b/Source/WebCore/platform/graphics/BitmapImage.h
@@ -25,11 +25,11 @@
  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
  */
 
-#pragma once
+#ifndef BitmapImage_h
+#define BitmapImage_h
 
 #include "Image.h"
 #include "Color.h"
-#include "ImageObserver.h"
 #include "ImageOrientation.h"
 #include "ImageSource.h"
 #include "IntSize.h"
@@ -47,10 +47,64 @@ typedef struct HBITMAP__ *HBITMAP;
 #endif
 
 namespace WebCore {
+    struct FrameData;
+}
+
+namespace WTF {
+    template<> struct VectorTraits<WebCore::FrameData> : public SimpleClassVectorTraits {
+        static const bool canInitializeWithMemset = false; // Not all FrameData members initialize to 0.
+    };
+}
+
+namespace WebCore {
 
 class Timer;
 
+// ================================================
+// FrameData Class
+// ================================================
+
+struct FrameData {
+public:
+    FrameData()
+        : m_orientation(DefaultImageOrientation)
+        , m_subsamplingLevel(0)
+        , m_duration(0)
+        , m_haveMetadata(false)
+        , m_isComplete(false)
+        , m_hasAlpha(true)
+        , m_frameBytes(0)
+    {
+    }
+
+    ~FrameData()
+    { 
+        clear(true);
+    }
+
+    // Clear the cached image data on the frame, and (optionally) the metadata.
+    // Returns whether there was cached image data to clear.
+    bool clear(bool clearMetadata);
+
+    NativeImagePtr m_image;
+    ImageOrientation m_orientation;
+    SubsamplingLevel m_subsamplingLevel;
+    float m_duration;
+    bool m_haveMetadata : 1;
+    bool m_isComplete : 1;
+    bool m_hasAlpha : 1;
+    unsigned m_frameBytes;
+};
+
+// =================================================
+// BitmapImage Class
+// =================================================
+
 class BitmapImage final : public Image {
+    friend class GeneratedImage;
+    friend class CrossfadeGeneratedImage;
+    friend class GradientImage;
+    friend class GraphicsContext;
 public:
     static Ref<BitmapImage> create(NativeImagePtr&& nativeImage, ImageObserver* observer = nullptr)
     {
@@ -65,46 +119,42 @@ public:
 #endif
     virtual ~BitmapImage();
     
-    bool hasSingleSecurityOrigin() const override { return true; }
-
-    bool dataChanged(bool allDataReceived) override;
-    unsigned decodedSize() const { return m_source.decodedSize(); }
-
-    bool isSizeAvailable() const { return m_source.isSizeAvailable(); }
-    size_t frameCount() const { return m_source.frameCount(); }
-    RepetitionCount repetitionCount() const { return m_source.repetitionCount(); }
-    String filenameExtension() const override { return m_source.filenameExtension(); }
-    Optional<IntPoint> hotSpot() const override { return m_source.hotSpot(); }
+    bool hasSingleSecurityOrigin() const override;
 
     // FloatSize due to override.
-    FloatSize size() const override { return m_source.size(); }
-    IntSize sizeRespectingOrientation() const { return m_source.sizeRespectingOrientation(); }
-    Color singlePixelSolidColor() const override { return m_source.singlePixelSolidColor(); }
+    FloatSize size() const override;
+    IntSize sizeRespectingOrientation(ImageOrientationDescription = ImageOrientationDescription()) const;
 
-    bool frameIsBeingDecodedAtIndex(size_t index) const { return m_source.frameIsBeingDecodedAtIndex(index); }
-    bool frameIsCompleteAtIndex(size_t index) const { return m_source.frameIsCompleteAtIndex(index); }
-    bool frameHasAlphaAtIndex(size_t index) const { return m_source.frameHasAlphaAtIndex(index); }
-    bool frameHasValidNativeImageAtIndex(size_t index, SubsamplingLevel subsamplingLevel) const { return m_source.frameHasValidNativeImageAtIndex(index, subsamplingLevel); }
-    SubsamplingLevel frameSubsamplingLevelAtIndex(size_t index) const { return m_source.frameSubsamplingLevelAtIndex(index); }
+    bool getHotSpot(IntPoint&) const override;
 
-    float frameDurationAtIndex(size_t index) const { return m_source.frameDurationAtIndex(index); }
-    ImageOrientation frameOrientationAtIndex(size_t index) const { return m_source.frameOrientationAtIndex(index); }
+    unsigned decodedSize() const { return m_decodedSize; }
 
-    size_t currentFrame() const { return m_currentFrame; }
-    bool currentFrameKnownToBeOpaque() const override { return !frameHasAlphaAtIndex(currentFrame()); }
-    ImageOrientation orientationForCurrentFrame() const override { return frameOrientationAtIndex(currentFrame()); }
+    bool dataChanged(bool allDataReceived) override;
+    String filenameExtension() const override;
 
-    bool isAsyncDecodingForcedForTesting() const { return m_frameDecodingDurationForTesting > 0; }
-    void setFrameDecodingDurationForTesting(float duration) { m_frameDecodingDurationForTesting = duration; }
+    // It may look unusual that there is no start animation call as public API. This is because
+    // we start and stop animating lazily. Animation begins whenever someone draws the image. It will
+    // automatically pause once all observers no longer want to render the image anywhere.
+    void stopAnimation() override;
+    void resetAnimation() override;
+
+    void drawPattern(GraphicsContext&, const FloatRect& srcRect, const AffineTransform& patternTransform,
+        const FloatPoint& phase, const FloatSize& spacing, CompositeOperator, const FloatRect& destRect, BlendMode = BlendModeNormal) override;
 
     // Accessors for native image formats.
+
 #if USE(APPKIT)
-    NSImage *nsImage() override;
-    RetainPtr<NSImage> snapshotNSImage() override;
+    NSImage* getNSImage() override;
 #endif
 
 #if PLATFORM(COCOA)
-    CFDataRef tiffRepresentation() override;
+    CFDataRef getTIFFRepresentation() override;
+#endif
+
+#if USE(CG)
+    WEBCORE_EXPORT CGImageRef getCGImageRef() override;
+    CGImageRef getFirstCGImageRefOfSize(const IntSize&) override;
+    RetainPtr<CFArrayRef> getCGImageArray() override;
 #endif
 
 #if PLATFORM(WIN)
@@ -120,22 +170,64 @@ public:
     Evas_Object* getEvasObject(Evas*) override;
 #endif
 
-    WEBCORE_EXPORT NativeImagePtr nativeImage(const GraphicsContext* = nullptr) override;
-    NativeImagePtr nativeImageForCurrentFrame(const GraphicsContext* = nullptr) override;
-#if USE(CG)
-    NativeImagePtr nativeImageOfSize(const IntSize&, const GraphicsContext* = nullptr) override;
-    Vector<NativeImagePtr> framesNativeImages() override;
-#endif
+    NativeImagePtr nativeImageForCurrentFrame() override;
+    ImageOrientation orientationForCurrentFrame() override { return frameOrientationAtIndex(currentFrame()); }
+
+    bool currentFrameKnownToBeOpaque() override;
+
+    bool isAnimated() const override { return m_frameCount > 1; }
+    
+    bool canAnimate();
+
+    bool allowSubsampling() const { return m_allowSubsampling; }
+    void setAllowSubsampling(bool allowSubsampling) { m_allowSubsampling = allowSubsampling; }
+
+    size_t currentFrame() const { return m_currentFrame; }
+    
+private:
+    bool isBitmapImage() const override { return true; }
+
+    void updateSize(ImageOrientationDescription = ImageOrientationDescription()) const;
+    void determineMinimumSubsamplingLevel() const;
 
 protected:
+    enum RepetitionCountStatus {
+      Unknown,    // We haven't checked the source's repetition count.
+      Uncertain,  // We have a repetition count, but it might be wrong (some GIFs have a count after the image data, and will report "loop once" until all data has been decoded).
+      Certain     // The repetition count is known to be correct.
+    };
+
     WEBCORE_EXPORT BitmapImage(NativeImagePtr&&, ImageObserver* = nullptr);
     WEBCORE_EXPORT BitmapImage(ImageObserver* = nullptr);
 
-    NativeImagePtr frameImageAtIndex(size_t, SubsamplingLevel = SubsamplingLevel::Default, const GraphicsContext* = nullptr);
+#if PLATFORM(WIN)
+    void drawFrameMatchingSourceSize(GraphicsContext&, const FloatRect& dstRect, const IntSize& srcSize, CompositeOperator) override;
+#endif
+    void draw(GraphicsContext&, const FloatRect& dstRect, const FloatRect& srcRect, CompositeOperator, BlendMode, ImageOrientationDescription) override;
+
+#if USE(WINGDI)
+    virtual void drawPattern(GraphicsContext&, const FloatRect& srcRect, const AffineTransform& patternTransform,
+        const FloatPoint& phase, const FloatSize& spacing, CompositeOperator, const FloatRect& destRect);
+#endif
+
+    size_t frameCount();
 
-    bool allowSubsampling() const { return imageObserver() && imageObserver()->allowSubsampling(); }
-    bool allowAsyncImageDecoding() const { return imageObserver() && imageObserver()->allowAsyncImageDecoding(); }
-    bool showDebugBackground() const { return imageObserver() && imageObserver()->showDebugBackground(); }
+    NativeImagePtr frameImageAtIndex(size_t, float presentationScaleHint = 1);
+    NativeImagePtr copyUnscaledFrameImageAtIndex(size_t);
+
+    bool haveFrameImageAtIndex(size_t);
+
+    bool frameIsCompleteAtIndex(size_t);
+    float frameDurationAtIndex(size_t);
+    bool frameHasAlphaAtIndex(size_t);
+    ImageOrientation frameOrientationAtIndex(size_t);
+
+    // Decodes and caches a frame. Never accessed except internally.
+    enum ImageFrameCaching { CacheMetadataOnly, CacheMetadataAndFrame };
+    void cacheFrame(size_t index, SubsamplingLevel, ImageFrameCaching = CacheMetadataAndFrame);
+
+    // Called before accessing m_frames[index] for info without decoding. Returns false on index out of bounds.
+    bool ensureFrameIsCached(size_t index, ImageFrameCaching = CacheMetadataAndFrame);
 
     // Called to invalidate cached data. When |destroyAll| is true, we wipe out
     // the entire frame buffer cache and tell the image source to destroy
@@ -147,74 +239,113 @@ protected:
 
     // If the image is large enough, calls destroyDecodedData() and passes
     // |destroyAll| along.
-    void destroyDecodedDataIfNecessary(bool destroyAll = true);
+    void destroyDecodedDataIfNecessary(bool destroyAll);
 
-    void draw(GraphicsContext&, const FloatRect& dstRect, const FloatRect& srcRect, CompositeOperator, BlendMode, ImageOrientationDescription) override;
-    void drawPattern(GraphicsContext&, const FloatRect& destRect, const FloatRect& srcRect, const AffineTransform& patternTransform, const FloatPoint& phase, const FloatSize& spacing, CompositeOperator, BlendMode = BlendModeNormal) override;
-#if PLATFORM(WIN)
-    void drawFrameMatchingSourceSize(GraphicsContext&, const FloatRect& dstRect, const IntSize& srcSize, CompositeOperator) override;
-#endif
+    // Generally called by destroyDecodedData(), destroys whole-image metadata
+    // and notifies observers that the memory footprint has (hopefully)
+    // decreased by |frameBytesCleared|.
+    enum class ClearedSource { No, Yes };
+    void destroyMetadataAndNotify(unsigned frameBytesCleared, ClearedSource);
+
+    // Whether or not size is available yet.
+    bool isSizeAvailable();
+
+    // Called after asking the source for any information that may require
+    // decoding part of the image (e.g., the image size). We need to report
+    // the partially decoded data to our observer so it has an accurate
+    // account of the BitmapImage's memory usage.
+    void didDecodeProperties() const;
 
     // Animation.
-    enum class StartAnimationResult { CannotStart, IncompleteData, TimerActive, DecodingActive, Started };
-    bool isAnimated() const override { return m_source.frameCount() > 1; }
+    int repetitionCount(bool imageKnownToBeComplete);  // |imageKnownToBeComplete| should be set if the caller knows the entire image has been decoded.
     bool shouldAnimate();
-    bool canAnimate();
-    void startAnimation() override { internalStartAnimation(); }
-    StartAnimationResult internalStartAnimation();
+    void startAnimation(CatchUpAnimation = CatchUp) override;
     void advanceAnimation();
-    void internalAdvanceAnimation();
 
-    // It may look unusual that there is no start animation call as public API. This is because
-    // we start and stop animating lazily. Animation begins whenever someone draws the image. It will
-    // automatically pause once all observers no longer want to render the image anywhere.
-    void stopAnimation() override;
-    void resetAnimation() override;
-    void newFrameNativeImageAvailableAtIndex(size_t) override;
+    // Function that does the real work of advancing the animation. When
+    // skippingFrames is true, we're in the middle of a loop trying to skip over
+    // a bunch of animation frames, so we should not do things like decode each
+    // one or notify our observers.
+    // Returns whether the animation was advanced.
+    enum AnimationAdvancement { Normal, SkippingFramesToCatchUp };
+    bool internalAdvanceAnimation(AnimationAdvancement = Normal);
 
     // Handle platform-specific data
     void invalidatePlatformData();
 
+    // Checks to see if the image is a 1x1 solid color. We optimize these images and just do a fill rect instead.
+    // This check should happen regardless whether m_checkedForSolidColor is already set, as the frame may have
+    // changed.
+    void checkForSolidColor();
+
+    bool mayFillWithSolidColor() override;
+    Color solidColor() const override;
+
 #if !ASSERT_DISABLED
     bool notSolidColor() override;
 #endif
 
-#if PLATFORM(COCOA)
-    RetainPtr<CFDataRef> tiffRepresentation(const Vector<NativeImagePtr>&);
-#endif
-
 private:
     void clearTimer();
     void startTimer(double delay);
-    bool isBitmapImage() const override { return true; }
+
     void dump(TextStream&) const override;
 
-    mutable ImageSource m_source;
+    ImageSource m_source;
+    mutable IntSize m_size; // The size to use for the overall image (will just be the size of the first image).
+    mutable IntSize m_sizeRespectingOrientation;
 
-    size_t m_currentFrame { 0 }; // The index of the current frame of animation.
-    SubsamplingLevel m_currentSubsamplingLevel { SubsamplingLevel::Default };
-    std::unique_ptr<Timer> m_frameTimer;
-    RepetitionCount m_repetitionsComplete { RepetitionCountNone }; // How many repetitions we've finished.
-    double m_desiredFrameStartTime { 0 }; // The system time at which we hope to see the next call to startAnimation().
-    bool m_animationFinished { false };
+    mutable SubsamplingLevel m_minimumSubsamplingLevel;
 
-    float m_frameDecodingDurationForTesting { 0 };
-    double m_desiredFrameDecodeTimeForTesting { 0 };
-#if !LOG_DISABLED
-    size_t m_lateFrameCount { 0 };
-    size_t m_earlyFrameCount { 0 };
-    size_t m_cachedFrameCount { 0 };
-#endif
+    mutable unsigned m_imageOrientation : 4; // ImageOrientationEnum
+    mutable unsigned m_shouldRespectImageOrientation : 1; // RespectImageOrientationEnum
+
+    size_t m_currentFrame; // The index of the current frame of animation.
+    Vector<FrameData, 1> m_frames; // An array of the cached frames of the animation. We have to ref frames to pin them in the cache.
+
+    std::unique_ptr<Timer> m_frameTimer;
+    int m_repetitionCount; // How many total animation loops we should do. This will be cAnimationNone if this image type is incapable of animation.
+    RepetitionCountStatus m_repetitionCountStatus;
+    int m_repetitionsComplete;  // How many repetitions we've finished.
+    double m_desiredFrameStartTime;  // The system time at which we hope to see the next call to startAnimation().
 
 #if USE(APPKIT)
-    mutable RetainPtr<NSImage> m_nsImage; // A cached NSImage of all the frames. Only built lazily if someone actually queries for one.
+    mutable RetainPtr<NSImage> m_nsImage; // A cached NSImage of frame 0. Only built lazily if someone actually queries for one.
 #endif
 #if USE(CG)
-    mutable RetainPtr<CFDataRef> m_tiffRep; // Cached TIFF rep for all the frames. Only built lazily if someone queries for one.
+    mutable RetainPtr<CFDataRef> m_tiffRep; // Cached TIFF rep for frame 0. Only built lazily if someone queries for one.
+#endif
+
+    Color m_solidColor;  // If we're a 1x1 solid color, this is the color to use to fill.
+
+    unsigned m_decodedSize; // The current size of all decoded frames.
+    mutable unsigned m_decodedPropertiesSize; // The size of data decoded by the source to determine image properties (e.g. size, frame count, etc).
+    size_t m_frameCount;
+
+#if PLATFORM(IOS)
+    // FIXME: We should expose a setting to enable/disable progressive loading remove the PLATFORM(IOS)-guard.
+    double m_progressiveLoadChunkTime;
+    uint16_t m_progressiveLoadChunkCount;
 #endif
+
+    bool m_allowSubsampling : 1; // Whether we should attempt subsampling if this image is very large.
+    bool m_isSolidColor : 1; // Whether or not we are a 1x1 solid image.
+    bool m_checkedForSolidColor : 1; // Whether we've checked the frame for solid color.
+
+    bool m_animationFinished : 1; // Whether or not we've completed the entire animation.
+
+    bool m_allDataReceived : 1; // Whether or not we've received all our data.
+    mutable bool m_haveSize : 1; // Whether or not our |m_size| member variable has the final overall image size yet.
+    bool m_sizeAvailable : 1; // Whether or not we can obtain the size of the first image frame yet from ImageIO.
+    mutable bool m_hasUniformFrameSize : 1;
+    mutable bool m_haveFrameCount : 1;
+    bool m_animationFinishedWhenCatchingUp : 1;
+
     RefPtr<Image> m_cachedImage;
 };
 
 } // namespace WebCore
 
 SPECIALIZE_TYPE_TRAITS_IMAGE(BitmapImage)
+
+#endif // BitmapImage_h
diff --git a/Source/WebCore/platform/graphics/Color.cpp b/Source/WebCore/platform/graphics/Color.cpp
index 562fe5ecfd2..bd99ac19666 100644
--- a/Source/WebCore/platform/graphics/Color.cpp
+++ b/Source/WebCore/platform/graphics/Color.cpp
@@ -49,16 +49,6 @@ const RGBA32 Color::transparent;
 static const RGBA32 lightenedBlack = 0xFF545454;
 static const RGBA32 darkenedWhite = 0xFFABABAB;
 
-static inline unsigned premultipliedChannel(unsigned c, unsigned a)
-{
-    return fastDivideBy255(c * a + 254);
-}
-
-static inline unsigned unpremultipliedChannel(unsigned c, unsigned a)
-{
-    return (fastMultiplyBy255(c) + a - 1) / a;
-}
-
 RGBA32 makeRGB(int r, int g, int b)
 {
     return 0xFF000000 | std::max(0, std::min(r, 255)) << 16 | std::max(0, std::min(g, 255)) << 8 | std::max(0, std::min(b, 255));
@@ -69,16 +59,6 @@ RGBA32 makeRGBA(int r, int g, int b, int a)
     return std::max(0, std::min(a, 255)) << 24 | std::max(0, std::min(r, 255)) << 16 | std::max(0, std::min(g, 255)) << 8 | std::max(0, std::min(b, 255));
 }
 
-RGBA32 makePremultipliedRGBA(int r, int g, int b, int a)
-{
-    return makeRGBA(premultipliedChannel(r, a), premultipliedChannel(g, a), premultipliedChannel(b, a), a);
-}
-
-RGBA32 makeUnPremultipliedRGBA(int r, int g, int b, int a)
-{
-    return makeRGBA(unpremultipliedChannel(r, a), unpremultipliedChannel(g, a), unpremultipliedChannel(b, a), a);
-}
-
 static int colorFloatToRGBAByte(float f)
 {
     // We use lroundf and 255 instead of nextafterf(256, 0) to match CG's rounding
@@ -606,9 +586,14 @@ void Color::getHSV(double& hue, double& saturation, double& value) const
 Color colorFromPremultipliedARGB(RGBA32 pixelColor)
 {
     int alpha = alphaChannel(pixelColor);
-    if (alpha && alpha < 255)
-        pixelColor = makeUnPremultipliedRGBA(redChannel(pixelColor), greenChannel(pixelColor), blueChannel(pixelColor), alpha);
-    return Color(pixelColor);
+    if (alpha && alpha < 255) {
+        return Color::createUnchecked(
+            redChannel(pixelColor) * 255 / alpha,
+            greenChannel(pixelColor) * 255 / alpha,
+            blueChannel(pixelColor) * 255 / alpha,
+            alpha);
+    } else
+        return Color(pixelColor);
 }
 
 RGBA32 premultipliedARGBFromColor(const Color& color)
@@ -616,10 +601,14 @@ RGBA32 premultipliedARGBFromColor(const Color& color)
     unsigned pixelColor;
 
     unsigned alpha = color.alpha();
-    if (alpha < 255)
-        pixelColor = makePremultipliedRGBA(color.red(), color.green(), color.blue(), alpha);
-    else
-        pixelColor = color.rgb();
+    if (alpha < 255) {
+        pixelColor = Color::createUnchecked(
+            fastDivideBy255(color.red() * alpha + 254),
+            fastDivideBy255(color.green() * alpha + 254),
+            fastDivideBy255(color.blue() * alpha + 254),
+            alpha).rgb();
+    } else
+         pixelColor = color.rgb();
 
     return pixelColor;
 }
diff --git a/Source/WebCore/platform/graphics/Color.h b/Source/WebCore/platform/graphics/Color.h
index c5b5703bcd3..295dae32b0c 100644
--- a/Source/WebCore/platform/graphics/Color.h
+++ b/Source/WebCore/platform/graphics/Color.h
@@ -45,8 +45,6 @@ struct _D3DCOLORVALUE;
 typedef _D3DCOLORVALUE D3DCOLORVALUE;
 typedef D3DCOLORVALUE D2D_COLOR_F;
 typedef D2D_COLOR_F D2D1_COLOR_F;
-struct D2D_VECTOR_4F;
-typedef D2D_VECTOR_4F D2D1_VECTOR_4F;
 #endif
 
 #if PLATFORM(GTK)
@@ -65,9 +63,6 @@ typedef unsigned RGBA32; // Deprecated: Type for an RGBA quadruplet. Use RGBA cl
 WEBCORE_EXPORT RGBA32 makeRGB(int r, int g, int b);
 WEBCORE_EXPORT RGBA32 makeRGBA(int r, int g, int b, int a);
 
-RGBA32 makePremultipliedRGBA(int r, int g, int b, int a);
-RGBA32 makeUnPremultipliedRGBA(int r, int g, int b, int a);
-
 WEBCORE_EXPORT RGBA32 colorWithOverrideAlpha(RGBA32 color, float overrideAlpha);
 RGBA32 colorWithOverrideAlpha(RGBA32 color, Optional<float> overrideAlpha);
 
@@ -249,7 +244,6 @@ public:
 #if PLATFORM(WIN)
     WEBCORE_EXPORT Color(D2D1_COLOR_F);
     WEBCORE_EXPORT operator D2D1_COLOR_F() const;
-    WEBCORE_EXPORT operator D2D1_VECTOR_4F() const;
 #endif
 
     static bool parseHexColor(const String&, RGBA32&);
@@ -264,7 +258,6 @@ public:
     static const RGBA32 lightGray = 0xFFC0C0C0;
     WEBCORE_EXPORT static const RGBA32 transparent = 0x00000000;
     static const RGBA32 cyan = 0xFF00FFFF;
-    static const RGBA32 yellow = 0xFFFFFF00;
 
 #if PLATFORM(IOS)
     static const RGBA32 compositionFill = 0x3CAFC0E3;
@@ -318,7 +311,6 @@ Color blend(const Color& from, const Color& to, double progress, bool blendPremu
 
 int differenceSquared(const Color&, const Color&);
 
-uint16_t fastMultiplyBy255(uint16_t value);
 uint16_t fastDivideBy255(uint16_t);
 
 #if USE(CG)
@@ -394,11 +386,6 @@ inline uint8_t roundAndClampColorChannel(float value)
 #endif
 }
 
-inline uint16_t fastMultiplyBy255(uint16_t value)
-{
-    return (value << 8) - value;
-}
-
 inline uint16_t fastDivideBy255(uint16_t value)
 {
     // While this is an approximate algorithm for division by 255, it gives perfectly accurate results for 16-bit values.
diff --git a/Source/WebCore/platform/graphics/CrossfadeGeneratedImage.cpp b/Source/WebCore/platform/graphics/CrossfadeGeneratedImage.cpp
index 3a229c61b73..a6ad51b62a1 100644
--- a/Source/WebCore/platform/graphics/CrossfadeGeneratedImage.cpp
+++ b/Source/WebCore/platform/graphics/CrossfadeGeneratedImage.cpp
@@ -99,7 +99,7 @@ void CrossfadeGeneratedImage::draw(GraphicsContext& context, const FloatRect& ds
     drawCrossfade(context);
 }
 
-void CrossfadeGeneratedImage::drawPattern(GraphicsContext& context, const FloatRect& dstRect, const FloatRect& srcRect, const AffineTransform& patternTransform, const FloatPoint& phase, const FloatSize& spacing, CompositeOperator compositeOp, BlendMode blendMode)
+void CrossfadeGeneratedImage::drawPattern(GraphicsContext& context, const FloatRect& srcRect, const AffineTransform& patternTransform, const FloatPoint& phase, const FloatSize& spacing, CompositeOperator compositeOp, const FloatRect& dstRect, BlendMode blendMode)
 {
     std::unique_ptr<ImageBuffer> imageBuffer = ImageBuffer::create(size(), context.renderingMode());
     if (!imageBuffer)
@@ -110,7 +110,7 @@ void CrossfadeGeneratedImage::drawPattern(GraphicsContext& context, const FloatR
     drawCrossfade(graphicsContext);
 
     // Tile the image buffer into the context.
-    imageBuffer->drawPattern(context, dstRect, srcRect, patternTransform, phase, spacing, compositeOp, blendMode);
+    imageBuffer->drawPattern(context, srcRect, patternTransform, phase, spacing, compositeOp, dstRect, blendMode);
 }
 
 void CrossfadeGeneratedImage::dump(TextStream& ts) const
diff --git a/Source/WebCore/platform/graphics/CrossfadeGeneratedImage.h b/Source/WebCore/platform/graphics/CrossfadeGeneratedImage.h
index c7849a71570..9ec9b209585 100644
--- a/Source/WebCore/platform/graphics/CrossfadeGeneratedImage.h
+++ b/Source/WebCore/platform/graphics/CrossfadeGeneratedImage.h
@@ -50,7 +50,7 @@ public:
 
 protected:
     void draw(GraphicsContext&, const FloatRect& dstRect, const FloatRect& srcRect, CompositeOperator, BlendMode, ImageOrientationDescription) override;
-    void drawPattern(GraphicsContext&, const FloatRect& dstRect, const FloatRect& srcRect, const AffineTransform& patternTransform, const FloatPoint& phase, const FloatSize& spacing, CompositeOperator, BlendMode) override;
+    void drawPattern(GraphicsContext&, const FloatRect& srcRect, const AffineTransform& patternTransform, const FloatPoint& phase, const FloatSize& spacing, CompositeOperator, const FloatRect& dstRect, BlendMode) override;
 
     CrossfadeGeneratedImage(Image& fromImage, Image& toImage, float percentage, const FloatSize& crossfadeSize, const FloatSize&);
 
diff --git a/Source/WebCore/platform/graphics/FloatSize.h b/Source/WebCore/platform/graphics/FloatSize.h
index c7c4de74f3a..ca6fc76e95a 100644
--- a/Source/WebCore/platform/graphics/FloatSize.h
+++ b/Source/WebCore/platform/graphics/FloatSize.h
@@ -113,11 +113,6 @@ public:
     {
         return m_width * m_width + m_height * m_height;
     }
-    
-    float area() const
-    {
-        return m_width * m_height;
-    }
 
     FloatSize transposedSize() const
     {
@@ -135,7 +130,7 @@ public:
 #endif
 
 #if PLATFORM(WIN)
-    WEBCORE_EXPORT FloatSize(const D2D1_SIZE_F&);
+    WEBCORE_EXPORT explicit FloatSize(const D2D1_SIZE_F&); // don't do this implicitly since it's lossy
     operator D2D1_SIZE_F() const;
 #endif
 
@@ -183,11 +178,6 @@ inline FloatSize operator*(float a, const FloatSize& b)
     return FloatSize(a * b.width(), a * b.height());
 }
 
-inline FloatSize operator*(const FloatSize& a, const FloatSize& b)
-{
-    return FloatSize(a.width() * b.width(), a.height() * b.height());
-}
-
 inline FloatSize operator/(const FloatSize& a, float b)
 {
     return FloatSize(a.width() / b, a.height() / b);
diff --git a/Source/WebCore/platform/graphics/GeneratedImage.h b/Source/WebCore/platform/graphics/GeneratedImage.h
index 7d9fe358d5c..e2b5d82ef35 100644
--- a/Source/WebCore/platform/graphics/GeneratedImage.h
+++ b/Source/WebCore/platform/graphics/GeneratedImage.h
@@ -48,11 +48,11 @@ public:
 
 protected:
     void draw(GraphicsContext&, const FloatRect& dstRect, const FloatRect& srcRect, CompositeOperator, BlendMode, ImageOrientationDescription) override = 0;
-    void drawPattern(GraphicsContext&, const FloatRect& destRect, const FloatRect& srcRect, const AffineTransform& patternTransform,
-        const FloatPoint& phase, const FloatSize& spacing, CompositeOperator, BlendMode) override = 0;
+    void drawPattern(GraphicsContext&, const FloatRect& srcRect, const AffineTransform& patternTransform,
+        const FloatPoint& phase, const FloatSize& spacing, CompositeOperator, const FloatRect& destRect, BlendMode) override = 0;
 
     // FIXME: Implement this to be less conservative.
-    bool currentFrameKnownToBeOpaque() const override { return false; }
+    bool currentFrameKnownToBeOpaque() override { return false; }
 
     GeneratedImage() { }
 
diff --git a/Source/WebCore/platform/graphics/GradientImage.cpp b/Source/WebCore/platform/graphics/GradientImage.cpp
index d6198937b37..372691a9b2b 100644
--- a/Source/WebCore/platform/graphics/GradientImage.cpp
+++ b/Source/WebCore/platform/graphics/GradientImage.cpp
@@ -56,8 +56,8 @@ void GradientImage::draw(GraphicsContext& destContext, const FloatRect& destRect
     destContext.fillRect(FloatRect(FloatPoint(), size()), *m_gradient.get());
 }
 
-void GradientImage::drawPattern(GraphicsContext& destContext, const FloatRect& destRect, const FloatRect& srcRect, const AffineTransform& patternTransform,
-    const FloatPoint& phase, const FloatSize& spacing, CompositeOperator compositeOp, BlendMode blendMode)
+void GradientImage::drawPattern(GraphicsContext& destContext, const FloatRect& srcRect, const AffineTransform& patternTransform,
+    const FloatPoint& phase, const FloatSize& spacing, CompositeOperator compositeOp, const FloatRect& destRect, BlendMode blendMode)
 {
     // Allow the generator to provide visually-equivalent tiling parameters for better performance.
     FloatSize adjustedSize = size();
@@ -74,8 +74,8 @@ void GradientImage::drawPattern(GraphicsContext& destContext, const FloatRect& d
 
     unsigned generatorHash = m_gradient->hash();
 
-    if (!m_cachedImageBuffer || m_cachedGeneratorHash != generatorHash || m_cachedAdjustedSize != adjustedSize || !m_cachedImageBuffer->isCompatibleWithContext(destContext)) {
-        m_cachedImageBuffer = ImageBuffer::createCompatibleBuffer(adjustedSize, ColorSpaceSRGB, destContext);
+    if (!m_cachedImageBuffer || m_cachedGeneratorHash != generatorHash || m_cachedAdjustedSize != adjustedSize || !destContext.isCompatibleWithBuffer(*m_cachedImageBuffer)) {
+        m_cachedImageBuffer = destContext.createCompatibleBuffer(adjustedSize, m_gradient->hasAlpha());
         if (!m_cachedImageBuffer)
             return;
 
@@ -92,7 +92,7 @@ void GradientImage::drawPattern(GraphicsContext& destContext, const FloatRect& d
     destContext.setDrawLuminanceMask(false);
 
     // Tile the image buffer into the context.
-    m_cachedImageBuffer->drawPattern(destContext, destRect, adjustedSrcRect, adjustedPatternCTM, phase, spacing, compositeOp, blendMode);
+    m_cachedImageBuffer->drawPattern(destContext, adjustedSrcRect, adjustedPatternCTM, phase, spacing, compositeOp, destRect, blendMode);
 }
 
 void GradientImage::dump(TextStream& ts) const
diff --git a/Source/WebCore/platform/graphics/GradientImage.h b/Source/WebCore/platform/graphics/GradientImage.h
index d2ceb2603b8..063963032f1 100644
--- a/Source/WebCore/platform/graphics/GradientImage.h
+++ b/Source/WebCore/platform/graphics/GradientImage.h
@@ -47,8 +47,8 @@ public:
 
 protected:
     void draw(GraphicsContext&, const FloatRect& dstRect, const FloatRect& srcRect, CompositeOperator, BlendMode, ImageOrientationDescription) override;
-    void drawPattern(GraphicsContext&, const FloatRect& destRect, const FloatRect& srcRect, const AffineTransform& patternTransform,
-        const FloatPoint& phase, const FloatSize& spacing, CompositeOperator, BlendMode) override;
+    void drawPattern(GraphicsContext&, const FloatRect& srcRect, const AffineTransform& patternTransform,
+        const FloatPoint& phase, const FloatSize& spacing, CompositeOperator, const FloatRect& destRect, BlendMode) override;
 
     GradientImage(PassRefPtr<Gradient>, const FloatSize&);
 
diff --git a/Source/WebCore/platform/graphics/GraphicsContext.cpp b/Source/WebCore/platform/graphics/GraphicsContext.cpp
index c77344299ca..fc927b3791a 100644
--- a/Source/WebCore/platform/graphics/GraphicsContext.cpp
+++ b/Source/WebCore/platform/graphics/GraphicsContext.cpp
@@ -835,7 +835,7 @@ void GraphicsContext::clipOutRoundedRect(const FloatRoundedRect& rect)
     clipOut(path);
 }
 
-#if !USE(CG) && !USE(DIRECT2D) && !USE(CAIRO)
+#if !USE(CG) && !USE(CAIRO)
 IntRect GraphicsContext::clipBounds() const
 {
     ASSERT_NOT_REACHED();
@@ -903,7 +903,7 @@ void GraphicsContext::fillRoundedRect(const FloatRoundedRect& rect, const Color&
         fillRect(rect.rect(), color, compositeOperation(), blendMode);
 }
 
-#if !USE(CG) && !USE(DIRECT2D) && !USE(CAIRO)
+#if !USE(CG) && !USE(CAIRO)
 void GraphicsContext::fillRectWithRoundedHole(const IntRect& rect, const FloatRoundedRect& roundedHoleRect, const Color& color)
 {
     if (paintingDisabled())
@@ -958,7 +958,7 @@ void GraphicsContext::setDrawLuminanceMask(bool drawLuminanceMask)
         m_displayListRecorder->updateState(m_state, GraphicsContextState::DrawLuminanceMaskChange);
 }
 
-#if !USE(CG) && !USE(DIRECT2D)
+#if !USE(CG)
 // Implement this if you want to go push the drawing mode into your native context immediately.
 void GraphicsContext::setPlatformTextDrawingMode(TextDrawingModeFlags)
 {
@@ -971,13 +971,13 @@ void GraphicsContext::setPlatformStrokeStyle(StrokeStyle)
 }
 #endif
 
-#if !USE(CG) && !USE(DIRECT2D)
+#if !USE(CG)
 void GraphicsContext::setPlatformShouldSmoothFonts(bool)
 {
 }
 #endif
 
-#if !USE(CG) && !USE(DIRECT2D) && !USE(CAIRO)
+#if !USE(CG) && !USE(CAIRO)
 bool GraphicsContext::isAcceleratedContext() const
 {
     return false;
@@ -1013,7 +1013,37 @@ void GraphicsContext::adjustLineToPixelBoundaries(FloatPoint& p1, FloatPoint& p2
     }
 }
 
-#if !USE(CG) && !USE(DIRECT2D)
+static bool scalesMatch(AffineTransform a, AffineTransform b)
+{
+    return a.xScale() == b.xScale() && a.yScale() == b.yScale();
+}
+
+std::unique_ptr<ImageBuffer> GraphicsContext::createCompatibleBuffer(const FloatSize& size, bool hasAlpha) const
+{
+    // Make the buffer larger if the context's transform is scaling it so we need a higher
+    // resolution than one pixel per unit. Also set up a corresponding scale factor on the
+    // graphics context.
+
+    AffineTransform transform = getCTM(DefinitelyIncludeDeviceScale);
+    FloatSize scaledSize(static_cast<int>(ceil(size.width() * transform.xScale())), static_cast<int>(ceil(size.height() * transform.yScale())));
+
+    std::unique_ptr<ImageBuffer> buffer = ImageBuffer::createCompatibleBuffer(scaledSize, 1, ColorSpaceSRGB, *this, hasAlpha);
+    if (!buffer)
+        return nullptr;
+
+    buffer->context().scale(FloatSize(scaledSize.width() / size.width(), scaledSize.height() / size.height()));
+
+    return buffer;
+}
+
+bool GraphicsContext::isCompatibleWithBuffer(ImageBuffer& buffer) const
+{
+    GraphicsContext& bufferContext = buffer.context();
+
+    return scalesMatch(getCTM(), bufferContext.getCTM()) && isAcceleratedContext() == bufferContext.isAcceleratedContext();
+}
+
+#if !USE(CG)
 void GraphicsContext::platformApplyDeviceScaleFactor(float)
 {
 }
@@ -1030,12 +1060,6 @@ void GraphicsContext::applyDeviceScaleFactor(float deviceScaleFactor)
 
     platformApplyDeviceScaleFactor(deviceScaleFactor);
 }
-    
-FloatSize GraphicsContext::scaleFactor() const
-{
-    AffineTransform transform = getCTM(GraphicsContext::DefinitelyIncludeDeviceScale);
-    return FloatSize(transform.xScale(), transform.yScale());
-}
 
 void GraphicsContext::fillEllipse(const FloatRect& ellipse)
 {
@@ -1061,7 +1085,7 @@ void GraphicsContext::strokeEllipseAsPath(const FloatRect& ellipse)
     strokePath(path);
 }
 
-#if !USE(CG) && !USE(DIRECT2D)
+#if !USE(CG)
 void GraphicsContext::platformFillEllipse(const FloatRect& ellipse)
 {
     if (paintingDisabled())
diff --git a/Source/WebCore/platform/graphics/GraphicsContext.h b/Source/WebCore/platform/graphics/GraphicsContext.h
index 9a37d7c9fa6..7e062d9e14f 100644
--- a/Source/WebCore/platform/graphics/GraphicsContext.h
+++ b/Source/WebCore/platform/graphics/GraphicsContext.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2003-2016 Apple Inc. All rights reserved.
+ * Copyright (C) 2003, 2006, 2007, 2008, 2009, 2013 Apple Inc. All rights reserved.
  * Copyright (C) 2008-2009 Torch Mobile, Inc.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -38,12 +38,6 @@
 
 #if USE(CG)
 typedef struct CGContext PlatformGraphicsContext;
-#elif USE(DIRECT2D)
-interface ID2D1DCRenderTarget;
-interface ID2D1RenderTarget;
-interface ID2D1Factory;
-interface ID2D1SolidColorBrush;
-typedef ID2D1RenderTarget PlatformGraphicsContext;
 #elif USE(CAIRO)
 namespace WebCore {
 class PlatformContextCairo;
@@ -306,11 +300,11 @@ public:
 
     const GraphicsContextState& state() const { return m_state; }
 
-#if USE(CG) || USE(DIRECT2D) || USE(CAIRO)
+#if USE(CG) || USE(CAIRO)
     WEBCORE_EXPORT void drawNativeImage(const NativeImagePtr&, const FloatSize& selfSize, const FloatRect& destRect, const FloatRect& srcRect, CompositeOperator = CompositeSourceOver, BlendMode = BlendModeNormal, ImageOrientation = ImageOrientation());
 #endif
 
-#if USE(CG) || USE(DIRECT2D)
+#if USE(CG)
     void applyStrokePattern();
     void applyFillPattern();
     void drawPath(const Path&);
@@ -365,7 +359,7 @@ public:
     void drawImageBuffer(ImageBuffer&, const FloatRect& destination, const ImagePaintingOptions& = ImagePaintingOptions());
     void drawImageBuffer(ImageBuffer&, const FloatRect& destination, const FloatRect& source, const ImagePaintingOptions& = ImagePaintingOptions());
 
-    void drawPattern(Image&, const FloatRect& destRect, const FloatRect& srcRect, const AffineTransform&, const FloatPoint& phase, const FloatSize& spacing, CompositeOperator, BlendMode = BlendModeNormal);
+    void drawPattern(Image&, const FloatRect& srcRect, const AffineTransform&, const FloatPoint& phase, const FloatSize& spacing, CompositeOperator, const FloatRect& destRect, BlendMode = BlendModeNormal);
 
     WEBCORE_EXPORT void drawConsumingImageBuffer(std::unique_ptr<ImageBuffer>, const FloatPoint& destination, const ImagePaintingOptions& = ImagePaintingOptions());
     void drawConsumingImageBuffer(std::unique_ptr<ImageBuffer>, const FloatRect& destination, const ImagePaintingOptions& = ImagePaintingOptions());
@@ -489,12 +483,15 @@ public:
     void set3DTransform(const TransformationMatrix&);
     TransformationMatrix get3DTransform() const;
 #endif
+    // Create an image buffer compatible with this context, with suitable resolution
+    // for drawing into the buffer and then into this context.
+    std::unique_ptr<ImageBuffer> createCompatibleBuffer(const FloatSize&, bool hasAlpha = true) const;
+    bool isCompatibleWithBuffer(ImageBuffer&) const;
 
     // This function applies the device scale factor to the context, making the context capable of
     // acting as a base-level context for a HiDPI environment.
     WEBCORE_EXPORT void applyDeviceScaleFactor(float);
     void platformApplyDeviceScaleFactor(float);
-    FloatSize scaleFactor() const;
 
 #if OS(WINDOWS)
     HDC getWindowsContext(const IntRect&, bool supportAlphaBlend, bool mayCreateBitmap); // The passed in rect is used to create a bitmap for compositing inside transparency layers.
@@ -553,27 +550,6 @@ public:
     // The bitmap should be non-premultiplied.
     void drawWindowsBitmap(WindowsBitmap*, const IntPoint&);
 #endif
-#if USE(DIRECT2D)
-    GraphicsContext(HDC, ID2D1DCRenderTarget**, RECT, bool hasAlpha = false); // FIXME: To be removed.
-
-    WEBCORE_EXPORT static ID2D1Factory* systemFactory();
-    WEBCORE_EXPORT static ID2D1RenderTarget* defaultRenderTarget();
-
-    WEBCORE_EXPORT void beginDraw();
-    D2D1_COLOR_F colorWithGlobalAlpha(const Color&) const;
-    WEBCORE_EXPORT void endDraw();
-    void flush();
-
-    ID2D1Brush* solidStrokeBrush() const;
-    ID2D1Brush* solidFillBrush() const;
-    ID2D1Brush* patternStrokeBrush() const;
-    ID2D1Brush* patternFillBrush() const;
-    ID2D1StrokeStyle* platformStrokeStyle() const;
-
-    ID2D1SolidColorBrush* brushWithColor(const Color&);
-#endif
-#else // PLATFORM(WIN)
-    bool shouldIncludeChildWindows() const { return false; }
 #endif // PLATFORM(WIN)
 #endif // OS(WINDOWS)
 
@@ -593,12 +569,6 @@ private:
     void platformInit(HDC, bool hasAlpha = false);
 #endif
 
-#if USE(DIRECT2D)
-    void platformInit(HDC, ID2D1RenderTarget**, RECT, bool hasAlpha = false);
-    void drawWithoutShadow(const FloatRect& boundingRect, const std::function<void(ID2D1RenderTarget*)>&);
-    void drawWithShadow(const FloatRect& boundingRect, const std::function<void(ID2D1RenderTarget*)>&);
-#endif
-
     void savePlatformState();
     void restorePlatformState();
 
diff --git a/Source/WebCore/platform/graphics/Icon.h b/Source/WebCore/platform/graphics/Icon.h
index 4914b0138f8..c07825cd94a 100644
--- a/Source/WebCore/platform/graphics/Icon.h
+++ b/Source/WebCore/platform/graphics/Icon.h
@@ -28,7 +28,7 @@
 #include <wtf/Vector.h>
 
 #if PLATFORM(IOS)
-#include "NativeImage.h"
+#include "NativeImagePtr.h"
 #include <CoreGraphics/CoreGraphics.h>
 #elif PLATFORM(MAC)
 OBJC_CLASS NSImage;
diff --git a/Source/WebCore/platform/graphics/Image.cpp b/Source/WebCore/platform/graphics/Image.cpp
index ca7b59e150e..41a36e8ab82 100644
--- a/Source/WebCore/platform/graphics/Image.cpp
+++ b/Source/WebCore/platform/graphics/Image.cpp
@@ -92,10 +92,9 @@ void Image::fillWithSolidColor(GraphicsContext& ctxt, const FloatRect& dstRect,
 }
 
 void Image::drawTiled(GraphicsContext& ctxt, const FloatRect& destRect, const FloatPoint& srcPoint, const FloatSize& scaledTileSize, const FloatSize& spacing, CompositeOperator op, BlendMode blendMode)
-{
-    Color color = singlePixelSolidColor();
-    if (color.isValid()) {
-        fillWithSolidColor(ctxt, destRect, color, op);
+{    
+    if (mayFillWithSolidColor()) {
+        fillWithSolidColor(ctxt, destRect, solidColor(), op);
         return;
     }
 
@@ -193,17 +192,21 @@ void Image::drawTiled(GraphicsContext& ctxt, const FloatRect& destRect, const Fl
 
     AffineTransform patternTransform = AffineTransform().scaleNonUniform(scale.width(), scale.height());
     FloatRect tileRect(FloatPoint(), intrinsicTileSize);
-    drawPattern(ctxt, destRect, tileRect, patternTransform, oneTileRect.location(), spacing, op, blendMode);
+    drawPattern(ctxt, tileRect, patternTransform, oneTileRect.location(), spacing, op, destRect, blendMode);
+
+#if PLATFORM(IOS)
+    startAnimation(DoNotCatchUp);
+#else
     startAnimation();
+#endif
 }
 
 // FIXME: Merge with the other drawTiled eventually, since we need a combination of both for some things.
 void Image::drawTiled(GraphicsContext& ctxt, const FloatRect& dstRect, const FloatRect& srcRect,
     const FloatSize& tileScaleFactor, TileRule hRule, TileRule vRule, CompositeOperator op)
 {    
-    Color color = singlePixelSolidColor();
-    if (color.isValid()) {
-        fillWithSolidColor(ctxt, dstRect, color, op);
+    if (mayFillWithSolidColor()) {
+        fillWithSolidColor(ctxt, dstRect, solidColor(), op);
         return;
     }
     
@@ -273,8 +276,13 @@ void Image::drawTiled(GraphicsContext& ctxt, const FloatRect& dstRect, const Flo
         vPhase -= (dstRect.height() - scaledTileHeight) / 2;
 
     FloatPoint patternPhase(dstRect.x() - hPhase, dstRect.y() - vPhase);
-    drawPattern(ctxt, dstRect, srcRect, patternTransform, patternPhase, spacing, op);
+    drawPattern(ctxt, srcRect, patternTransform, patternPhase, spacing, op, dstRect);
+
+#if PLATFORM(IOS)
+    startAnimation(DoNotCatchUp);
+#else
     startAnimation();
+#endif
 }
 
 #if ENABLE(IMAGE_DECODER_DOWN_SAMPLING)
diff --git a/Source/WebCore/platform/graphics/Image.h b/Source/WebCore/platform/graphics/Image.h
index 7bdab079a33..d604ba4166c 100644
--- a/Source/WebCore/platform/graphics/Image.h
+++ b/Source/WebCore/platform/graphics/Image.h
@@ -32,8 +32,7 @@
 #include "FloatSize.h"
 #include "GraphicsTypes.h"
 #include "ImageOrientation.h"
-#include "NativeImage.h"
-#include <wtf/Optional.h>
+#include "NativeImagePtr.h"
 #include <wtf/PassRefPtr.h>
 #include <wtf/RefCounted.h>
 #include <wtf/RefPtr.h>
@@ -88,7 +87,7 @@ public:
     virtual bool isSVGImage() const { return false; }
     virtual bool isPDFDocumentImage() const { return false; }
 
-    virtual bool currentFrameKnownToBeOpaque() const = 0;
+    virtual bool currentFrameKnownToBeOpaque() = 0;
     virtual bool isAnimated() const { return false; }
 
     // Derived classes should override this if they can assure that 
@@ -108,7 +107,7 @@ public:
     FloatRect rect() const { return FloatRect(FloatPoint(), size()); }
     float width() const { return size().width(); }
     float height() const { return size().height(); }
-    virtual Optional<IntPoint> hotSpot() const { return Nullopt; }
+    virtual bool getHotSpot(IntPoint&) const { return false; }
 
 #if PLATFORM(IOS)
     virtual FloatSize originalSize() const { return size(); }
@@ -126,10 +125,10 @@ public:
 
     // Animation begins whenever someone draws the image, so startAnimation() is not normally called.
     // It will automatically pause once all observers no longer want to render the image anywhere.
-    virtual void startAnimation() { }
+    enum CatchUpAnimation { DoNotCatchUp, CatchUp };
+    virtual void startAnimation(CatchUpAnimation = CatchUp) { }
     virtual void stopAnimation() {}
     virtual void resetAnimation() {}
-    virtual void newFrameNativeImageAvailableAtIndex(size_t) { }
     
     // Typically the CachedImage that owns us.
     ImageObserver* imageObserver() const { return m_imageObserver; }
@@ -137,21 +136,23 @@ public:
 
     enum TileRule { StretchTile, RoundTile, SpaceTile, RepeatTile };
 
-    virtual NativeImagePtr nativeImage(const GraphicsContext* = nullptr) { return nullptr; }
-    virtual NativeImagePtr nativeImageOfSize(const IntSize&, const GraphicsContext* = nullptr) { return nullptr; }
-    virtual NativeImagePtr nativeImageForCurrentFrame(const GraphicsContext* = nullptr) { return nullptr; }
-    virtual ImageOrientation orientationForCurrentFrame() const { return ImageOrientation(); }
-    virtual Vector<NativeImagePtr> framesNativeImages() { return { }; }
+    virtual NativeImagePtr nativeImageForCurrentFrame() { return nullptr; }
+    virtual ImageOrientation orientationForCurrentFrame() { return ImageOrientation(); }
 
     // Accessors for native image formats.
 
 #if USE(APPKIT)
-    virtual NSImage *nsImage() { return nullptr; }
-    virtual RetainPtr<NSImage> snapshotNSImage() { return nullptr; }
+    virtual NSImage* getNSImage() { return nullptr; }
 #endif
 
 #if PLATFORM(COCOA)
-    virtual CFDataRef tiffRepresentation() { return nullptr; }
+    virtual CFDataRef getTIFFRepresentation() { return nullptr; }
+#endif
+
+#if USE(CG)
+    virtual CGImageRef getCGImageRef() { return nullptr; }
+    virtual CGImageRef getFirstCGImageRefOfSize(const IntSize&) { return nullptr; }
+    virtual RetainPtr<CFArrayRef> getCGImageArray() { return nullptr; }
 #endif
 
 #if PLATFORM(WIN)
@@ -167,8 +168,8 @@ public:
     virtual Evas_Object* getEvasObject(Evas*) { return nullptr; }
 #endif
 
-    virtual void drawPattern(GraphicsContext&, const FloatRect& destRect, const FloatRect& srcRect, const AffineTransform& patternTransform,
-        const FloatPoint& phase, const FloatSize& spacing, CompositeOperator, BlendMode = BlendModeNormal);
+    virtual void drawPattern(GraphicsContext&, const FloatRect& srcRect, const AffineTransform& patternTransform,
+        const FloatPoint& phase, const FloatSize& spacing, CompositeOperator, const FloatRect& destRect, BlendMode = BlendModeNormal);
 
 #if ENABLE(IMAGE_DECODER_DOWN_SAMPLING)
     FloatRect adjustSourceRectForDownSampling(const FloatRect& srcRect, const IntSize& scaledSize) const;
@@ -193,8 +194,9 @@ protected:
     void drawTiled(GraphicsContext&, const FloatRect& dstRect, const FloatRect& srcRect, const FloatSize& tileScaleFactor, TileRule hRule, TileRule vRule, CompositeOperator);
 
     // Supporting tiled drawing
-    virtual Color singlePixelSolidColor() const { return Color(); }
-
+    virtual bool mayFillWithSolidColor() { return false; }
+    virtual Color solidColor() const { return Color(); }
+    
 private:
     RefPtr<SharedBuffer> m_encodedImageData;
     ImageObserver* m_imageObserver;
diff --git a/Source/WebCore/platform/graphics/ImageBackingStore.h b/Source/WebCore/platform/graphics/ImageBackingStore.h
deleted file mode 100644
index 99f6847b6c4..00000000000
--- a/Source/WebCore/platform/graphics/ImageBackingStore.h
+++ /dev/null
@@ -1,222 +0,0 @@
-/*
- * Copyright (C) 2016 Apple Inc.  All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS'' AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
- * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#pragma once
-
-#include "Color.h"
-#include "IntRect.h"
-#include "IntSize.h"
-#include "NativeImage.h"
-
-#include <wtf/Vector.h>
-
-namespace WebCore {
-
-class ImageBackingStore {
-    WTF_MAKE_FAST_ALLOCATED;
-public:
-    static std::unique_ptr<ImageBackingStore> create(const IntSize& size, bool premultiplyAlpha = true)
-    {
-        return std::unique_ptr<ImageBackingStore>(new ImageBackingStore(size, premultiplyAlpha));
-    }
-
-    static std::unique_ptr<ImageBackingStore> create(const ImageBackingStore& other)
-    {
-        return std::unique_ptr<ImageBackingStore>(new ImageBackingStore(other));
-    }
-
-    NativeImagePtr image() const;
-
-    bool setSize(const IntSize& size)
-    {
-        if (size.isEmpty())
-            return false;
-
-        unsigned area = size.area().unsafeGet();
-        if (!m_pixels.tryReserveCapacity(area))
-            return false;
-
-        m_pixels.resize(area);
-        m_pixelsPtr = m_pixels.data();
-        m_size = size;
-        m_frameRect = IntRect(IntPoint(), m_size);
-        clear();
-        return true;
-    }
-
-    void setFrameRect(const IntRect& frameRect)
-    {
-        ASSERT(!m_size.isEmpty());
-        ASSERT(inBounds(frameRect));
-        m_frameRect = frameRect;
-    }
-
-    const IntSize& size() const { return m_size; }
-    const IntRect& frameRect() const { return m_frameRect; }
-
-    void clear()
-    {
-        memset(m_pixelsPtr, 0, (m_size.area() * sizeof(RGBA32)).unsafeGet());
-    }
-
-    void clearRect(const IntRect& rect)
-    {
-        if (rect.isEmpty() || !inBounds(rect))
-            return;
-
-        size_t rowBytes = rect.width() * sizeof(RGBA32);
-        RGBA32* start = pixelAt(rect.x(), rect.y());
-        for (int i = 0; i < rect.height(); ++i) {
-            memset(start, 0, rowBytes);
-            start += m_size.width();
-        }
-    }
-
-    void fillRect(const IntRect &rect, unsigned r, unsigned g, unsigned b, unsigned a)
-    {
-        if (rect.isEmpty() || !inBounds(rect))
-            return;
-
-        RGBA32* start = pixelAt(rect.x(), rect.y());
-        RGBA32 pixelValue = this->pixelValue(r, g, b, a);
-        for (int i = 0; i < rect.height(); ++i) {
-            for (int j = 0; j < rect.width(); ++j)
-                start[j] = pixelValue;
-            start += m_size.width();
-        }
-    }
-
-    void repeatFirstRow(const IntRect& rect)
-    {
-        if (rect.isEmpty() || !inBounds(rect))
-            return;
-
-        size_t rowBytes = rect.width() * sizeof(RGBA32);
-        RGBA32* src = pixelAt(rect.x(), rect.y());
-        RGBA32* dest = src + m_size.width();
-        for (int i = 1; i < rect.height(); ++i) {
-            memcpy(dest, src, rowBytes);
-            dest += m_size.width();
-        }
-    }
-
-    RGBA32* pixelAt(int x, int y) const
-    {
-        ASSERT(inBounds(IntPoint(x, y)));
-        return m_pixelsPtr + y * m_size.width() + x;
-    }
-
-    void setPixel(RGBA32* dest, unsigned r, unsigned g, unsigned b, unsigned a)
-    {
-        ASSERT(dest);
-        *dest = pixelValue(r, g, b, a);
-    }
-
-    void setPixel(int x, int y, unsigned r, unsigned g, unsigned b, unsigned a)
-    {
-        setPixel(pixelAt(x, y), r, g, b, a);
-    }
-
-#if ENABLE(APNG)
-    void blendPixel(RGBA32* dest, unsigned r, unsigned g, unsigned b, unsigned a)
-    {
-        if (!a)
-            return;
-
-        if (a >= 255 || !alphaChannel(*dest)) {
-            setPixel(dest, r, g, b, a);
-            return;
-        }
-
-        if (!m_premultiplyAlpha)
-            *dest = makePremultipliedRGBA(redChannel(*dest), greenChannel(*dest), blueChannel(*dest), alphaChannel(*dest));
-
-        unsigned d = 255 - a;
-
-        r = fastDivideBy255(r * a + redChannel(*dest) * d);
-        g = fastDivideBy255(g * a + greenChannel(*dest) * d);
-        b = fastDivideBy255(b * a + blueChannel(*dest) * d);
-        a += fastDivideBy255(d * alphaChannel(*dest));
-
-        if (m_premultiplyAlpha)
-            *dest = makeRGBA(r, g, b, a);
-        else
-            *dest = makeUnPremultipliedRGBA(r, g, b, a);
-    }
-#endif
-
-    static bool isOverSize(const IntSize& size)
-    {
-        static unsigned long long MaxPixels = ((1 << 29) - 1);
-        unsigned long long pixels = static_cast<unsigned long long>(size.width()) * static_cast<unsigned long long>(size.height());
-        return pixels > MaxPixels;
-    }
-
-private:
-    ImageBackingStore(const IntSize& size, bool premultiplyAlpha = true)
-        : m_premultiplyAlpha(premultiplyAlpha)
-    {
-        ASSERT(!size.isEmpty() && !isOverSize(size));
-        setSize(size);
-    }
-
-    ImageBackingStore(const ImageBackingStore& other)
-        : m_pixels(other.m_pixels)
-        , m_size(other.m_size)
-        , m_premultiplyAlpha(other.m_premultiplyAlpha)
-    {
-        ASSERT(!m_size.isEmpty() && !isOverSize(m_size));
-        m_pixelsPtr = m_pixels.data();
-    }
-
-    bool inBounds(const IntPoint& point) const
-    {
-        return IntRect(IntPoint(), m_size).contains(point);
-    }
-
-    bool inBounds(const IntRect& rect) const
-    {
-        return IntRect(IntPoint(), m_size).contains(rect);
-    }
-
-    RGBA32 pixelValue(unsigned r, unsigned g, unsigned b, unsigned a) const
-    {
-        if (m_premultiplyAlpha && !a)
-            return 0;
-
-        if (m_premultiplyAlpha && a < 255)
-            return makePremultipliedRGBA(r, g, b, a);
-
-        return makeRGBA(r, g, b, a);
-    }
-
-    Vector<RGBA32> m_pixels;
-    RGBA32* m_pixelsPtr { nullptr };
-    IntSize m_size;
-    IntRect m_frameRect; // This will always just be the entire buffer except for GIF and PNG frames
-    bool m_premultiplyAlpha { true };
-};
-
-}
diff --git a/Source/WebCore/platform/graphics/ImageBuffer.cpp b/Source/WebCore/platform/graphics/ImageBuffer.cpp
index eae4c4edaa5..5d644efbdd8 100644
--- a/Source/WebCore/platform/graphics/ImageBuffer.cpp
+++ b/Source/WebCore/platform/graphics/ImageBuffer.cpp
@@ -1,7 +1,6 @@
 /*
  * Copyright (C) 2009 Dirk Schulze <krit@webkit.org>
  * Copyright (C) Research In Motion Limited 2011. All rights reserved.
- * Copyright (C) 2016 Apple Inc. All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
@@ -38,26 +37,6 @@ namespace WebCore {
 static const float MaxClampedLength = 4096;
 static const float MaxClampedArea = MaxClampedLength * MaxClampedLength;
 
-std::unique_ptr<ImageBuffer> ImageBuffer::create(const FloatSize& size, RenderingMode renderingMode, float resolutionScale, ColorSpace colorSpace)
-{
-    bool success = false;
-    std::unique_ptr<ImageBuffer> buffer(new ImageBuffer(size, resolutionScale, colorSpace, renderingMode, success));
-    if (!success)
-        return nullptr;
-    return buffer;
-}
-
-#if USE(DIRECT2D)
-std::unique_ptr<ImageBuffer> ImageBuffer::create(const FloatSize& size, RenderingMode renderingMode, const GraphicsContext* targetContext, float resolutionScale, ColorSpace colorSpace)
-{
-    bool success = false;
-    std::unique_ptr<ImageBuffer> buffer(new ImageBuffer(size, resolutionScale, colorSpace, renderingMode, targetContext, success));
-    if (!success)
-        return nullptr;
-    return buffer;
-}
-#endif
-
 bool ImageBuffer::sizeNeedsClamping(const FloatSize& size)
 {
     if (size.isEmpty())
@@ -102,7 +81,7 @@ FloatRect ImageBuffer::clampedRect(const FloatRect& rect)
     return FloatRect(rect.location(), clampedSize(rect.size()));
 }
 
-#if !(USE(CG) || USE(DIRECT2D))
+#if !USE(CG)
 FloatSize ImageBuffer::sizeForDestinationSize(FloatSize size) const
 {
     return size;
@@ -185,38 +164,11 @@ bool ImageBuffer::copyToPlatformTexture(GraphicsContext3D&, GC3Denum, Platform3D
 }
 #endif
 
-std::unique_ptr<ImageBuffer> ImageBuffer::createCompatibleBuffer(const FloatSize& size, ColorSpace colorSpace, const GraphicsContext& context)
-{
-    if (size.isEmpty())
-        return nullptr;
-
-    IntSize scaledSize = ImageBuffer::compatibleBufferSize(size, context);
-
-    auto buffer = ImageBuffer::createCompatibleBuffer(scaledSize, 1, colorSpace, context);
-    if (!buffer)
-        return nullptr;
-
-    // Set up a corresponding scale factor on the graphics context.
-    buffer->context().scale(FloatSize(scaledSize.width() / size.width(), scaledSize.height() / size.height()));
-    return buffer;
-}
-
-std::unique_ptr<ImageBuffer> ImageBuffer::createCompatibleBuffer(const FloatSize& size, float resolutionScale, ColorSpace colorSpace, const GraphicsContext& context)
+std::unique_ptr<ImageBuffer> ImageBuffer::createCompatibleBuffer(const FloatSize& size, float resolutionScale, ColorSpace colorSpace, const GraphicsContext& context, bool)
 {
     return create(size, context.renderingMode(), resolutionScale, colorSpace);
 }
 
-IntSize ImageBuffer::compatibleBufferSize(const FloatSize& size, const GraphicsContext& context)
-{
-    // Enlarge the buffer size if the context's transform is scaling it so we need a higher
-    // resolution than one pixel per unit.
-    return expandedIntSize(size * context.scaleFactor());
-}
-
-bool ImageBuffer::isCompatibleWithContext(const GraphicsContext& context) const
-{
-    return areEssentiallyEqual(context.scaleFactor(), this->context().scaleFactor());
-}
 
 #if !USE(IOSURFACE_CANVAS_BACKING_STORE)
 size_t ImageBuffer::memoryCost() const
@@ -230,4 +182,5 @@ size_t ImageBuffer::externalMemoryCost() const
 }
 #endif
 
+
 }
diff --git a/Source/WebCore/platform/graphics/ImageBuffer.h b/Source/WebCore/platform/graphics/ImageBuffer.h
index fc222c7602f..4f7720ec8d5 100644
--- a/Source/WebCore/platform/graphics/ImageBuffer.h
+++ b/Source/WebCore/platform/graphics/ImageBuffer.h
@@ -35,7 +35,6 @@
 #include "IntSize.h"
 #include "ImageBufferData.h"
 #include "PlatformLayer.h"
-#include <memory>
 #include <runtime/Uint8ClampedArray.h>
 #include <wtf/Forward.h>
 #include <wtf/RefPtr.h>
@@ -71,18 +70,16 @@ class ImageBuffer {
     friend class IOSurface;
 public:
     // Will return a null pointer on allocation failure.
-    WEBCORE_EXPORT static std::unique_ptr<ImageBuffer> create(const FloatSize&, RenderingMode, float resolutionScale = 1, ColorSpace = ColorSpaceSRGB);
-#if USE(DIRECT2D)
-    WEBCORE_EXPORT static std::unique_ptr<ImageBuffer> create(const FloatSize&, RenderingMode, const GraphicsContext*, float resolutionScale = 1, ColorSpace = ColorSpaceSRGB);
-#endif
-
-    // Create an image buffer compatible with the context, with suitable resolution for drawing into the buffer and then into this context.
-    static std::unique_ptr<ImageBuffer> createCompatibleBuffer(const FloatSize&, const GraphicsContext&);
-    static std::unique_ptr<ImageBuffer> createCompatibleBuffer(const FloatSize&, ColorSpace, const GraphicsContext&);
-    static std::unique_ptr<ImageBuffer> createCompatibleBuffer(const FloatSize&, float resolutionScale, ColorSpace, const GraphicsContext&);
+    static std::unique_ptr<ImageBuffer> create(const FloatSize& size, RenderingMode renderingMode, float resolutionScale = 1, ColorSpace colorSpace = ColorSpaceSRGB)
+    {
+        bool success = false;
+        std::unique_ptr<ImageBuffer> buffer(new ImageBuffer(size, resolutionScale, colorSpace, renderingMode, success));
+        if (!success)
+            return nullptr;
+        return buffer;
+    }
 
-    static IntSize compatibleBufferSize(const FloatSize&, const GraphicsContext&);
-    bool isCompatibleWithContext(const GraphicsContext&) const;
+    static std::unique_ptr<ImageBuffer> createCompatibleBuffer(const FloatSize&, float resolutionScale, ColorSpace, const GraphicsContext&, bool hasAlpha);
 
     WEBCORE_EXPORT ~ImageBuffer();
 
@@ -150,12 +147,10 @@ private:
     RetainPtr<CGImageRef> copyNativeImage(BackingStoreCopy = CopyBackingStore) const;
     static RetainPtr<CGImageRef> sinkIntoNativeImage(std::unique_ptr<ImageBuffer>);
     void flushContext() const;
-#elif USE(DIRECT2D)
-    void flushContext() const;
 #endif
     
     void draw(GraphicsContext&, const FloatRect& destRect, const FloatRect& srcRect = FloatRect(0, 0, -1, -1), CompositeOperator = CompositeSourceOver, BlendMode = BlendModeNormal);
-    void drawPattern(GraphicsContext&, const FloatRect& destRect, const FloatRect& srcRect, const AffineTransform& patternTransform, const FloatPoint& phase, const FloatSize& spacing, CompositeOperator, BlendMode = BlendModeNormal);
+    void drawPattern(GraphicsContext&, const FloatRect& srcRect, const AffineTransform& patternTransform, const FloatPoint& phase, const FloatSize& spacing, CompositeOperator, const FloatRect& destRect, BlendMode = BlendModeNormal);
 
     static void drawConsuming(std::unique_ptr<ImageBuffer>, GraphicsContext&, const FloatRect& destRect, const FloatRect& srcRect = FloatRect(0, 0, -1, -1), CompositeOperator = CompositeSourceOver, BlendMode = BlendModeNormal);
 
@@ -176,11 +171,6 @@ private:
     // This constructor will place its success into the given out-variable
     // so that create() knows when it should return failure.
     WEBCORE_EXPORT ImageBuffer(const FloatSize&, float resolutionScale, ColorSpace, RenderingMode, bool& success);
-#if USE(CG)
-    ImageBuffer(const FloatSize&, float resolutionScale, CGColorSpaceRef, RenderingMode, bool& success);
-#elif USE(DIRECT2D)
-    ImageBuffer(const FloatSize&, float resolutionScale, ColorSpace, RenderingMode, const GraphicsContext*, bool& success);
-#endif
 };
 
 #if USE(CG)
diff --git a/Source/WebCore/platform/graphics/ImageBufferData.h b/Source/WebCore/platform/graphics/ImageBufferData.h
index f89ec0d36fe..fbdae7afe1f 100644
--- a/Source/WebCore/platform/graphics/ImageBufferData.h
+++ b/Source/WebCore/platform/graphics/ImageBufferData.h
@@ -25,8 +25,6 @@
 
 #if USE(CG)
 #include "ImageBufferDataCG.h"
-#elif USE(DIRECT2D)
-#include "ImageBufferDataDirect2D.h"
 #elif USE(CAIRO)
 #include "ImageBufferDataCairo.h"
 #endif
diff --git a/Source/WebCore/platform/graphics/ImageFrame.cpp b/Source/WebCore/platform/graphics/ImageFrame.cpp
deleted file mode 100644
index 9b71282738a..00000000000
--- a/Source/WebCore/platform/graphics/ImageFrame.cpp
+++ /dev/null
@@ -1,135 +0,0 @@
-/*
- * Copyright (C) 2016 Apple Inc.  All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS'' AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
- * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#include "config.h"
-#include "ImageFrame.h"
-
-#include <wtf/NeverDestroyed.h>
-
-namespace WebCore {
-
-ImageFrame::ImageFrame()
-{
-}
-
-ImageFrame::~ImageFrame()
-{
-    clearImage();
-}
-
-const ImageFrame& ImageFrame::defaultFrame()
-{
-    static NeverDestroyed<ImageFrame> sharedInstance;
-    return sharedInstance;
-}
-
-ImageFrame& ImageFrame::operator=(const ImageFrame& other)
-{
-    if (this == &other)
-        return *this;
-
-    m_decoding = other.m_decoding;
-    m_size = other.m_size;
-
-#if !USE(CG)
-    if (other.backingStore())
-        initialize(*other.backingStore());
-    else
-        m_backingStore = nullptr;
-    m_disposalMethod = other.m_disposalMethod;
-#endif
-
-    m_nativeImage = other.m_nativeImage;
-    m_subsamplingLevel = other.m_subsamplingLevel;
-
-    m_orientation = other.m_orientation;
-    m_duration = other.m_duration;
-    m_hasAlpha = other.m_hasAlpha;
-    return *this;
-}
-
-unsigned ImageFrame::clearImage()
-{
-#if !USE(CG)
-    if (hasBackingStore())
-        m_backingStore = nullptr;
-#endif
-
-    if (!hasNativeImage())
-        return 0;
-
-    unsigned frameBytes = this->frameBytes();
-
-    clearNativeImageSubimages(m_nativeImage);
-    m_nativeImage = nullptr;
-
-    return frameBytes;
-}
-
-unsigned ImageFrame::clear()
-{
-    unsigned frameBytes = clearImage();
-    *this = ImageFrame();
-    return frameBytes;
-}
-
-#if !USE(CG)
-bool ImageFrame::initialize(const ImageBackingStore& backingStore)
-{
-    if (&backingStore == this->backingStore())
-        return true;
-
-    m_backingStore = ImageBackingStore::create(backingStore);
-    return m_backingStore != nullptr;
-}
-
-bool ImageFrame::initialize(const IntSize& size, bool premultiplyAlpha)
-{
-    if (size.isEmpty())
-        return false;
-
-    m_backingStore = ImageBackingStore::create(size, premultiplyAlpha);
-    return m_backingStore != nullptr;
-}
-#endif
-
-IntSize ImageFrame::size() const
-{
-#if !USE(CG)
-    if (hasBackingStore())
-        return backingStore()->size();
-#endif
-    return m_size;
-}
-
-Color ImageFrame::singlePixelSolidColor() const
-{
-    if (!hasNativeImage() || m_size != IntSize(1, 1))
-        return Color();
-
-    return nativeImageSinglePixelSolidColor(m_nativeImage);
-}
-
-}
diff --git a/Source/WebCore/platform/graphics/ImageFrame.h b/Source/WebCore/platform/graphics/ImageFrame.h
deleted file mode 100644
index 4f518e95c6e..00000000000
--- a/Source/WebCore/platform/graphics/ImageFrame.h
+++ /dev/null
@@ -1,161 +0,0 @@
-/*
- * Copyright (C) 2016 Apple Inc.  All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS'' AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
- * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#pragma once
-
-#include "Color.h"
-#include "ImageBackingStore.h"
-#include "ImageOrientation.h"
-#include "IntSize.h"
-#include "NativeImage.h"
-
-namespace WebCore {
-
-class Color;
-
-// There are four subsampling levels: 0 = 1x, 1 = 0.5x, 2 = 0.25x, 3 = 0.125x.
-enum class SubsamplingLevel {
-    Undefinded = -1,
-    First = 0,
-    Default = First,
-    Level0 = First,
-    Level1,
-    Level2,
-    Level3,
-    Last = Level3,
-    Max
-};
-
-inline SubsamplingLevel& operator++(SubsamplingLevel& subsamplingLevel)
-{
-    subsamplingLevel = static_cast<SubsamplingLevel>(static_cast<int>(subsamplingLevel) + 1);
-    ASSERT(subsamplingLevel <= SubsamplingLevel::Max);
-    return subsamplingLevel;
-}
-
-typedef int RepetitionCount;
-
-enum {
-    RepetitionCountNone = 0,
-    RepetitionCountOnce = 1,
-    RepetitionCountInfinite = -1,
-};
-
-enum class AlphaOption {
-    Premultiplied,
-    NotPremultiplied
-};
-
-enum class GammaAndColorProfileOption {
-    Applied,
-    Ignored
-};
-
-enum class DecodingMode {
-    OnDemand,
-    Immediate
-};
-
-class ImageFrame {
-    friend class ImageFrameCache;
-public:
-    enum class Caching { Empty, Metadata, MetadataAndImage };
-    enum class Decoding { Empty, BeingDecoded, Partial, Complete };
-
-    ImageFrame();
-    ImageFrame(const ImageFrame& other) { operator=(other); }
-
-    ~ImageFrame();
-
-    static const ImageFrame& defaultFrame();
-
-    ImageFrame& operator=(const ImageFrame& other);
-
-    unsigned clearImage();
-    unsigned clear();
-
-#if !USE(CG)
-    bool initialize(const ImageBackingStore&);
-    bool initialize(const IntSize&, bool premultiplyAlpha);
-#endif
-
-    void setDecoding(Decoding decoding) { m_decoding = decoding; }
-    Decoding decoding() const { return m_decoding; }
-    bool isEmpty() const { return m_decoding == Decoding::Empty; }
-    bool isBeingDecoded() const { return m_decoding == Decoding::BeingDecoded; }
-    bool isPartial() const { return m_decoding == Decoding::Partial; }
-    bool isComplete() const { return m_decoding == Decoding::Complete; }
-
-    IntSize size() const;
-    IntSize sizeRespectingOrientation() const { return !m_orientation.usesWidthAsHeight() ? size() : size().transposedSize(); }
-    unsigned frameBytes() const { return hasNativeImage() ? (size().area() * sizeof(RGBA32)).unsafeGet() : 0; }
-    SubsamplingLevel subsamplingLevel() const { return m_subsamplingLevel; }
-
-#if !USE(CG)
-    enum class DisposalMethod { Unspecified, DoNotDispose, RestoreToBackground, RestoreToPrevious };
-    void setDisposalMethod(DisposalMethod method) { m_disposalMethod = method; }
-    DisposalMethod disposalMethod() const { return m_disposalMethod; }
-#endif
-
-    NativeImagePtr nativeImage() const { return m_nativeImage; }
-
-    void setOrientation(ImageOrientation orientation) { m_orientation = orientation; };
-    ImageOrientation orientation() const { return m_orientation; }
-
-    void setDuration(float duration) { m_duration = duration; }
-    float duration() const { return m_duration; }
-
-    void setHasAlpha(bool hasAlpha) { m_hasAlpha = hasAlpha; }
-    bool hasAlpha() const { return !hasMetadata() || m_hasAlpha; }
-
-    bool hasNativeImage() const { return m_nativeImage; }
-    bool hasValidNativeImage(SubsamplingLevel subsamplingLevel) const { return hasNativeImage() && subsamplingLevel >= m_subsamplingLevel; }
-    bool hasMetadata() const { return !size().isEmpty(); }
-
-#if !USE(CG)
-    ImageBackingStore* backingStore() const { return m_backingStore ? m_backingStore.get() : nullptr; }
-    bool hasBackingStore() const { return backingStore(); }
-#endif
-
-    Color singlePixelSolidColor() const;
-
-private:
-    Decoding m_decoding { Decoding::Empty };
-    IntSize m_size;
-
-#if !USE(CG)
-    std::unique_ptr<ImageBackingStore> m_backingStore;
-    DisposalMethod m_disposalMethod { DisposalMethod::Unspecified };
-#endif
-
-    NativeImagePtr m_nativeImage;
-    SubsamplingLevel m_subsamplingLevel { SubsamplingLevel::Default };
-
-    ImageOrientation m_orientation { DefaultImageOrientation };
-    float m_duration { 0 };
-    bool m_hasAlpha { true };
-};
-
-}
diff --git a/Source/WebCore/platform/graphics/ImageFrameCache.cpp b/Source/WebCore/platform/graphics/ImageFrameCache.cpp
deleted file mode 100644
index 1c418e2eede..00000000000
--- a/Source/WebCore/platform/graphics/ImageFrameCache.cpp
+++ /dev/null
@@ -1,478 +0,0 @@
-/*
- * Copyright (C) 2016 Apple Inc.  All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS'' AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
- * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#include "config.h"
-#include "ImageFrameCache.h"
-
-#include "Image.h"
-#include "ImageObserver.h"
-
-#if USE(CG)
-#include "ImageDecoderCG.h"
-#elif USE(DIRECT2D)
-#include "ImageDecoderDirect2D.h"
-#include <WinCodec.h>
-#else
-#include "ImageDecoder.h"
-#endif
-
-#include <wtf/CheckedArithmetic.h>
-#include <wtf/MainThread.h>
-#include <wtf/RunLoop.h>
-
-namespace WebCore {
-
-ImageFrameCache::ImageFrameCache(Image* image)
-    : m_image(image)
-{
-}
-
-ImageFrameCache::ImageFrameCache(NativeImagePtr&& nativeImage)
-{
-    m_frameCount = 1;
-    m_isSizeAvailable = true;
-    growFrames();
-
-    setNativeImage(WTFMove(nativeImage));
-
-    m_decodedSize = m_frames[0].frameBytes();
-
-    // The assumption is the memory image will be displayed with the default
-    // orientation. So set m_sizeRespectingOrientation to be the same as m_size.
-    m_size = m_frames[0].size();
-    m_sizeRespectingOrientation = m_size;
-}
-
-ImageFrameCache::~ImageFrameCache()
-{
-    ASSERT(!hasDecodingQueue());
-}
-
-void ImageFrameCache::destroyDecodedData(bool destroyAll, size_t count)
-{
-    if (destroyAll)
-        count = m_frames.size();
-    
-    unsigned decodedSize = 0;
-    for (size_t i = 0; i <  count; ++i)
-        decodedSize += m_frames[i].clearImage();
-
-    decodedSizeReset(decodedSize);
-}
-
-bool ImageFrameCache::destroyDecodedDataIfNecessary(bool destroyAll, size_t count)
-{
-    unsigned decodedSize = 0;
-    for (auto& frame : m_frames)
-        decodedSize += frame.frameBytes();
-    
-    if (decodedSize < LargeAnimationCutoff)
-        return false;
-    
-    destroyDecodedData(destroyAll, count);
-    return true;
-}
-
-void ImageFrameCache::destroyIncompleteDecodedData()
-{
-    unsigned decodedSize = 0;
-    
-    for (auto& frame : m_frames) {
-        if (!frame.hasMetadata() || frame.isComplete())
-            continue;
-        
-        decodedSize += frame.clear();
-    }
-
-    decodedSizeDecreased(decodedSize);
-}
-
-void ImageFrameCache::decodedSizeChanged(long long decodedSize)
-{
-    if (!decodedSize || !m_image || !m_image->imageObserver())
-        return;
-    
-    m_image->imageObserver()->decodedSizeChanged(m_image, decodedSize);
-}
-
-void ImageFrameCache::decodedSizeIncreased(unsigned decodedSize)
-{
-    if (!decodedSize)
-        return;
-    
-    m_decodedSize += decodedSize;
-    
-    // The fully-decoded frame will subsume the partially decoded data used
-    // to determine image properties.
-    long long changeSize = static_cast<long long>(decodedSize) - m_decodedPropertiesSize;
-    m_decodedPropertiesSize = 0;
-    decodedSizeChanged(changeSize);
-}
-
-void ImageFrameCache::decodedSizeDecreased(unsigned decodedSize)
-{
-    if (!decodedSize)
-        return;
-
-    ASSERT(m_decodedSize >= decodedSize);
-    m_decodedSize -= decodedSize;
-    decodedSizeChanged(-static_cast<long long>(decodedSize));
-}
-
-void ImageFrameCache::decodedSizeReset(unsigned decodedSize)
-{
-    ASSERT(m_decodedSize >= decodedSize);
-    m_decodedSize -= decodedSize;
-
-    // Clearing the ImageSource destroys the extra decoded data used for
-    // determining image properties.
-    decodedSize += m_decodedPropertiesSize;
-    m_decodedPropertiesSize = 0;
-    decodedSizeChanged(-static_cast<long long>(decodedSize));
-}
-
-void ImageFrameCache::didDecodeProperties(unsigned decodedPropertiesSize)
-{
-    if (m_decodedSize)
-        return;
-
-    long long decodedSize = static_cast<long long>(decodedPropertiesSize) - m_decodedPropertiesSize;
-    m_decodedPropertiesSize = decodedPropertiesSize;
-    decodedSizeChanged(decodedSize);
-}
-
-void ImageFrameCache::growFrames()
-{
-    ASSERT(isSizeAvailable());
-    ASSERT(m_frames.size() <= frameCount());
-    m_frames.grow(frameCount());
-}
-
-void ImageFrameCache::setNativeImage(NativeImagePtr&& nativeImage)
-{
-    ASSERT(m_frames.size() == 1);
-    ImageFrame& frame = m_frames[0];
-
-    ASSERT(!isDecoderAvailable());
-
-    frame.m_nativeImage = WTFMove(nativeImage);
-
-    frame.m_decoding = ImageFrame::Decoding::Complete;
-    frame.m_size = nativeImageSize(frame.m_nativeImage);
-    frame.m_hasAlpha = nativeImageHasAlpha(frame.m_nativeImage);
-}
-
-void ImageFrameCache::setFrameNativeImageAtIndex(NativeImagePtr&& nativeImage, size_t index, SubsamplingLevel subsamplingLevel)
-{
-    ASSERT(index < m_frames.size());
-    ImageFrame& frame = m_frames[index];
-
-    ASSERT(isDecoderAvailable());
-
-    frame.m_nativeImage = WTFMove(nativeImage);
-    setFrameMetadataAtIndex(index, subsamplingLevel);
-}
-
-void ImageFrameCache::setFrameMetadataAtIndex(size_t index, SubsamplingLevel subsamplingLevel)
-{
-    ASSERT(index < m_frames.size());
-    ImageFrame& frame = m_frames[index];
-
-    ASSERT(isDecoderAvailable());
-    frame.m_decoding = m_decoder->frameIsCompleteAtIndex(index) ? ImageFrame::Decoding::Complete : ImageFrame::Decoding::Partial;
-    if (frame.hasMetadata())
-        return;
-    
-    frame.m_subsamplingLevel = subsamplingLevel;
-    frame.m_size = m_decoder->frameSizeAtIndex(index, subsamplingLevel);
-    frame.m_orientation = m_decoder->frameOrientationAtIndex(index);
-    frame.m_hasAlpha = m_decoder->frameHasAlphaAtIndex(index);
-    
-    if (repetitionCount())
-        frame.m_duration = m_decoder->frameDurationAtIndex(index);
-}
-
-void ImageFrameCache::replaceFrameNativeImageAtIndex(NativeImagePtr&& nativeImage, size_t index, SubsamplingLevel subsamplingLevel)
-{
-    ASSERT(index < m_frames.size());
-    ImageFrame& frame = m_frames[index];
-
-    if (!frame.hasValidNativeImage(subsamplingLevel)) {
-        // Clear the current image frame and update the observer with this clearance.
-        unsigned decodedSize = frame.clear();
-        decodedSizeDecreased(decodedSize);
-    }
-
-    // Do not cache the NativeImage if adding its frameByes to the MemoryCache will cause numerical overflow.
-    size_t frameBytes = size().unclampedArea() * sizeof(RGBA32);
-    if (!WTF::isInBounds<unsigned>(frameBytes + decodedSize()))
-        return;
-
-    // Copy the new image to the cache.
-    setFrameNativeImageAtIndex(WTFMove(nativeImage), index, subsamplingLevel);
-
-    // Update the observer with the new image frame bytes.
-    decodedSizeIncreased(frame.frameBytes());
-}
-
-void ImageFrameCache::cacheFrameNativeImageAtIndex(NativeImagePtr&& nativeImage, size_t index, SubsamplingLevel subsamplingLevel)
-{
-    if (!isDecoderAvailable())
-        return;
-
-    // Clean the old native image and set a new one
-    replaceFrameNativeImageAtIndex(WTFMove(nativeImage), index, subsamplingLevel);
-
-    // Notify the image with the readiness of the new frame NativeImage.
-    if (m_image)
-        m_image->newFrameNativeImageAvailableAtIndex(index);
-}
-
-Ref<WorkQueue> ImageFrameCache::decodingQueue()
-{
-    if (!m_decodingQueue)
-        m_decodingQueue = WorkQueue::create("org.webkit.ImageDecoder", WorkQueue::Type::Serial, WorkQueue::QOS::UserInteractive);
-    
-    return *m_decodingQueue;
-}
-
-void ImageFrameCache::startAsyncDecodingQueue()
-{
-    if (hasDecodingQueue() || !isDecoderAvailable())
-        return;
-
-    Ref<ImageFrameCache> protectedThis = Ref<ImageFrameCache>(*this);
-    Ref<WorkQueue> protectedQueue = decodingQueue();
-
-    // We need to protect this and m_decodingQueue from being deleted while we are in the decoding loop.
-    decodingQueue()->dispatch([this, protectedThis = WTFMove(protectedThis), protectedQueue = WTFMove(protectedQueue)] {
-        ImageFrameRequest frameRequest;
-
-        while (m_frameRequestQueue.dequeue(frameRequest)) {
-            // Get the frame NativeImage on the decoding thread.
-            NativeImagePtr nativeImage = m_decoder->createFrameImageAtIndex(frameRequest.index, frameRequest.subsamplingLevel, DecodingMode::Immediate);
-
-            // Update the cached frames on the main thread to avoid updating the MemoryCache from a different thread.
-            callOnMainThread([this, nativeImage, frameRequest] () mutable {
-                // The queue may be closed if after we got the frame NativeImage, stopAsyncDecodingQueue() was called
-                if (hasDecodingQueue())
-                    cacheFrameNativeImageAtIndex(WTFMove(nativeImage), frameRequest.index, frameRequest.subsamplingLevel);
-            });
-        }
-    });
-}
-
-bool ImageFrameCache::requestFrameAsyncDecodingAtIndex(size_t index, SubsamplingLevel subsamplingLevel)
-{
-    if (!isDecoderAvailable())
-        return false;
-
-    if (!hasDecodingQueue())
-        startAsyncDecodingQueue();
-
-    ASSERT(index < m_frames.size());
-    ImageFrame& frame = m_frames[index];
-    
-    if (subsamplingLevel == SubsamplingLevel::Undefinded)
-        subsamplingLevel = frame.subsamplingLevel();
-    
-    if (frame.hasValidNativeImage(subsamplingLevel))
-        return false;
-    
-    frame.setDecoding(ImageFrame::Decoding::BeingDecoded);
-    m_frameRequestQueue.enqueue({ index, subsamplingLevel });
-    return true;
-}
-
-void ImageFrameCache::stopAsyncDecodingQueue()
-{
-    if (!hasDecodingQueue())
-        return;
-    
-    m_frameRequestQueue.close();
-    m_decodingQueue = nullptr;
-}
-
-const ImageFrame& ImageFrameCache::frameAtIndex(size_t index, SubsamplingLevel subsamplingLevel, ImageFrame::Caching caching)
-{
-    ASSERT(index < m_frames.size());
-    ImageFrame& frame = m_frames[index];
-    if (!isDecoderAvailable() || frame.isBeingDecoded() || caching == ImageFrame::Caching::Empty)
-        return frame;
-    
-    if (subsamplingLevel == SubsamplingLevel::Undefinded)
-        subsamplingLevel = frame.subsamplingLevel();
-
-    if (!frame.isComplete() && caching == ImageFrame::Caching::Metadata)
-        setFrameMetadataAtIndex(index, subsamplingLevel);
-    else if (!frame.hasValidNativeImage(subsamplingLevel) && caching == ImageFrame::Caching::MetadataAndImage)
-        replaceFrameNativeImageAtIndex(m_decoder->createFrameImageAtIndex(index, subsamplingLevel), index, subsamplingLevel);
-
-    return frame;
-}
-
-void ImageFrameCache::clearMetadata()
-{
-    m_frameCount = Nullopt;
-    m_singlePixelSolidColor = Nullopt;
-}
-
-template<typename T, T (ImageDecoder::*functor)() const>
-T ImageFrameCache::metadata(const T& defaultValue, Optional<T>* cachedValue)
-{
-    if (cachedValue && *cachedValue)
-        return cachedValue->value();
-
-    if (!isDecoderAvailable() || !m_decoder->isSizeAvailable())
-        return defaultValue;
-
-    if (!cachedValue)
-        return (m_decoder->*functor)();
-
-    *cachedValue = (m_decoder->*functor)();
-    didDecodeProperties(m_decoder->bytesDecodedToDetermineProperties());
-    return cachedValue->value();
-}
-
-template<typename T, T (ImageFrame::*functor)() const>
-T ImageFrameCache::frameMetadataAtIndex(size_t index, SubsamplingLevel subsamplingLevel, ImageFrame::Caching caching, Optional<T>* cachedValue)
-{
-    if (cachedValue && *cachedValue)
-        return cachedValue->value();
-    
-    const ImageFrame& frame = index < m_frames.size() ? frameAtIndex(index, subsamplingLevel, caching) : ImageFrame::defaultFrame();
-
-    // Don't cache any unavailable frame metadata.
-    if (!frame.hasMetadata() || !cachedValue)
-        return (frame.*functor)();
-    
-    *cachedValue = (frame.*functor)();
-    return cachedValue->value();
-}
-
-bool ImageFrameCache::isSizeAvailable()
-{
-    if (m_isSizeAvailable)
-        return m_isSizeAvailable.value();
-    
-    if (!isDecoderAvailable() || !m_decoder->isSizeAvailable())
-        return false;
-    
-    m_isSizeAvailable = true;
-    didDecodeProperties(m_decoder->bytesDecodedToDetermineProperties());
-    return true;
-}
-
-size_t ImageFrameCache::frameCount()
-{
-    return metadata<size_t, (&ImageDecoder::frameCount)>(m_frames.size(), &m_frameCount);
-}
-
-RepetitionCount ImageFrameCache::repetitionCount()
-{
-    return metadata<RepetitionCount, (&ImageDecoder::repetitionCount)>(RepetitionCountNone, &m_repetitionCount);
-}
-
-String ImageFrameCache::filenameExtension()
-{
-    return metadata<String, (&ImageDecoder::filenameExtension)>(String(), &m_filenameExtension);
-}
-
-Optional<IntPoint> ImageFrameCache::hotSpot()
-{
-    return metadata<Optional<IntPoint>, (&ImageDecoder::hotSpot)>(Nullopt, &m_hotSpot);
-}
-
-IntSize ImageFrameCache::size()
-{
-    return frameMetadataAtIndex<IntSize, (&ImageFrame::size)>(0, SubsamplingLevel::Default, ImageFrame::Caching::Metadata, &m_size);
-}
-
-IntSize ImageFrameCache::sizeRespectingOrientation()
-{
-    return frameMetadataAtIndex<IntSize, (&ImageFrame::sizeRespectingOrientation)>(0, SubsamplingLevel::Default, ImageFrame::Caching::Metadata, &m_sizeRespectingOrientation);
-}
-
-Color ImageFrameCache::singlePixelSolidColor()
-{
-    return frameCount() == 1 ? frameMetadataAtIndex<Color, (&ImageFrame::singlePixelSolidColor)>(0, SubsamplingLevel::Undefinded, ImageFrame::Caching::MetadataAndImage, &m_singlePixelSolidColor) : Color();
-}
-
-bool ImageFrameCache::frameIsBeingDecodedAtIndex(size_t index)
-{
-    return frameMetadataAtIndex<bool, (&ImageFrame::isBeingDecoded)>(index);
-}
-
-bool ImageFrameCache::frameIsCompleteAtIndex(size_t index)
-{
-    return frameMetadataAtIndex<bool, (&ImageFrame::isComplete)>(index);
-}
-
-bool ImageFrameCache::frameHasAlphaAtIndex(size_t index)
-{
-    return frameMetadataAtIndex<bool, (&ImageFrame::hasAlpha)>(index);
-}
-
-bool ImageFrameCache::frameHasImageAtIndex(size_t index)
-{
-    return frameMetadataAtIndex<bool, (&ImageFrame::hasNativeImage)>(index);
-}
-
-bool ImageFrameCache::frameHasValidNativeImageAtIndex(size_t index, SubsamplingLevel subsamplingLevel)
-{
-    return frameHasImageAtIndex(index) && subsamplingLevel >= frameSubsamplingLevelAtIndex(index);
-}
-
-SubsamplingLevel ImageFrameCache::frameSubsamplingLevelAtIndex(size_t index)
-{
-    return frameMetadataAtIndex<SubsamplingLevel, (&ImageFrame::subsamplingLevel)>(index);
-}
-
-IntSize ImageFrameCache::frameSizeAtIndex(size_t index, SubsamplingLevel subsamplingLevel)
-{
-    return frameMetadataAtIndex<IntSize, (&ImageFrame::size)>(index, subsamplingLevel, ImageFrame::Caching::Metadata);
-}
-
-unsigned ImageFrameCache::frameBytesAtIndex(size_t index, SubsamplingLevel subsamplingLevel)
-{
-    return frameMetadataAtIndex<unsigned, (&ImageFrame::frameBytes)>(index, subsamplingLevel, ImageFrame::Caching::Metadata);
-}
-
-float ImageFrameCache::frameDurationAtIndex(size_t index)
-{
-    return frameMetadataAtIndex<float, (&ImageFrame::duration)>(index, SubsamplingLevel::Undefinded, ImageFrame::Caching::Metadata);
-}
-
-ImageOrientation ImageFrameCache::frameOrientationAtIndex(size_t index)
-{
-    return frameMetadataAtIndex<ImageOrientation, (&ImageFrame::orientation)>(index, SubsamplingLevel::Undefinded, ImageFrame::Caching::Metadata);
-}
-
-NativeImagePtr ImageFrameCache::frameImageAtIndex(size_t index, SubsamplingLevel subsamplingLevel)
-{
-    return frameMetadataAtIndex<NativeImagePtr, (&ImageFrame::nativeImage)>(index, subsamplingLevel, ImageFrame::Caching::MetadataAndImage);
-}
-
-}
diff --git a/Source/WebCore/platform/graphics/ImageFrameCache.h b/Source/WebCore/platform/graphics/ImageFrameCache.h
deleted file mode 100644
index 6f905a10a6b..00000000000
--- a/Source/WebCore/platform/graphics/ImageFrameCache.h
+++ /dev/null
@@ -1,168 +0,0 @@
-/*
- * Copyright (C) 2016 Apple Inc.  All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS'' AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
- * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#pragma once
-
-#include "ImageFrame.h"
-#include "TextStream.h"
-
-#include <wtf/Forward.h>
-#include <wtf/Optional.h>
-#include <wtf/SynchronizedFixedQueue.h>
-#include <wtf/WorkQueue.h>
-#include <wtf/threads/BinarySemaphore.h>
-
-namespace WebCore {
-
-class GraphicsContext;
-class Image;
-class ImageDecoder;
-
-class ImageFrameCache : public RefCounted<ImageFrameCache> {
-    friend class ImageSource;
-public:
-    static Ref<ImageFrameCache> create(Image* image)
-    {
-        return adoptRef(*new ImageFrameCache(image));
-    }
-
-    static Ref<ImageFrameCache> create(NativeImagePtr&& nativeImage)
-    {
-        return adoptRef(*new ImageFrameCache(WTFMove(nativeImage)));
-    }
-
-    ~ImageFrameCache();
-
-    void setDecoder(ImageDecoder* decoder) { m_decoder = decoder; }
-    ImageDecoder* decoder() const { return m_decoder; }
-
-    unsigned decodedSize() const { return m_decodedSize; }
-    void destroyDecodedData(bool destroyAll = true, size_t count = 0);
-    bool destroyDecodedDataIfNecessary(bool destroyAll = true, size_t count = 0);
-    void destroyIncompleteDecodedData();
-
-    void growFrames();
-    void clearMetadata();
-    
-    // Asynchronous image decoding
-    void startAsyncDecodingQueue();
-    bool requestFrameAsyncDecodingAtIndex(size_t, SubsamplingLevel);
-    void stopAsyncDecodingQueue();
-    bool hasDecodingQueue() { return m_decodingQueue; }
-
-    // Image metadata which is calculated either by the ImageDecoder or directly
-    // from the NativeImage if this class was created for a memory image.
-    bool isSizeAvailable();
-    size_t frameCount();
-    RepetitionCount repetitionCount();
-    String filenameExtension();
-    Optional<IntPoint> hotSpot();
-    
-    // Image metadata which is calculated from the first ImageFrame.
-    IntSize size();
-    IntSize sizeRespectingOrientation();
-
-    Color singlePixelSolidColor();
-
-    // ImageFrame metadata which does not require caching the ImageFrame.
-    bool frameIsBeingDecodedAtIndex(size_t);
-    bool frameIsCompleteAtIndex(size_t);
-    bool frameHasAlphaAtIndex(size_t);
-    bool frameHasImageAtIndex(size_t);
-    bool frameHasValidNativeImageAtIndex(size_t, SubsamplingLevel);
-    SubsamplingLevel frameSubsamplingLevelAtIndex(size_t);
-    
-    // ImageFrame metadata which forces caching or re-caching the ImageFrame.
-    IntSize frameSizeAtIndex(size_t, SubsamplingLevel = SubsamplingLevel::Default);
-    unsigned frameBytesAtIndex(size_t, SubsamplingLevel = SubsamplingLevel::Default);
-    float frameDurationAtIndex(size_t);
-    ImageOrientation frameOrientationAtIndex(size_t);
-    NativeImagePtr frameImageAtIndex(size_t, SubsamplingLevel = SubsamplingLevel::Default);
-
-private:
-    ImageFrameCache(Image*);
-    ImageFrameCache(NativeImagePtr&&);
-
-    template<typename T, T (ImageDecoder::*functor)() const>
-    T metadata(const T& defaultValue, Optional<T>* cachedValue = nullptr);
-
-    template<typename T, T (ImageFrame::*functor)() const>
-    T frameMetadataAtIndex(size_t index, SubsamplingLevel = SubsamplingLevel::Undefinded, ImageFrame::Caching = ImageFrame::Caching::Empty, Optional<T>* = nullptr);
-
-    bool isDecoderAvailable() const { return m_decoder; }
-    void decodedSizeChanged(long long decodedSize);
-    void didDecodeProperties(unsigned decodedPropertiesSize);
-    void decodedSizeIncreased(unsigned decodedSize);
-    void decodedSizeDecreased(unsigned decodedSize);
-    void decodedSizeReset(unsigned decodedSize);
-
-    void setNativeImage(NativeImagePtr&&);
-    void setFrameNativeImageAtIndex(NativeImagePtr&&, size_t, SubsamplingLevel);
-    void setFrameMetadataAtIndex(size_t, SubsamplingLevel);
-    void replaceFrameNativeImageAtIndex(NativeImagePtr&&, size_t, SubsamplingLevel);
-    void cacheFrameNativeImageAtIndex(NativeImagePtr&&, size_t, SubsamplingLevel);
-
-    Ref<WorkQueue> decodingQueue();
-
-    const ImageFrame& frameAtIndex(size_t, SubsamplingLevel, ImageFrame::Caching);
-
-    // Animated images over a certain size are considered large enough that we'll only hang on to one frame at a time.
-#if !PLATFORM(IOS)
-    static const unsigned LargeAnimationCutoff = 5242880;
-#else
-    static const unsigned LargeAnimationCutoff = 2097152;
-#endif
-
-    Image* m_image { nullptr };
-    ImageDecoder* m_decoder { nullptr };
-    unsigned m_decodedSize { 0 };
-    unsigned m_decodedPropertiesSize { 0 };
-
-    Vector<ImageFrame, 1> m_frames;
-
-    // Asynchronous image decoding.
-    struct ImageFrameRequest {
-        size_t index;
-        SubsamplingLevel subsamplingLevel;
-    };
-    static const int BufferSize = 8;
-    using FrameRequestQueue = SynchronizedFixedQueue<ImageFrameRequest, BufferSize>;
-    FrameRequestQueue m_frameRequestQueue;
-    RefPtr<WorkQueue> m_decodingQueue;
-
-    // Image metadata.
-    Optional<bool> m_isSizeAvailable;
-    Optional<size_t> m_frameCount;
-    Optional<RepetitionCount> m_repetitionCount;
-    Optional<String> m_filenameExtension;
-    Optional<Optional<IntPoint>> m_hotSpot;
-
-    // Image metadata which is calculated from the first ImageFrame.
-    Optional<IntSize> m_size;
-    Optional<IntSize> m_sizeRespectingOrientation;
-    Optional<Color> m_singlePixelSolidColor;
-};
-    
-}
diff --git a/Source/WebCore/platform/graphics/ImageObserver.h b/Source/WebCore/platform/graphics/ImageObserver.h
index 55317dac8b2..ed6b017f4ef 100644
--- a/Source/WebCore/platform/graphics/ImageObserver.h
+++ b/Source/WebCore/platform/graphics/ImageObserver.h
@@ -37,16 +37,12 @@ class ImageObserver {
 protected:
     virtual ~ImageObserver() {}
 public:
-    virtual bool allowSubsampling() const = 0;
-    virtual bool allowAsyncImageDecoding() const = 0;
-    virtual bool showDebugBackground() const = 0;
-    virtual void decodedSizeChanged(const Image*, long long delta) = 0;
-
+    virtual void decodedSizeChanged(const Image*, int delta) = 0;
     virtual void didDraw(const Image*) = 0;
 
     virtual void animationAdvanced(const Image*) = 0;
 
-    virtual void changedInRect(const Image*, const IntRect* changeRect = nullptr) = 0;
+    virtual void changedInRect(const Image*, const IntRect&) = 0;
 };
 
 }
diff --git a/Source/WebCore/platform/graphics/ImageSource.cpp b/Source/WebCore/platform/graphics/ImageSource.cpp
index 910d61da6e1..08cd0ef0ed5 100644
--- a/Source/WebCore/platform/graphics/ImageSource.cpp
+++ b/Source/WebCore/platform/graphics/ImageSource.cpp
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2006, 2010, 2011, 2012, 2014, 2016 Apple Inc.  All rights reserved.
+ * Copyright (C) 2006 Apple Inc.  All rights reserved.
  * Copyright (C) 2007 Alp Toker <alp.toker@collabora.co.uk>
  * Copyright (C) 2008, Google Inc. All rights reserved.
  * Copyright (C) 2007-2009 Torch Mobile, Inc
@@ -29,29 +29,21 @@
 #include "config.h"
 #include "ImageSource.h"
 
-#if USE(CG)
-#include "ImageDecoderCG.h"
-#elif USE(DIRECT2D)
-#include "GraphicsContext.h"
-#include "ImageDecoderDirect2D.h"
-#include <WinCodec.h>
-#else
+#if !USE(CG)
+
 #include "ImageDecoder.h"
-#endif
 
 #include "ImageOrientation.h"
-
-#include <wtf/CurrentTime.h>
+#include "NotImplemented.h"
 
 namespace WebCore {
 
-ImageSource::ImageSource(NativeImagePtr&& nativeImage)
-    : m_frameCache(ImageFrameCache::create(WTFMove(nativeImage)))
-{
-}
-    
-ImageSource::ImageSource(Image* image, AlphaOption alphaOption, GammaAndColorProfileOption gammaAndColorProfileOption)
-    : m_frameCache(ImageFrameCache::create(image))
+#if ENABLE(IMAGE_DECODER_DOWN_SAMPLING)
+unsigned ImageSource::s_maxPixelsPerDecodedImage = 1024 * 1024;
+#endif
+
+ImageSource::ImageSource(ImageSource::AlphaOption alphaOption, ImageSource::GammaAndColorProfileOption gammaAndColorProfileOption)
+    : m_decoder(0)
     , m_alphaOption(alphaOption)
     , m_gammaAndColorProfileOption(gammaAndColorProfileOption)
 {
@@ -59,182 +51,169 @@ ImageSource::ImageSource(Image* image, AlphaOption alphaOption, GammaAndColorPro
 
 ImageSource::~ImageSource()
 {
+    clear(true);
 }
 
-void ImageSource::clearFrameBufferCache(size_t clearBeforeFrame)
+void ImageSource::clear(bool destroyAll, size_t clearBeforeFrame, SharedBuffer* data, bool allDataReceived)
 {
-    if (!isDecoderAvailable())
-        return;
-    m_decoder->clearFrameBufferCache(clearBeforeFrame);
-}
-
-void ImageSource::clear(bool destroyAll, size_t count, SharedBuffer* data)
-{
-    // There's no need to throw away the decoder unless we're explicitly asked
-    // to destroy all of the frames.
-    if (!destroyAll || m_frameCache->hasDecodingQueue()) {
-        clearFrameBufferCache(count);
+    if (!destroyAll) {
+        if (m_decoder)
+            m_decoder->clearFrameBufferCache(clearBeforeFrame);
         return;
     }
 
-    m_decoder = nullptr;
-    m_frameCache->setDecoder(nullptr);
-    setData(data, isAllDataReceived());
+    delete m_decoder;
+    m_decoder = 0;
+    if (data)
+        setData(data, allDataReceived);
 }
 
-void ImageSource::destroyDecodedData(SharedBuffer* data, bool destroyAll, size_t count)
+bool ImageSource::initialized() const
 {
-    m_frameCache->destroyDecodedData(destroyAll, count);
-    clear(destroyAll, count, data);
+    return m_decoder;
 }
 
-bool ImageSource::destroyDecodedDataIfNecessary(SharedBuffer* data, bool destroyAll, size_t count)
+void ImageSource::setData(SharedBuffer* data, bool allDataReceived)
 {
-    // If we have decoded frames but there is no encoded data, we shouldn't destroy
-    // the decoded image since we won't be able to reconstruct it later.
-    if (!data && m_frameCache->frameCount())
-        return false;
-
-    if (!m_frameCache->destroyDecodedDataIfNecessary(destroyAll, count))
-        return false;
+    // Make the decoder by sniffing the bytes.
+    // This method will examine the data and instantiate an instance of the appropriate decoder plugin.
+    // If insufficient bytes are available to determine the image type, no decoder plugin will be
+    // made.
+    if (!m_decoder) {
+        m_decoder = static_cast<NativeImageDecoderPtr>(NativeImageDecoder::create(*data, m_alphaOption, m_gammaAndColorProfileOption));
+#if ENABLE(IMAGE_DECODER_DOWN_SAMPLING)
+        if (m_decoder && s_maxPixelsPerDecodedImage)
+            m_decoder->setMaxNumPixels(s_maxPixelsPerDecodedImage);
+#endif
+    }
 
-    clear(destroyAll, count, data);
-    return true;
+    if (m_decoder)
+        m_decoder->setData(data, allDataReceived);
 }
 
-bool ImageSource::ensureDecoderAvailable(SharedBuffer* data)
+String ImageSource::filenameExtension() const
 {
-    if (!data || isDecoderAvailable())
-        return true;
-
-    m_decoder = ImageDecoder::create(*data, m_alphaOption, m_gammaAndColorProfileOption);
-    if (!isDecoderAvailable())
-        return false;
-
-    m_frameCache->setDecoder(m_decoder.get());
-    return true;
+    return m_decoder ? m_decoder->filenameExtension() : String();
 }
 
-void ImageSource::setDecoderTargetContext(const GraphicsContext* targetContext)
+SubsamplingLevel ImageSource::subsamplingLevelForScale(float) const
 {
-#if USE(DIRECT2D)
-    if (!isDecoderAvailable())
-        return;
-
-    if (targetContext)
-        m_decoder->setTargetContext(targetContext->platformContext());
-#else
-    UNUSED_PARAM(targetContext);
-#endif
+    return 0;
 }
 
-void ImageSource::setData(SharedBuffer* data, bool allDataReceived)
+bool ImageSource::allowSubsamplingOfFrameAtIndex(size_t) const
 {
-    if (!data || !ensureDecoderAvailable(data))
-        return;
-
-    m_decoder->setData(*data, allDataReceived);
+    return false;
 }
 
-bool ImageSource::dataChanged(SharedBuffer* data, bool allDataReceived)
+bool ImageSource::isSizeAvailable()
 {
-    m_frameCache->destroyIncompleteDecodedData();
-
-#if PLATFORM(IOS)
-    // FIXME: We should expose a setting to enable/disable progressive loading and make this
-    // code conditional on it. Then we can remove the PLATFORM(IOS)-guard.
-    static const double chunkLoadIntervals[] = {0, 1, 3, 6, 15};
-    double interval = chunkLoadIntervals[std::min(m_progressiveLoadChunkCount, static_cast<uint16_t>(4))];
+    return m_decoder && m_decoder->isSizeAvailable();
+}
 
-    bool needsUpdate = false;
+IntSize ImageSource::size(ImageOrientationDescription description) const
+{
+    return frameSizeAtIndex(0, 0, description);
+}
 
-    // The first time through, the chunk time will be 0 and the image will get an update.
-    if (currentTime() - m_progressiveLoadChunkTime > interval) {
-        needsUpdate = true;
-        m_progressiveLoadChunkTime = currentTime();
-        ASSERT(m_progressiveLoadChunkCount <= std::numeric_limits<uint16_t>::max());
-        ++m_progressiveLoadChunkCount;
-    }
+IntSize ImageSource::frameSizeAtIndex(size_t index, SubsamplingLevel, ImageOrientationDescription description) const
+{
+    if (!m_decoder)
+        return IntSize();
 
-    if (needsUpdate || allDataReceived)
-        setData(data, allDataReceived);
-#else
-    setData(data, allDataReceived);
-#endif
+    IntSize size = m_decoder->frameSizeAtIndex(index);
+    if ((description.respectImageOrientation() == RespectImageOrientation) && m_decoder->orientation().usesWidthAsHeight())
+        return IntSize(size.height(), size.width());
 
-    m_frameCache->clearMetadata();
-    if (!isSizeAvailable())
-        return false;
+    return size;
+}
 
-    m_frameCache->growFrames();
-    return true;
+bool ImageSource::getHotSpot(IntPoint& hotSpot) const
+{
+    return m_decoder ? m_decoder->hotSpot(hotSpot) : false;
 }
 
-bool ImageSource::isAllDataReceived()
+size_t ImageSource::bytesDecodedToDetermineProperties() const
 {
-    return isDecoderAvailable() ? m_decoder->isAllDataReceived() : m_frameCache->frameCount();
+    return 0;
 }
 
-bool ImageSource::isAsyncDecodingRequired()
+int ImageSource::repetitionCount()
 {
-    // FIXME: figure out the best heuristic for enabling async image decoding.
-    return size().area() * sizeof(RGBA32) >= 100 * KB;
+    return m_decoder ? m_decoder->repetitionCount() : cAnimationNone;
 }
 
-SubsamplingLevel ImageSource::maximumSubsamplingLevel()
+size_t ImageSource::frameCount() const
 {
-    if (m_maximumSubsamplingLevel)
-        return m_maximumSubsamplingLevel.value();
+    return m_decoder ? m_decoder->frameCount() : 0;
+}
 
-    if (!isDecoderAvailable() || !m_decoder->frameAllowSubsamplingAtIndex(0))
-        return SubsamplingLevel::Default;
+NativeImagePtr ImageSource::createFrameImageAtIndex(size_t index, SubsamplingLevel)
+{
+    if (!m_decoder)
+        return nullptr;
 
-    // FIXME: this value was chosen to be appropriate for iOS since the image
-    // subsampling is only enabled by default on iOS. Choose a different value
-    // if image subsampling is enabled on other platform.
-    const int maximumImageAreaBeforeSubsampling = 5 * 1024 * 1024;
-    SubsamplingLevel level = SubsamplingLevel::First;
+    ImageFrame* buffer = m_decoder->frameBufferAtIndex(index);
+    if (!buffer || buffer->status() == ImageFrame::FrameEmpty)
+        return nullptr;
 
-    for (; level < SubsamplingLevel::Last; ++level) {
-        if (frameSizeAtIndex(0, level).area().unsafeGet() < maximumImageAreaBeforeSubsampling)
-            break;
-    }
+    // Zero-height images can cause problems for some ports.  If we have an
+    // empty image dimension, just bail.
+    if (size().isEmpty())
+        return nullptr;
 
-    m_maximumSubsamplingLevel = level;
-    return m_maximumSubsamplingLevel.value();
+    // Return the buffer contents as a native image.  For some ports, the data
+    // is already in a native container, and this just increments its refcount.
+    return buffer->asNewNativeImage();
 }
 
-SubsamplingLevel ImageSource::subsamplingLevelForScale(float scale)
+float ImageSource::frameDurationAtIndex(size_t index)
 {
-    if (!(scale > 0 && scale <= 1))
-        return SubsamplingLevel::Default;
+    if (!m_decoder)
+        return 0;
+
+    ImageFrame* buffer = m_decoder->frameBufferAtIndex(index);
+    if (!buffer || buffer->status() == ImageFrame::FrameEmpty)
+        return 0;
 
-    int result = std::ceil(std::log2(1 / scale));
-    return static_cast<SubsamplingLevel>(std::min(result, static_cast<int>(maximumSubsamplingLevel())));
+    // Many annoying ads specify a 0 duration to make an image flash as quickly as possible.
+    // We follow Firefox's behavior and use a duration of 100 ms for any frames that specify
+    // a duration of <= 10 ms. See <rdar://problem/7689300> and <http://webkit.org/b/36082>
+    // for more information.
+    const float duration = buffer->duration() / 1000.0f;
+    if (duration < 0.011f)
+        return 0.100f;
+    return duration;
 }
 
-NativeImagePtr ImageSource::createFrameImageAtIndex(size_t index, SubsamplingLevel subsamplingLevel)
+ImageOrientation ImageSource::orientationAtIndex(size_t) const
 {
-    return isDecoderAvailable() ? m_decoder->createFrameImageAtIndex(index, subsamplingLevel) : nullptr;
+    return m_decoder ? m_decoder->orientation() : ImageOrientation();
 }
 
-NativeImagePtr ImageSource::frameImageAtIndex(size_t index, SubsamplingLevel subsamplingLevel, const GraphicsContext* targetContext)
+bool ImageSource::frameHasAlphaAtIndex(size_t index)
 {
-    setDecoderTargetContext(targetContext);
-
-    return m_frameCache->frameImageAtIndex(index, subsamplingLevel);
+    if (!m_decoder)
+        return true;
+    return m_decoder->frameHasAlphaAtIndex(index);
 }
 
-void ImageSource::dump(TextStream& ts)
+bool ImageSource::frameIsCompleteAtIndex(size_t index)
 {
-    ts.dumpProperty("type", filenameExtension());
-    ts.dumpProperty("frame-count", frameCount());
-    ts.dumpProperty("repetitions", repetitionCount());
-    ts.dumpProperty("solid-color", singlePixelSolidColor());
+    if (!m_decoder)
+        return false;
+
+    ImageFrame* buffer = m_decoder->frameBufferAtIndex(index);
+    return buffer && buffer->status() == ImageFrame::FrameComplete;
+}
 
-    ImageOrientation orientation = frameOrientationAtIndex(0);
-    if (orientation != OriginTopLeft)
-        ts.dumpProperty("orientation", orientation);
+unsigned ImageSource::frameBytesAtIndex(size_t index, SubsamplingLevel) const
+{
+    if (!m_decoder)
+        return 0;
+    return m_decoder->frameBytesAtIndex(index);
 }
 
 }
+
+#endif // USE(CG)
diff --git a/Source/WebCore/platform/graphics/ImageSource.h b/Source/WebCore/platform/graphics/ImageSource.h
index 3e24126b460..c11f7be4829 100644
--- a/Source/WebCore/platform/graphics/ImageSource.h
+++ b/Source/WebCore/platform/graphics/ImageSource.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2004-2008, 2010, 2012, 2014, 2016 Apple Inc.  All rights reserved.
+ * Copyright (C) 2004, 2005, 2006 Apple Inc.  All rights reserved.
  * Copyright (C) 2007-2008 Torch Mobile, Inc.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -24,102 +24,156 @@
  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
  */
 
-#pragma once
+#ifndef ImageSource_h
+#define ImageSource_h
 
-#include "ImageFrame.h"
-#include "ImageFrameCache.h"
 #include "ImageOrientation.h"
-#include "IntPoint.h"
-#include "NativeImage.h"
-#include "TextStream.h"
+#include "NativeImagePtr.h"
+
 #include <wtf/Forward.h>
 #include <wtf/Noncopyable.h>
-#include <wtf/Optional.h>
+#include <wtf/Vector.h>
+
+#if USE(CG)
+typedef struct CGImageSource* CGImageSourceRef;
+typedef const struct __CFData* CFDataRef;
+#endif
 
 namespace WebCore {
 
-class GraphicsContext;
-class ImageDecoder;
 class ImageOrientation;
 class IntPoint;
 class IntSize;
 class SharedBuffer;
 
+#if USE(CG)
+typedef CGImageSourceRef NativeImageDecoderPtr;
+#else
+class ImageDecoder;
+typedef ImageDecoder* NativeImageDecoderPtr;
+#endif
+
+#if USE(CG)
+#define NativeImageDecoder ImageDecoder
+#else
+typedef ImageDecoder NativeImageDecoder;
+#endif
+
+// Right now GIFs are the only recognized image format that supports animation.
+// The animation system and the constants below are designed with this in mind.
+// GIFs have an optional 16-bit unsigned loop count that describes how an
+// animated GIF should be cycled.  If the loop count is absent, the animation
+// cycles once; if it is 0, the animation cycles infinitely; otherwise the
+// animation plays n + 1 cycles (where n is the specified loop count).  If the
+// GIF decoder defaults to cAnimationLoopOnce in the absence of any loop count
+// and translates an explicit "0" loop count to cAnimationLoopInfinite, then we
+// get a couple of nice side effects:
+//   * By making cAnimationLoopOnce be 0, we allow the animation cycling code in
+//     BitmapImage.cpp to avoid special-casing it, and simply treat all
+//     non-negative loop counts identically.
+//   * By making the other two constants negative, we avoid conflicts with any
+//     real loop count values.
+const int cAnimationLoopOnce = 0;
+const int cAnimationLoopInfinite = -1;
+const int cAnimationNone = -2;
+
+// SubsamplingLevel. 0 is no subsampling, 1 is half dimensions on each axis etc.
+typedef short SubsamplingLevel;
+
 class ImageSource {
     WTF_MAKE_NONCOPYABLE(ImageSource);
-    friend class BitmapImage;
 public:
-    ImageSource(NativeImagePtr&&);
-    ImageSource(Image*, AlphaOption = AlphaOption::Premultiplied, GammaAndColorProfileOption = GammaAndColorProfileOption::Applied);
-    ~ImageSource();
+    enum AlphaOption {
+        AlphaPremultiplied,
+        AlphaNotPremultiplied
+    };
+
+    enum GammaAndColorProfileOption {
+        GammaAndColorProfileApplied,
+        GammaAndColorProfileIgnored
+    };
 
-    void destroyDecodedData(SharedBuffer* data, bool destroyAll = true, size_t count = 0);
-    bool destroyDecodedDataIfNecessary(SharedBuffer* data, bool destroyAll = true, size_t count = 0);
+    ImageSource(AlphaOption alphaOption = AlphaPremultiplied, GammaAndColorProfileOption gammaAndColorProfileOption = GammaAndColorProfileApplied);
+    ~ImageSource();
 
-    bool ensureDecoderAvailable(SharedBuffer*);
-    bool isDecoderAvailable() const { return m_decoder.get(); }
+    // Tells the ImageSource that the Image no longer cares about decoded frame
+    // data -- at all (if |destroyAll| is true), or before frame
+    // |clearBeforeFrame| (if |destroyAll| is false).  The ImageSource should
+    // delete cached decoded data for these frames where possible to keep memory
+    // usage low.  When |destroyAll| is true, the ImageSource should also reset
+    // any local state so that decoding can begin again.
+    //
+    // Implementations that delete less than what's specified above waste
+    // memory.  Implementations that delete more may burn CPU re-decoding frames
+    // that could otherwise have been cached, or encounter errors if they're
+    // asked to decode frames they can't decode due to the loss of previous
+    // decoded frames.
+    //
+    // Callers should not call clear(false, n) and subsequently call
+    // createFrameImageAtIndex(m) with m < n, unless they first call clear(true).
+    // This ensures that stateful ImageSources/decoders will work properly.
+    //
+    // The |data| and |allDataReceived| parameters should be supplied by callers
+    // who set |destroyAll| to true if they wish to be able to continue using
+    // the ImageSource.  This way implementations which choose to destroy their
+    // decoders in some cases can reconstruct them correctly.
+    void clear(bool destroyAll,
+               size_t clearBeforeFrame = 0,
+               SharedBuffer* data = NULL,
+               bool allDataReceived = false);
+
+    bool initialized() const;
 
     void setData(SharedBuffer* data, bool allDataReceived);
-    bool dataChanged(SharedBuffer* data, bool allDataReceived);
-
-    unsigned decodedSize() const { return m_frameCache->decodedSize(); }
-    bool isAllDataReceived();
-
-    bool isAsyncDecodingRequired();
-    bool requestFrameAsyncDecodingAtIndex(size_t index, SubsamplingLevel subsamplingLevel) { return m_frameCache->requestFrameAsyncDecodingAtIndex(index, subsamplingLevel); }
-    void stopAsyncDecodingQueue() { m_frameCache->stopAsyncDecodingQueue(); }
-
-    // Image metadata which is calculated by the decoder or can deduced by the case of the memory NativeImage.
-    bool isSizeAvailable() { return m_frameCache->isSizeAvailable(); }
-    size_t frameCount() { return m_frameCache->frameCount(); }
-    RepetitionCount repetitionCount() { return m_frameCache->repetitionCount(); }
-    String filenameExtension() { return m_frameCache->filenameExtension(); }
-    Optional<IntPoint> hotSpot() { return m_frameCache->hotSpot(); }
-
-    // Image metadata which is calculated from the first ImageFrame.
-    IntSize size() { return m_frameCache->size(); }
-    IntSize sizeRespectingOrientation() { return m_frameCache->sizeRespectingOrientation(); }
-    Color singlePixelSolidColor() { return m_frameCache->singlePixelSolidColor(); }
-
-    // ImageFrame metadata which does not require caching the ImageFrame.
-    bool frameIsBeingDecodedAtIndex(size_t index) { return m_frameCache->frameIsBeingDecodedAtIndex(index); }
-    bool frameIsCompleteAtIndex(size_t index) { return m_frameCache->frameIsCompleteAtIndex(index); }
-    bool frameHasAlphaAtIndex(size_t index) { return m_frameCache->frameHasAlphaAtIndex(index); }
-    bool frameHasImageAtIndex(size_t index) { return m_frameCache->frameHasImageAtIndex(index); }
-    bool frameHasValidNativeImageAtIndex(size_t index, SubsamplingLevel subsamplingLevel) { return m_frameCache->frameHasValidNativeImageAtIndex(index, subsamplingLevel); }
-    SubsamplingLevel frameSubsamplingLevelAtIndex(size_t index) { return m_frameCache->frameSubsamplingLevelAtIndex(index); }
-
-    // ImageFrame metadata which forces caching or re-caching the ImageFrame.
-    IntSize frameSizeAtIndex(size_t index, SubsamplingLevel subsamplingLevel = SubsamplingLevel::Default) { return m_frameCache->frameSizeAtIndex(index, subsamplingLevel); }
-    unsigned frameBytesAtIndex(size_t index, SubsamplingLevel subsamplingLevel = SubsamplingLevel::Default) { return m_frameCache->frameBytesAtIndex(index, subsamplingLevel); }
-    float frameDurationAtIndex(size_t index) { return m_frameCache->frameDurationAtIndex(index); }
-    ImageOrientation frameOrientationAtIndex(size_t index) { return m_frameCache->frameOrientationAtIndex(index); }
-    NativeImagePtr frameImageAtIndex(size_t index, SubsamplingLevel = SubsamplingLevel::Default, const GraphicsContext* targetContext = nullptr);
-
-    SubsamplingLevel maximumSubsamplingLevel();
-    SubsamplingLevel subsamplingLevelForScale(float);
-    NativeImagePtr createFrameImageAtIndex(size_t, SubsamplingLevel = SubsamplingLevel::Default);
+    String filenameExtension() const;
 
-private:
-    void clearFrameBufferCache(size_t);
-    void clear(bool destroyAll, size_t count, SharedBuffer* data);
-    void dump(TextStream&);
+    SubsamplingLevel subsamplingLevelForScale(float) const;
+    bool allowSubsamplingOfFrameAtIndex(size_t) const;
+
+    bool isSizeAvailable();
+    // Always original size, without subsampling.
+    IntSize size(ImageOrientationDescription = ImageOrientationDescription()) const;
+    // Size of optionally subsampled frame.
+    IntSize frameSizeAtIndex(size_t, SubsamplingLevel = 0, ImageOrientationDescription = ImageOrientationDescription()) const;
+
+    bool getHotSpot(IntPoint&) const;
+
+    size_t bytesDecodedToDetermineProperties() const;
+
+    int repetitionCount();
+
+    size_t frameCount() const;
 
-    void setDecoderTargetContext(const GraphicsContext*);
+    // Callers should not call this after calling clear() with a higher index;
+    // see comments on clear() above.
+    NativeImagePtr createFrameImageAtIndex(size_t, SubsamplingLevel = 0);
 
-    Ref<ImageFrameCache> m_frameCache;
-    std::unique_ptr<ImageDecoder> m_decoder;
+    float frameDurationAtIndex(size_t);
+    bool frameHasAlphaAtIndex(size_t); // Whether or not the frame actually used any alpha.
+    bool frameIsCompleteAtIndex(size_t); // Whether or not the frame is completely decoded.
+    ImageOrientation orientationAtIndex(size_t) const; // EXIF image orientation
 
-    Optional<SubsamplingLevel> m_maximumSubsamplingLevel;
+    // Return the number of bytes in the decoded frame. If the frame is not yet
+    // decoded then return 0.
+    unsigned frameBytesAtIndex(size_t, SubsamplingLevel = 0) const;
 
-#if PLATFORM(IOS)
-    // FIXME: We should expose a setting to enable/disable progressive loading so that we can remove the PLATFORM(IOS)-guard.
-    double m_progressiveLoadChunkTime { 0 };
-    uint16_t m_progressiveLoadChunkCount { 0 };
+#if ENABLE(IMAGE_DECODER_DOWN_SAMPLING)
+    static unsigned maxPixelsPerDecodedImage() { return s_maxPixelsPerDecodedImage; }
+    static void setMaxPixelsPerDecodedImage(unsigned maxPixels) { s_maxPixelsPerDecodedImage = maxPixels; }
 #endif
 
-    AlphaOption m_alphaOption { AlphaOption::Premultiplied };
-    GammaAndColorProfileOption m_gammaAndColorProfileOption { GammaAndColorProfileOption::Applied };
+private:
+    NativeImageDecoderPtr m_decoder;
+
+#if !USE(CG)
+    AlphaOption m_alphaOption;
+    GammaAndColorProfileOption m_gammaAndColorProfileOption;
+#endif
+#if ENABLE(IMAGE_DECODER_DOWN_SAMPLING)
+    static unsigned s_maxPixelsPerDecodedImage;
+#endif
 };
 
 }
+
+#endif
diff --git a/Source/WebCore/platform/graphics/IntSize.h b/Source/WebCore/platform/graphics/IntSize.h
index d39b65085ae..0962e2daadb 100644
--- a/Source/WebCore/platform/graphics/IntSize.h
+++ b/Source/WebCore/platform/graphics/IntSize.h
@@ -137,11 +137,6 @@ public:
         return Checked<unsigned, T>(abs(m_width)) * abs(m_height);
     }
 
-    size_t unclampedArea() const
-    {
-        return static_cast<size_t>(abs(m_width)) * abs(m_height);
-    }
-
     int diagonalLengthSquared() const
     {
         return m_width * m_width + m_height * m_height;
diff --git a/Source/WebCore/platform/graphics/MediaPlayer.h b/Source/WebCore/platform/graphics/MediaPlayer.h
index 66939f5ed15..f0fc581df85 100644
--- a/Source/WebCore/platform/graphics/MediaPlayer.h
+++ b/Source/WebCore/platform/graphics/MediaPlayer.h
@@ -36,7 +36,7 @@
 #include "URL.h"
 #include "LayoutRect.h"
 #include "MediaPlayerEnums.h"
-#include "NativeImage.h"
+#include "NativeImagePtr.h"
 #include "PlatformLayer.h"
 #include "PlatformMediaResourceLoader.h"
 #include "PlatformMediaSession.h"
diff --git a/Source/WebCore/platform/graphics/NamedImageGeneratedImage.cpp b/Source/WebCore/platform/graphics/NamedImageGeneratedImage.cpp
index 591b4dde2fe..bd798c0953f 100644
--- a/Source/WebCore/platform/graphics/NamedImageGeneratedImage.cpp
+++ b/Source/WebCore/platform/graphics/NamedImageGeneratedImage.cpp
@@ -61,10 +61,10 @@ void NamedImageGeneratedImage::draw(GraphicsContext& context, const FloatRect& d
 #endif
 }
 
-void NamedImageGeneratedImage::drawPattern(GraphicsContext& context, const FloatRect& dstRect, const FloatRect& srcRect, const AffineTransform& patternTransform, const FloatPoint& phase, const FloatSize& spacing, CompositeOperator compositeOp, BlendMode blendMode)
+void NamedImageGeneratedImage::drawPattern(GraphicsContext& context, const FloatRect& srcRect, const AffineTransform& patternTransform, const FloatPoint& phase, const FloatSize& spacing, CompositeOperator compositeOp, const FloatRect& dstRect, BlendMode blendMode)
 {
 #if USE(NEW_THEME)
-    auto imageBuffer = ImageBuffer::createCompatibleBuffer(size(), context);
+    std::unique_ptr<ImageBuffer> imageBuffer = context.createCompatibleBuffer(size(), true);
     if (!imageBuffer)
         return;
 
@@ -72,7 +72,7 @@ void NamedImageGeneratedImage::drawPattern(GraphicsContext& context, const Float
     platformTheme()->drawNamedImage(m_name, graphicsContext, FloatRect(0, 0, size().width(), size().height()));
 
     // Tile the image buffer into the context.
-    imageBuffer->drawPattern(context, dstRect, srcRect, patternTransform, phase, spacing, compositeOp, blendMode);
+    imageBuffer->drawPattern(context, srcRect, patternTransform, phase, spacing, compositeOp, dstRect, blendMode);
 #else
     UNUSED_PARAM(context);
     UNUSED_PARAM(srcRect);
diff --git a/Source/WebCore/platform/graphics/NamedImageGeneratedImage.h b/Source/WebCore/platform/graphics/NamedImageGeneratedImage.h
index 1bac56af9b6..d0b79c4bd98 100644
--- a/Source/WebCore/platform/graphics/NamedImageGeneratedImage.h
+++ b/Source/WebCore/platform/graphics/NamedImageGeneratedImage.h
@@ -41,7 +41,7 @@ public:
 
 protected:
     void draw(GraphicsContext&, const FloatRect& dstRect, const FloatRect& srcRect, CompositeOperator, BlendMode, ImageOrientationDescription) override;
-    void drawPattern(GraphicsContext&, const FloatRect& dstRect, const FloatRect& srcRect, const AffineTransform& patternTransform, const FloatPoint& phase, const FloatSize& spacing, CompositeOperator, BlendMode) override;
+    void drawPattern(GraphicsContext&, const FloatRect& srcRect, const AffineTransform& patternTransform, const FloatPoint& phase, const FloatSize& spacing, CompositeOperator, const FloatRect& dstRect, BlendMode) override;
 
     NamedImageGeneratedImage(String name, const FloatSize&);
 
diff --git a/Source/WebCore/platform/graphics/NativeImage.h b/Source/WebCore/platform/graphics/NativeImagePtr.h
similarity index 67%
rename from Source/WebCore/platform/graphics/NativeImage.h
rename to Source/WebCore/platform/graphics/NativeImagePtr.h
index 4a4f1d0efbb..0346665b36d 100644
--- a/Source/WebCore/platform/graphics/NativeImage.h
+++ b/Source/WebCore/platform/graphics/NativeImagePtr.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2004, 2005, 2006, 2016 Apple Inc.  All rights reserved.
+ * Copyright (C) 2004, 2005, 2006 Apple Inc.  All rights reserved.
  * Copyright (C) 2007-2008 Torch Mobile, Inc.
  * Copyright (C) 2012 Company 100 Inc.
  *
@@ -22,13 +22,11 @@
  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
  */
 
-#pragma once
-
-#include "GraphicsTypes.h"
-#include "ImageOrientation.h"
+#ifndef NativeImagePtr_h
+#define NativeImagePtr_h
 
 #if USE(CG)
 #include <wtf/RetainPtr.h>
@@ -39,35 +37,16 @@ typedef struct CGImage* CGImageRef;
 #include "SharedBitmap.h"
 #endif
 
-#if USE(DIRECT2D)
-#include "COMPtr.h"
-#include <d2d1.h>
-#endif
-
 namespace WebCore {
 
-class Color;
-class FloatRect;
-class IntSize;
-class GraphicsContext;
-
 #if USE(CG)
 typedef RetainPtr<CGImageRef> NativeImagePtr;
-#elif USE(DIRECT2D)
-typedef COMPtr<ID2D1Bitmap> NativeImagePtr;
 #elif USE(CAIRO)
 typedef RefPtr<cairo_surface_t> NativeImagePtr;
 #elif USE(WINGDI)
 typedef RefPtr<SharedBitmap> NativeImagePtr;
 #endif
 
-IntSize nativeImageSize(const NativeImagePtr&);
-bool nativeImageHasAlpha(const NativeImagePtr&);
-Color nativeImageSinglePixelSolidColor(const NativeImagePtr&);
-
-float subsamplingScale(GraphicsContext&, const FloatRect& destRect, const FloatRect& srcRect);
-
-void drawNativeImage(const NativeImagePtr&, GraphicsContext&, const FloatRect&, const FloatRect&, const IntSize&, CompositeOperator, BlendMode, const ImageOrientation&);
-void clearNativeImageSubimages(const NativeImagePtr&);
-    
 }
+
+#endif
diff --git a/Source/WebCore/platform/graphics/Pattern.h b/Source/WebCore/platform/graphics/Pattern.h
index 256fa2d5fb4..01a73b6b160 100644
--- a/Source/WebCore/platform/graphics/Pattern.h
+++ b/Source/WebCore/platform/graphics/Pattern.h
@@ -39,6 +39,7 @@ typedef struct CGPattern* CGPatternRef;
 typedef CGPatternRef PlatformPatternPtr;
 #elif USE(DIRECT2D)
 interface ID2D1BitmapBrush;
+interface ID2D1RenderTarget;
 typedef ID2D1BitmapBrush* PlatformPatternPtr;
 #elif USE(CAIRO)
 #include <cairo.h>
@@ -50,7 +51,6 @@ typedef void* PlatformPatternPtr;
 namespace WebCore {
 
 class AffineTransform;
-class GraphicsContext;
 class Image;
 
 class Pattern final : public RefCounted<Pattern> {
@@ -66,7 +66,7 @@ public:
 #if !USE(DIRECT2D)
     PlatformPatternPtr createPlatformPattern(const AffineTransform& userSpaceTransformation) const;
 #else
-    PlatformPatternPtr createPlatformPattern(const GraphicsContext&, float alpha, const AffineTransform& userSpaceTransformation) const;
+    PlatformPatternPtr createPlatformPattern(ID2D1RenderTarget*, float alpha, const AffineTransform& userSpaceTransformation) const;
 #endif
     void setPatternSpaceTransform(const AffineTransform& patternSpaceTransformation);
     const AffineTransform& getPatternSpaceTransform() { return m_patternSpaceTransformation; };
diff --git a/Source/WebCore/platform/graphics/avfoundation/objc/MediaPlayerPrivateMediaStreamAVFObjC.mm b/Source/WebCore/platform/graphics/avfoundation/objc/MediaPlayerPrivateMediaStreamAVFObjC.mm
index 6e1f76c654c..6d0426d0a21 100644
--- a/Source/WebCore/platform/graphics/avfoundation/objc/MediaPlayerPrivateMediaStreamAVFObjC.mm
+++ b/Source/WebCore/platform/graphics/avfoundation/objc/MediaPlayerPrivateMediaStreamAVFObjC.mm
@@ -331,7 +331,7 @@ void MediaPlayerPrivateMediaStreamAVFObjC::updatePausedImage()
     if (!image)
         return;
 
-    m_pausedImage = image->nativeImage();
+    m_pausedImage = image->getCGImageRef();
     ASSERT(m_pausedImage);
 }
 
diff --git a/Source/WebCore/platform/graphics/cairo/BitmapImageCairo.cpp b/Source/WebCore/platform/graphics/cairo/BitmapImageCairo.cpp
new file mode 100644
index 00000000000..bda0dc281c9
--- /dev/null
+++ b/Source/WebCore/platform/graphics/cairo/BitmapImageCairo.cpp
@@ -0,0 +1,170 @@
+/*
+ * Copyright (C) 2004, 2005, 2006 Apple Inc.  All rights reserved.
+ * Copyright (C) 2007 Alp Toker <alp@atoker.com>
+ * Copyright (C) 2009 Dirk Schulze <krit@webkit.org>
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
+ * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "config.h"
+#include "BitmapImage.h"
+
+#if USE(CAIRO)
+
+#include "CairoUtilities.h"
+#include "ImageObserver.h"
+#include "PlatformContextCairo.h"
+#include "Timer.h"
+#include <cairo.h>
+
+namespace WebCore {
+
+BitmapImage::BitmapImage(RefPtr<cairo_surface_t>&& nativeImage, ImageObserver* observer)
+    : Image(observer)
+    , m_size(cairoSurfaceSize(nativeImage.get()))
+    , m_minimumSubsamplingLevel(0)
+    , m_currentFrame(0)
+    , m_repetitionCount(cAnimationNone)
+    , m_repetitionCountStatus(Unknown)
+    , m_repetitionsComplete(0)
+    , m_decodedSize(m_size.width() * m_size.height() * 4)
+    , m_frameCount(1)
+    , m_isSolidColor(false)
+    , m_checkedForSolidColor(false)
+    , m_animationFinished(true)
+    , m_allDataReceived(true)
+    , m_haveSize(true)
+    , m_sizeAvailable(true)
+    , m_haveFrameCount(true)
+{
+    m_frames.grow(1);
+    m_frames[0].m_hasAlpha = cairo_surface_get_content(nativeImage.get()) != CAIRO_CONTENT_COLOR;
+    m_frames[0].m_image = WTFMove(nativeImage);
+    m_frames[0].m_haveMetadata = true;
+
+    checkForSolidColor();
+}
+
+void BitmapImage::draw(GraphicsContext& context, const FloatRect& dst, const FloatRect& src, CompositeOperator op,
+    BlendMode blendMode, ImageOrientationDescription description)
+{
+    if (!dst.width() || !dst.height() || !src.width() || !src.height())
+        return;
+
+    startAnimation();
+
+    auto surface = frameImageAtIndex(m_currentFrame);
+    if (!surface) // If it's too early we won't have an image yet.
+        return;
+
+    if (mayFillWithSolidColor()) {
+        fillWithSolidColor(context, dst, solidColor(), op);
+        return;
+    }
+
+    context.save();
+
+    // Set the compositing operation.
+    if (op == CompositeSourceOver && blendMode == BlendModeNormal && !frameHasAlphaAtIndex(m_currentFrame))
+        context.setCompositeOperation(CompositeCopy);
+    else
+        context.setCompositeOperation(op, blendMode);
+
+#if ENABLE(IMAGE_DECODER_DOWN_SAMPLING)
+    IntSize scaledSize = cairoSurfaceSize(surface.get());
+    FloatRect adjustedSrcRect = adjustSourceRectForDownSampling(src, scaledSize);
+#else
+    FloatRect adjustedSrcRect(src);
+#endif
+
+    ImageOrientation frameOrientation(description.imageOrientation());
+    if (description.respectImageOrientation() == RespectImageOrientation)
+        frameOrientation = frameOrientationAtIndex(m_currentFrame);
+
+    FloatRect dstRect = dst;
+
+    if (frameOrientation != DefaultImageOrientation) {
+        // ImageOrientation expects the origin to be at (0, 0).
+        context.translate(dstRect.x(), dstRect.y());
+        dstRect.setLocation(FloatPoint());
+        context.concatCTM(frameOrientation.transformFromDefault(dstRect.size()));
+        if (frameOrientation.usesWidthAsHeight()) {
+            // The destination rectangle will have it's width and height already reversed for the orientation of
+            // the image, as it was needed for page layout, so we need to reverse it back here.
+            dstRect = FloatRect(dstRect.x(), dstRect.y(), dstRect.height(), dstRect.width());
+        }
+    }
+
+    context.platformContext()->drawSurfaceToContext(surface.get(), dstRect, adjustedSrcRect, context);
+
+    context.restore();
+
+    if (imageObserver())
+        imageObserver()->didDraw(this);
+}
+
+void BitmapImage::determineMinimumSubsamplingLevel() const
+{
+    m_minimumSubsamplingLevel = 0;
+}
+
+void BitmapImage::checkForSolidColor()
+{
+    m_isSolidColor = false;
+    m_checkedForSolidColor = true;
+
+    if (frameCount() > 1)
+        return;
+
+    auto surface = frameImageAtIndex(m_currentFrame);
+    if (!surface) // If it's too early we won't have an image yet.
+        return;
+
+    if (cairo_surface_get_type(surface.get()) != CAIRO_SURFACE_TYPE_IMAGE)
+        return;
+
+    IntSize size = cairoSurfaceSize(surface.get());
+
+    if (size.width() != 1 || size.height() != 1)
+        return;
+
+    unsigned* pixelColor = reinterpret_cast_ptr<unsigned*>(cairo_image_surface_get_data(surface.get()));
+    m_solidColor = colorFromPremultipliedARGB(*pixelColor);
+
+    m_isSolidColor = true;
+}
+
+bool FrameData::clear(bool clearMetadata)
+{
+    if (clearMetadata)
+        m_haveMetadata = false;
+
+    if (m_image) {
+        m_image = nullptr;
+        return true;
+    }
+    return false;
+}
+
+} // namespace WebCore
+
+#endif // USE(CAIRO)
diff --git a/Source/WebCore/platform/graphics/cairo/GraphicsContext3DCairo.cpp b/Source/WebCore/platform/graphics/cairo/GraphicsContext3DCairo.cpp
index aa6fda11070..1f95613add5 100644
--- a/Source/WebCore/platform/graphics/cairo/GraphicsContext3DCairo.cpp
+++ b/Source/WebCore/platform/graphics/cairo/GraphicsContext3DCairo.cpp
@@ -223,16 +223,12 @@ bool GraphicsContext3D::ImageExtractor::extractImage(bool premultiplyAlpha, bool
     if (!m_image)
         return false;
     // We need this to stay in scope because the native image is just a shallow copy of the data.
-    AlphaOption alphaOption = premultiplyAlpha ? AlphaOption::Premultiplied : AlphaOption::NotPremultiplied;
-    GammaAndColorProfileOption gammaAndColorProfileOption = ignoreGammaAndColorProfile ? GammaAndColorProfileOption::Ignored : GammaAndColorProfileOption::Applied;
-    m_decoder = new ImageSource(nullptr, alphaOption, gammaAndColorProfileOption);
-    
+    m_decoder = new ImageSource(premultiplyAlpha ? ImageSource::AlphaPremultiplied : ImageSource::AlphaNotPremultiplied, ignoreGammaAndColorProfile ? ImageSource::GammaAndColorProfileIgnored : ImageSource::GammaAndColorProfileApplied);
     if (!m_decoder)
         return false;
-
     ImageSource& decoder = *m_decoder;
-    m_alphaOp = AlphaDoNothing;
 
+    m_alphaOp = AlphaDoNothing;
     if (m_image->data()) {
         decoder.setData(m_image->data(), true);
         if (!decoder.frameCount())
diff --git a/Source/WebCore/platform/graphics/cairo/GraphicsContextCairo.cpp b/Source/WebCore/platform/graphics/cairo/GraphicsContextCairo.cpp
index a67a0afbb3a..d49effeda9c 100644
--- a/Source/WebCore/platform/graphics/cairo/GraphicsContextCairo.cpp
+++ b/Source/WebCore/platform/graphics/cairo/GraphicsContextCairo.cpp
@@ -1161,13 +1161,13 @@ void GraphicsContext::fillRectWithRoundedHole(const FloatRect& rect, const Float
     cairo_restore(cr);
 }
 
-void GraphicsContext::drawPattern(Image& image, const FloatRect& destRect, const FloatRect& tileRect, const AffineTransform& patternTransform, const FloatPoint& phase, const FloatSize& spacing, CompositeOperator op, BlendMode blendMode)
+void GraphicsContext::drawPattern(Image& image, const FloatRect& tileRect, const AffineTransform& patternTransform, const FloatPoint& phase, const FloatSize& spacing, CompositeOperator op, const FloatRect& destRect, BlendMode blendMode)
 {
     if (paintingDisabled())
         return;
 
     if (isRecording()) {
-        m_displayListRecorder->drawPattern(image, destRect, tileRect, patternTransform, phase, spacing, op, blendMode);
+        m_displayListRecorder->drawPattern(image, tileRect, patternTransform, phase, spacing, op, destRect, blendMode);
         return;
     }
 
diff --git a/Source/WebCore/platform/graphics/cairo/ImageBufferCairo.cpp b/Source/WebCore/platform/graphics/cairo/ImageBufferCairo.cpp
index 10724f60348..3e50510c2b3 100644
--- a/Source/WebCore/platform/graphics/cairo/ImageBufferCairo.cpp
+++ b/Source/WebCore/platform/graphics/cairo/ImageBufferCairo.cpp
@@ -273,11 +273,6 @@ ImageBuffer::~ImageBuffer()
 {
 }
 
-std::unique_ptr<ImageBuffer> ImageBuffer::createCompatibleBuffer(const FloatSize& size, const GraphicsContext& context)
-{
-    return createCompatibleBuffer(size, ColorSpaceSRGB, context);
-}
-
 GraphicsContext& ImageBuffer::context() const
 {
     return *m_data.m_context;
@@ -316,11 +311,11 @@ void ImageBuffer::draw(GraphicsContext& destinationContext, const FloatRect& des
     destinationContext.drawImage(*image, destRect, srcRect, ImagePaintingOptions(op, blendMode, ImageOrientationDescription()));
 }
 
-void ImageBuffer::drawPattern(GraphicsContext& context, const FloatRect& destRect, const FloatRect& srcRect, const AffineTransform& patternTransform,
-    const FloatPoint& phase, const FloatSize& spacing, CompositeOperator op, BlendMode)
+void ImageBuffer::drawPattern(GraphicsContext& context, const FloatRect& srcRect, const AffineTransform& patternTransform,
+    const FloatPoint& phase, const FloatSize& spacing, CompositeOperator op, const FloatRect& destRect, BlendMode)
 {
     if (RefPtr<Image> image = copyImage(DontCopyBackingStore))
-        image->drawPattern(context, destRect, srcRect, patternTransform, phase, spacing, op);
+        image->drawPattern(context, srcRect, patternTransform, phase, spacing, op, destRect);
 }
 
 void ImageBuffer::platformTransformColorSpace(const Vector<int>& lookUpTable)
diff --git a/Source/WebCore/platform/graphics/cairo/ImageCairo.cpp b/Source/WebCore/platform/graphics/cairo/ImageCairo.cpp
index 4e536595855..11e57b4bd1c 100644
--- a/Source/WebCore/platform/graphics/cairo/ImageCairo.cpp
+++ b/Source/WebCore/platform/graphics/cairo/ImageCairo.cpp
@@ -31,16 +31,20 @@
 #if USE(CAIRO)
 
 #include "AffineTransform.h"
+#include "CairoUtilities.h"
 #include "Color.h"
 #include "GraphicsContext.h"
 #include "ImageObserver.h"
+#include "PlatformContextCairo.h"
+#include <cairo.h>
+#include <math.h>
 
 namespace WebCore {
 
-void Image::drawPattern(GraphicsContext& context, const FloatRect& destRect, const FloatRect& tileRect, const AffineTransform& patternTransform,
-    const FloatPoint& phase, const FloatSize& spacing, CompositeOperator op, BlendMode blendMode)
+void Image::drawPattern(GraphicsContext& context, const FloatRect& tileRect, const AffineTransform& patternTransform,
+    const FloatPoint& phase, const FloatSize& spacing, CompositeOperator op, const FloatRect& destRect, BlendMode blendMode)
 {
-    context.drawPattern(*this, destRect, tileRect, patternTransform, phase, spacing, op, blendMode);
+    context.drawPattern(*this, tileRect, patternTransform, phase, spacing, op, destRect, blendMode);
 
     if (imageObserver())
         imageObserver()->didDraw(this);
diff --git a/Source/WebCore/platform/graphics/cairo/NativeImageCairo.cpp b/Source/WebCore/platform/graphics/cairo/NativeImageCairo.cpp
deleted file mode 100644
index 69b7bb0f8b3..00000000000
--- a/Source/WebCore/platform/graphics/cairo/NativeImageCairo.cpp
+++ /dev/null
@@ -1,105 +0,0 @@
-/*
- * Copyright (C) 2016 Apple Inc.  All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS'' AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
- * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#include "config.h"
-#include "NativeImage.h"
-
-#if USE(CAIRO)
-
-#include "CairoUtilities.h"
-#include "PlatformContextCairo.h"
-#include <cairo.h>
-
-namespace WebCore {
-
-IntSize nativeImageSize(const NativeImagePtr& image)
-{
-    return image ? cairoSurfaceSize(image.get()) : IntSize();
-}
-
-bool nativeImageHasAlpha(const NativeImagePtr& image)
-{
-    return !image || cairo_surface_get_content(image.get()) != CAIRO_CONTENT_COLOR;
-}
-
-Color nativeImageSinglePixelSolidColor(const NativeImagePtr& image)
-{
-    if (!image || nativeImageSize(image) != IntSize(1, 1))
-        return Color();
-
-    if (cairo_surface_get_type(image.get()) != CAIRO_SURFACE_TYPE_IMAGE)
-        return Color();
-
-    RGBA32* pixel = reinterpret_cast_ptr<RGBA32*>(cairo_image_surface_get_data(image.get()));
-    return colorFromPremultipliedARGB(*pixel);
-}
-
-float subsamplingScale(GraphicsContext&, const FloatRect&, const FloatRect&)
-{
-    return 1;
-}
-
-void drawNativeImage(const NativeImagePtr& image, GraphicsContext& context, const FloatRect& destRect, const FloatRect& srcRect, const IntSize&, CompositeOperator op, BlendMode mode, const ImageOrientation& orientation)
-{
-    context.save();
-    
-    // Set the compositing operation.
-    if (op == CompositeSourceOver && mode == BlendModeNormal && !nativeImageHasAlpha(image))
-        context.setCompositeOperation(CompositeCopy);
-    else
-        context.setCompositeOperation(op, mode);
-        
-#if ENABLE(IMAGE_DECODER_DOWN_SAMPLING)
-    IntSize scaledSize = nativeImageSize(image);
-    FloatRect adjustedSrcRect = adjustSourceRectForDownSampling(srcRect, scaledSize);
-#else
-    FloatRect adjustedSrcRect(srcRect);
-#endif
-        
-    FloatRect adjustedDestRect = destRect;
-        
-    if (orientation != DefaultImageOrientation) {
-        // ImageOrientation expects the origin to be at (0, 0).
-        context.translate(destRect.x(), destRect.y());
-        adjustedDestRect.setLocation(FloatPoint());
-        context.concatCTM(orientation.transformFromDefault(adjustedDestRect.size()));
-        if (orientation.usesWidthAsHeight()) {
-            // The destination rectangle will have it's width and height already reversed for the orientation of
-            // the image, as it was needed for page layout, so we need to reverse it back here.
-            adjustedDestRect.setSize(adjustedDestRect.size().transposedSize());
-        }
-    }
-
-    context.platformContext()->drawSurfaceToContext(image.get(), adjustedDestRect, adjustedSrcRect, context);
-    context.restore();
-}
-
-void clearNativeImageSubimages(const NativeImagePtr&)
-{
-}
-
-} // namespace WebCore
-
-#endif // USE(CAIRO)
diff --git a/Source/WebCore/platform/graphics/cg/BitmapImageCG.cpp b/Source/WebCore/platform/graphics/cg/BitmapImageCG.cpp
new file mode 100644
index 00000000000..32bd0b5cb55
--- /dev/null
+++ b/Source/WebCore/platform/graphics/cg/BitmapImageCG.cpp
@@ -0,0 +1,269 @@
+/*
+ * Copyright (C) 2004, 2005, 2006 Apple Inc. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
+ * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
+ */
+
+#include "config.h"
+#include "BitmapImage.h"
+
+#if USE(CG)
+
+#include "CoreGraphicsSPI.h"
+#include "FloatConversion.h"
+#include "GeometryUtilities.h"
+#include "GraphicsContextCG.h"
+#include "ImageObserver.h"
+#include "SubimageCacheWithTimer.h"
+#include <wtf/RetainPtr.h>
+
+#if USE(APPKIT)
+#include <ApplicationServices/ApplicationServices.h>
+#endif
+
+#if PLATFORM(COCOA)
+#include "WebCoreSystemInterface.h"
+#endif
+
+#if PLATFORM(WIN)
+#include <WebKitSystemInterface/WebKitSystemInterface.h>
+#endif
+
+namespace WebCore {
+
+bool FrameData::clear(bool clearMetadata)
+{
+    if (clearMetadata)
+        m_haveMetadata = false;
+
+    m_orientation = DefaultImageOrientation;
+    m_subsamplingLevel = 0;
+
+    if (m_image) {
+#if CACHE_SUBIMAGES
+        subimageCache().clearImage(m_image.get());
+#endif
+        m_image = nullptr;
+        return true;
+    }
+    return false;
+}
+
+BitmapImage::BitmapImage(RetainPtr<CGImageRef>&& image, ImageObserver* observer)
+    : Image(observer)
+    , m_minimumSubsamplingLevel(0)
+    , m_imageOrientation(OriginTopLeft)
+    , m_shouldRespectImageOrientation(false)
+    , m_currentFrame(0)
+    , m_repetitionCount(cAnimationNone)
+    , m_repetitionCountStatus(Unknown)
+    , m_repetitionsComplete(0)
+    , m_decodedSize(0)
+    , m_decodedPropertiesSize(0)
+    , m_frameCount(1)
+    , m_isSolidColor(false)
+    , m_checkedForSolidColor(false)
+    , m_animationFinished(true)
+    , m_allDataReceived(true)
+    , m_haveSize(true)
+    , m_sizeAvailable(true)
+    , m_haveFrameCount(true)
+{
+    CGFloat width = CGImageGetWidth(image.get());
+    CGFloat height = CGImageGetHeight(image.get());
+    m_decodedSize = width * height * 4;
+    m_size = IntSize(width, height);
+
+    // Since we don't have a decoder, we can't figure out the image orientation.
+    // Set m_sizeRespectingOrientation to be the same as m_size so it's not 0x0.
+    m_sizeRespectingOrientation = m_size;
+
+    m_frames.grow(1);
+    m_frames[0].m_image = WTFMove(image);
+    m_frames[0].m_hasAlpha = true;
+    m_frames[0].m_haveMetadata = true;
+
+    checkForSolidColor();
+}
+
+void BitmapImage::determineMinimumSubsamplingLevel() const
+{
+    if (!m_allowSubsampling)
+        return;
+
+    if (!m_source.allowSubsamplingOfFrameAtIndex(0))
+        return;
+
+    // Values chosen to be appropriate for iOS.
+    const int cMaximumImageAreaBeforeSubsampling = 5 * 1024 * 1024;
+    const SubsamplingLevel maxSubsamplingLevel = 3;
+
+    SubsamplingLevel currentLevel = 0;
+    for ( ; currentLevel <= maxSubsamplingLevel; ++currentLevel) {
+        IntSize frameSize = m_source.frameSizeAtIndex(0, currentLevel);
+        if (frameSize.area() < cMaximumImageAreaBeforeSubsampling)
+            break;
+    }
+
+    m_minimumSubsamplingLevel = currentLevel;
+}
+
+void BitmapImage::checkForSolidColor()
+{
+    m_checkedForSolidColor = true;
+    m_isSolidColor = false;
+
+    if (frameCount() > 1)
+        return;
+
+    if (!haveFrameImageAtIndex(0)) {
+        IntSize size = m_source.frameSizeAtIndex(0, 0);
+        if (size.width() != 1 || size.height() != 1)
+            return;
+
+        if (!ensureFrameIsCached(0))
+            return;
+    }
+
+    CGImageRef image = nullptr;
+    if (m_frames.size())
+        image = m_frames[0].m_image.get();
+
+    if (!image)
+        return;
+
+    // Currently we only check for solid color in the important special case of a 1x1 image.
+    if (CGImageGetWidth(image) == 1 && CGImageGetHeight(image) == 1) {
+        unsigned char pixel[4]; // RGBA
+        RetainPtr<CGContextRef> bitmapContext = adoptCF(CGBitmapContextCreate(pixel, 1, 1, 8, sizeof(pixel), sRGBColorSpaceRef(),
+            kCGImageAlphaPremultipliedLast | kCGBitmapByteOrder32Big));
+        if (!bitmapContext)
+            return;
+        GraphicsContext(bitmapContext.get()).setCompositeOperation(CompositeCopy);
+        CGRect destinationRect = CGRectMake(0, 0, 1, 1);
+        CGContextDrawImage(bitmapContext.get(), destinationRect, image);
+        if (!pixel[3])
+            m_solidColor = Color(0, 0, 0, 0);
+        else
+            m_solidColor = Color(pixel[0] * 255 / pixel[3], pixel[1] * 255 / pixel[3], pixel[2] * 255 / pixel[3], pixel[3]);
+
+        m_isSolidColor = true;
+    }
+}
+
+CGImageRef BitmapImage::getCGImageRef()
+{
+    return frameImageAtIndex(0).get();
+}
+
+CGImageRef BitmapImage::getFirstCGImageRefOfSize(const IntSize& size)
+{
+    size_t count = frameCount();
+    for (size_t i = 0; i < count; ++i) {
+        CGImageRef cgImage = frameImageAtIndex(i).get();
+        if (cgImage && IntSize(CGImageGetWidth(cgImage), CGImageGetHeight(cgImage)) == size)
+            return cgImage;
+    }
+
+    // Fallback to the default CGImageRef if we can't find the right size
+    return getCGImageRef();
+}
+
+RetainPtr<CFArrayRef> BitmapImage::getCGImageArray()
+{
+    size_t count = frameCount();
+    if (!count)
+        return nullptr;
+    
+    CFMutableArrayRef array = CFArrayCreateMutable(NULL, count, &kCFTypeArrayCallBacks);
+    for (size_t i = 0; i < count; ++i) {
+        if (CGImageRef currFrame = frameImageAtIndex(i).get())
+            CFArrayAppendValue(array, currFrame);
+    }
+    return adoptCF(array);
+}
+
+void BitmapImage::draw(GraphicsContext& ctxt, const FloatRect& destRect, const FloatRect& srcRect, CompositeOperator compositeOp, BlendMode blendMode, ImageOrientationDescription description)
+{
+#if PLATFORM(IOS)
+    startAnimation(DoNotCatchUp);
+#else
+    startAnimation();
+#endif
+
+    RetainPtr<CGImageRef> image;
+    // Never use subsampled images for drawing into PDF contexts.
+    if (wkCGContextIsPDFContext(ctxt.platformContext()))
+        image = copyUnscaledFrameImageAtIndex(m_currentFrame);
+    else {
+        CGRect transformedDestinationRect = CGRectApplyAffineTransform(destRect, CGContextGetCTM(ctxt.platformContext()));
+        float subsamplingScale = std::min<float>(1, std::max(transformedDestinationRect.size.width / srcRect.width(), transformedDestinationRect.size.height / srcRect.height()));
+
+        image = frameImageAtIndex(m_currentFrame, subsamplingScale);
+    }
+
+    if (!image) // If it's too early we won't have an image yet.
+        return;
+    
+    if (mayFillWithSolidColor()) {
+        fillWithSolidColor(ctxt, destRect, solidColor(), compositeOp);
+        return;
+    }
+
+    // Subsampling may have given us an image that is smaller than size().
+    IntSize imageSize(CGImageGetWidth(image.get()), CGImageGetHeight(image.get()));
+    
+    // srcRect is in the coordinates of the unsubsampled image, so we have to map it to the subsampled image.
+    FloatRect scaledSrcRect = srcRect;
+    if (imageSize != m_size) {
+        FloatRect originalImageBounds(FloatPoint(), m_size);
+        FloatRect subsampledImageBounds(FloatPoint(), imageSize);
+        scaledSrcRect = mapRect(srcRect, originalImageBounds, subsampledImageBounds);
+    }
+    
+    ImageOrientation orientation;
+    if (description.respectImageOrientation() == RespectImageOrientation)
+        orientation = frameOrientationAtIndex(m_currentFrame);
+
+    ctxt.drawNativeImage(image, imageSize, destRect, scaledSrcRect, compositeOp, blendMode, orientation);
+
+    if (imageObserver())
+        imageObserver()->didDraw(this);
+}
+
+RetainPtr<CGImageRef> BitmapImage::copyUnscaledFrameImageAtIndex(size_t index)
+{
+    if (index >= frameCount())
+        return nullptr;
+
+    if (index >= m_frames.size() || !m_frames[index].m_image)
+        cacheFrame(index, 0);
+
+    if (!m_frames[index].m_subsamplingLevel)
+        return m_frames[index].m_image;
+
+    return m_source.createFrameImageAtIndex(index);
+}
+
+}
+
+#endif // USE(CG)
diff --git a/Source/WebCore/platform/graphics/cg/GraphicsContext3DCG.cpp b/Source/WebCore/platform/graphics/cg/GraphicsContext3DCG.cpp
index c3cb78bc2bd..99f09db67ba 100644
--- a/Source/WebCore/platform/graphics/cg/GraphicsContext3DCG.cpp
+++ b/Source/WebCore/platform/graphics/cg/GraphicsContext3DCG.cpp
@@ -327,7 +327,8 @@ bool GraphicsContext3D::ImageExtractor::extractImage(bool premultiplyAlpha, bool
         return false;
     bool hasAlpha = !m_image->currentFrameKnownToBeOpaque();
     if ((ignoreGammaAndColorProfile || (hasAlpha && !premultiplyAlpha)) && m_image->data()) {
-        ImageSource decoder(nullptr, AlphaOption::NotPremultiplied, ignoreGammaAndColorProfile ? GammaAndColorProfileOption::Ignored : GammaAndColorProfileOption::Applied);
+        ImageSource decoder(ImageSource::AlphaNotPremultiplied,
+                            ignoreGammaAndColorProfile ? ImageSource::GammaAndColorProfileIgnored : ImageSource::GammaAndColorProfileApplied);
         decoder.setData(m_image->data(), true);
         if (!decoder.frameCount())
             return false;
diff --git a/Source/WebCore/platform/graphics/cg/GraphicsContextCG.cpp b/Source/WebCore/platform/graphics/cg/GraphicsContextCG.cpp
index c2d227b4fb5..ebf481e4095 100644
--- a/Source/WebCore/platform/graphics/cg/GraphicsContextCG.cpp
+++ b/Source/WebCore/platform/graphics/cg/GraphicsContextCG.cpp
@@ -324,13 +324,13 @@ static void patternReleaseCallback(void* info)
     });
 }
 
-void GraphicsContext::drawPattern(Image& image, const FloatRect& destRect, const FloatRect& tileRect, const AffineTransform& patternTransform, const FloatPoint& phase, const FloatSize& spacing, CompositeOperator op, BlendMode blendMode)
+void GraphicsContext::drawPattern(Image& image, const FloatRect& tileRect, const AffineTransform& patternTransform, const FloatPoint& phase, const FloatSize& spacing, CompositeOperator op, const FloatRect& destRect, BlendMode blendMode)
 {
     if (paintingDisabled() || !patternTransform.isInvertible())
         return;
 
     if (isRecording()) {
-        m_displayListRecorder->drawPattern(image, destRect, tileRect, patternTransform, phase, spacing, op, blendMode);
+        m_displayListRecorder->drawPattern(image, tileRect, patternTransform, phase, spacing, op, destRect, blendMode);
         return;
     }
 
diff --git a/Source/WebCore/platform/graphics/cg/GraphicsContextCG.h b/Source/WebCore/platform/graphics/cg/GraphicsContextCG.h
index e6d31afc288..e6f15260843 100644
--- a/Source/WebCore/platform/graphics/cg/GraphicsContextCG.h
+++ b/Source/WebCore/platform/graphics/cg/GraphicsContextCG.h
@@ -34,7 +34,6 @@ namespace WebCore {
 
 CGColorSpaceRef deviceRGBColorSpaceRef();
 WEBCORE_EXPORT CGColorSpaceRef sRGBColorSpaceRef();
-WEBCORE_EXPORT CGColorSpaceRef extendedSRGBColorSpaceRef();
 WEBCORE_EXPORT CGColorSpaceRef displayP3ColorSpaceRef();
 CGColorSpaceRef linearRGBColorSpaceRef();
 
diff --git a/Source/WebCore/platform/graphics/cg/IOSurfacePool.cpp b/Source/WebCore/platform/graphics/cg/IOSurfacePool.cpp
index b81d58e63d1..133adabc698 100644
--- a/Source/WebCore/platform/graphics/cg/IOSurfacePool.cpp
+++ b/Source/WebCore/platform/graphics/cg/IOSurfacePool.cpp
@@ -64,7 +64,7 @@ IOSurfacePool& IOSurfacePool::sharedPool()
     return pool;
 }
 
-static bool surfaceMatchesParameters(IOSurface& surface, IntSize requestedSize, CGColorSpaceRef colorSpace, IOSurface::Format format)
+static bool surfaceMatchesParameters(IOSurface& surface, IntSize requestedSize, ColorSpace colorSpace, IOSurface::Format format)
 {
     if (format != surface.format())
         return false;
@@ -107,7 +107,7 @@ void IOSurfacePool::didUseSurfaceOfSize(IntSize size)
     m_sizesInPruneOrder.append(size);
 }
 
-std::unique_ptr<IOSurface> IOSurfacePool::takeSurface(IntSize size, CGColorSpaceRef colorSpace, IOSurface::Format format)
+std::unique_ptr<IOSurface> IOSurfacePool::takeSurface(IntSize size, ColorSpace colorSpace, IOSurface::Format format)
 {
     CachedSurfaceMap::iterator mapIter = m_cachedSurfaces.find(size);
 
diff --git a/Source/WebCore/platform/graphics/cg/IOSurfacePool.h b/Source/WebCore/platform/graphics/cg/IOSurfacePool.h
index 349a3bc3d27..45ceccc518d 100644
--- a/Source/WebCore/platform/graphics/cg/IOSurfacePool.h
+++ b/Source/WebCore/platform/graphics/cg/IOSurfacePool.h
@@ -28,6 +28,7 @@
 
 #if USE(IOSURFACE)
 
+#include "ColorSpace.h"
 #include "IOSurface.h"
 #include "IntSize.h"
 #include "IntSizeHash.h"
@@ -46,7 +47,7 @@ class IOSurfacePool {
 public:
     WEBCORE_EXPORT static IOSurfacePool& sharedPool();
 
-    std::unique_ptr<IOSurface> takeSurface(IntSize, CGColorSpaceRef, IOSurface::Format);
+    std::unique_ptr<IOSurface> takeSurface(IntSize, ColorSpace, IOSurface::Format);
     WEBCORE_EXPORT void addSurface(std::unique_ptr<IOSurface>);
 
     void discardAllSurfaces();
diff --git a/Source/WebCore/platform/graphics/cg/ImageBufferCG.cpp b/Source/WebCore/platform/graphics/cg/ImageBufferCG.cpp
index 4587562404f..2aab70a1e2f 100644
--- a/Source/WebCore/platform/graphics/cg/ImageBufferCG.cpp
+++ b/Source/WebCore/platform/graphics/cg/ImageBufferCG.cpp
@@ -363,7 +363,7 @@ void ImageBuffer::draw(GraphicsContext& destContext, const FloatRect& destRect,
     destContext.drawNativeImage(image.get(), m_data.backingStoreSize, destRect, adjustedSrcRect, op, blendMode);
 }
 
-void ImageBuffer::drawPattern(GraphicsContext& destContext, const FloatRect& destRect, const FloatRect& srcRect, const AffineTransform& patternTransform, const FloatPoint& phase, const FloatSize& spacing, CompositeOperator op, BlendMode blendMode)
+void ImageBuffer::drawPattern(GraphicsContext& destContext, const FloatRect& srcRect, const AffineTransform& patternTransform, const FloatPoint& phase, const FloatSize& spacing, CompositeOperator op, const FloatRect& destRect, BlendMode blendMode)
 {
     FloatRect adjustedSrcRect = srcRect;
     adjustedSrcRect.scale(m_resolutionScale);
@@ -371,14 +371,14 @@ void ImageBuffer::drawPattern(GraphicsContext& destContext, const FloatRect& des
     if (!context().isAcceleratedContext()) {
         if (&destContext == &context() || destContext.isAcceleratedContext()) {
             if (RefPtr<Image> copy = copyImage(CopyBackingStore)) // Drawing into our own buffer, need to deep copy.
-                copy->drawPattern(destContext, destRect, adjustedSrcRect, patternTransform, phase, spacing, op, blendMode);
+                copy->drawPattern(destContext, adjustedSrcRect, patternTransform, phase, spacing, op, destRect, blendMode);
         } else {
             if (RefPtr<Image> imageForRendering = copyImage(DontCopyBackingStore))
-                imageForRendering->drawPattern(destContext, destRect, adjustedSrcRect, patternTransform, phase, spacing, op, blendMode);
+                imageForRendering->drawPattern(destContext, adjustedSrcRect, patternTransform, phase, spacing, op, destRect, blendMode);
         }
     } else {
         if (RefPtr<Image> copy = copyImage(CopyBackingStore))
-            copy->drawPattern(destContext, destRect, adjustedSrcRect, patternTransform, phase, spacing, op, blendMode);
+            copy->drawPattern(destContext, adjustedSrcRect, patternTransform, phase, spacing, op, destRect, blendMode);
     }
 }
 
diff --git a/Source/WebCore/platform/graphics/cg/ImageCG.cpp b/Source/WebCore/platform/graphics/cg/ImageCG.cpp
index e5b3deaac00..f34c0f5ef91 100644
--- a/Source/WebCore/platform/graphics/cg/ImageCG.cpp
+++ b/Source/WebCore/platform/graphics/cg/ImageCG.cpp
@@ -28,19 +28,29 @@
 
 #if USE(CG)
 
+#include "FloatConversion.h"
 #include "FloatRect.h"
 #include "GraphicsContextCG.h"
 #include "ImageObserver.h"
+#include <CoreGraphics/CoreGraphics.h>
+
+#if PLATFORM(COCOA)
+#include "WebCoreSystemInterface.h"
+#endif
+
+#if PLATFORM(WIN)
+#include <WebKitSystemInterface/WebKitSystemInterface.h>
+#endif
 
 namespace WebCore {
 
-void Image::drawPattern(GraphicsContext& ctxt, const FloatRect& destRect, const FloatRect& tileRect, const AffineTransform& patternTransform,
-    const FloatPoint& phase, const FloatSize& spacing, CompositeOperator op, BlendMode blendMode)
+void Image::drawPattern(GraphicsContext& ctxt, const FloatRect& tileRect, const AffineTransform& patternTransform,
+    const FloatPoint& phase, const FloatSize& spacing, CompositeOperator op, const FloatRect& destRect, BlendMode blendMode)
 {
     if (!nativeImageForCurrentFrame())
         return;
 
-    ctxt.drawPattern(*this, destRect, tileRect, patternTransform, phase, spacing, op, blendMode);
+    ctxt.drawPattern(*this, tileRect, patternTransform, phase, spacing, op, destRect, blendMode);
 
     if (imageObserver())
         imageObserver()->didDraw(this);
diff --git a/Source/WebCore/platform/graphics/cg/ImageDecoderCG.cpp b/Source/WebCore/platform/graphics/cg/ImageDecoderCG.cpp
index b29031ebb70..4fefb9b374e 100644
--- a/Source/WebCore/platform/graphics/cg/ImageDecoderCG.cpp
+++ b/Source/WebCore/platform/graphics/cg/ImageDecoderCG.cpp
@@ -126,11 +126,20 @@ void sharedBufferRelease(void* info)
 }
 #endif
 
-ImageDecoder::ImageDecoder(AlphaOption, GammaAndColorProfileOption)
+ImageDecoder::ImageDecoder()
 {
     m_nativeDecoder = adoptCF(CGImageSourceCreateIncremental(nullptr));
 }
 
+SubsamplingLevel ImageDecoder::subsamplingLevelForScale(float scale, SubsamplingLevel maximumSubsamplingLevel)
+{
+    // There are four subsampling levels: 0 = 1x, 1 = 0.5x, 2 = 0.25x, 3 = 0.125x.
+    float clampedScale = std::max<float>(0.125, std::min<float>(1, scale));
+    SubsamplingLevel result = ceilf(log2f(1 / clampedScale));
+    ASSERT(result >=0 && result <= 3);
+    return std::min(result, maximumSubsamplingLevel);
+}
+
 size_t ImageDecoder::bytesDecodedToDetermineProperties()
 {
     // Measured by tracing malloc/calloc calls on Mac OS 10.6.6, x86_64.
@@ -162,6 +171,13 @@ bool ImageDecoder::isSizeAvailable() const
     && CFDictionaryContainsKey(image0Properties.get(), kCGImagePropertyPixelHeight);
 }
 
+IntSize ImageDecoder::size() const
+{
+    if (m_size.isEmpty())
+        m_size = frameSizeAtIndex(0, 0);
+    return m_size;
+}
+
 size_t ImageDecoder::frameCount() const
 {
     return CGImageSourceGetCount(m_nativeDecoder.get());
@@ -203,25 +219,26 @@ RepetitionCount ImageDecoder::repetitionCount() const
     return RepetitionCountNone;
 }
 
-Optional<IntPoint> ImageDecoder::hotSpot() const
+bool ImageDecoder::hotSpot(IntPoint& hotSpot) const
 {
     RetainPtr<CFDictionaryRef> properties = adoptCF(CGImageSourceCopyPropertiesAtIndex(m_nativeDecoder.get(), 0, imageSourceOptions().get()));
     if (!properties)
-        return Nullopt;
+        return false;
     
     int x = -1, y = -1;
     CFNumberRef num = (CFNumberRef)CFDictionaryGetValue(properties.get(), CFSTR("hotspotX"));
     if (!num || !CFNumberGetValue(num, kCFNumberIntType, &x))
-        return Nullopt;
+        return false;
     
     num = (CFNumberRef)CFDictionaryGetValue(properties.get(), CFSTR("hotspotY"));
     if (!num || !CFNumberGetValue(num, kCFNumberIntType, &y))
-        return Nullopt;
+        return false;
     
     if (x < 0 || y < 0)
-        return Nullopt;
+        return false;
     
-    return IntPoint(x, y);
+    hotSpot = IntPoint(x, y);
+    return true;
 }
 
 IntSize ImageDecoder::frameSizeAtIndex(size_t index, SubsamplingLevel subsamplingLevel) const
@@ -381,23 +398,26 @@ NativeImagePtr ImageDecoder::createFrameImageAtIndex(size_t index, SubsamplingLe
     return maskedImage ? maskedImage : image;
 }
 
-void ImageDecoder::setData(SharedBuffer& data, bool allDataReceived)
+void ImageDecoder::setData(CFDataRef data, bool allDataReceived)
 {
-    m_isAllDataReceived = allDataReceived;
+    CGImageSourceUpdateData(m_nativeDecoder.get(), data, allDataReceived);
+}
 
+void ImageDecoder::setData(SharedBuffer* data, bool allDataReceived)
+{
 #if PLATFORM(COCOA)
     // On Mac the NSData inside the SharedBuffer can be secretly appended to without the SharedBuffer's knowledge.
     // We use SharedBuffer's ability to wrap itself inside CFData to get around this, ensuring that ImageIO is
     // really looking at the SharedBuffer.
-    CGImageSourceUpdateData(m_nativeDecoder.get(), data.createCFData().get(), allDataReceived);
+    setData(data->createCFData().get(), allDataReceived);
 #else
     // Create a CGDataProvider to wrap the SharedBuffer.
-    data.ref();
+    data->ref();
     // We use the GetBytesAtPosition callback rather than the GetBytePointer one because SharedBuffer
     // does not provide a way to lock down the byte pointer and guarantee that it won't move, which
     // is a requirement for using the GetBytePointer callback.
     CGDataProviderDirectCallbacks providerCallbacks = { 0, 0, 0, sharedBufferGetBytesAtPosition, sharedBufferRelease };
-    RetainPtr<CGDataProviderRef> dataProvider = adoptCF(CGDataProviderCreateDirect(&data, data.size(), &providerCallbacks));
+    RetainPtr<CGDataProviderRef> dataProvider = adoptCF(CGDataProviderCreateDirect(data, data->size(), &providerCallbacks));
     CGImageSourceUpdateDataProvider(m_nativeDecoder.get(), dataProvider.get(), allDataReceived);
 #endif
 }
diff --git a/Source/WebCore/platform/graphics/cg/ImageDecoderCG.h b/Source/WebCore/platform/graphics/cg/ImageDecoderCG.h
index 6bc23681aa6..748995022b1 100644
--- a/Source/WebCore/platform/graphics/cg/ImageDecoderCG.h
+++ b/Source/WebCore/platform/graphics/cg/ImageDecoderCG.h
@@ -23,54 +23,55 @@
  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-#pragma once
+#ifndef ImageDecoderCG_h
+#define ImageDecoderCG_h
 
 #include "ImageSourceCG.h"
 #include "IntSize.h"
 
-#include <wtf/Optional.h>
-
-typedef struct CGImageSource* CGImageSourceRef;
-typedef const struct __CFData* CFDataRef;
-
 namespace WebCore {
 
 class ImageDecoder {
     WTF_MAKE_FAST_ALLOCATED;
 public:
-    ImageDecoder(AlphaOption, GammaAndColorProfileOption);
-
-    static std::unique_ptr<ImageDecoder> create(const SharedBuffer&, AlphaOption alphaOption, GammaAndColorProfileOption gammaAndColorProfileOption)
+    ImageDecoder();
+    
+    static std::unique_ptr<ImageDecoder> create()
     {
-        return std::make_unique<ImageDecoder>(alphaOption, gammaAndColorProfileOption);
+        return std::make_unique<ImageDecoder>();
     }
     
     static size_t bytesDecodedToDetermineProperties();
-
+    static SubsamplingLevel subsamplingLevelForScale(float scale, SubsamplingLevel maximumSubsamplingLevel);
+    
+    String filenameExtension() const;
     bool isSizeAvailable() const;
+    
+    // Always original size, without subsampling.
+    IntSize size() const;
     size_t frameCount() const;
-    RepetitionCount repetitionCount() const;
-    String filenameExtension() const;
-    Optional<IntPoint> hotSpot() const;
-
-    IntSize frameSizeAtIndex(size_t, SubsamplingLevel = SubsamplingLevel::Default) const;
+    int repetitionCount() const;
+    bool hotSpot(IntPoint& hotSpot) const;
+    
+    IntSize frameSizeAtIndex(size_t, SubsamplingLevel) const;
     bool frameIsCompleteAtIndex(size_t) const;
-    ImageOrientation frameOrientationAtIndex(size_t) const;
+    ImageOrientation orientationAtIndex(size_t) const;
     
     float frameDurationAtIndex(size_t) const;
     bool frameHasAlphaAtIndex(size_t) const;
-    bool frameAllowSubsamplingAtIndex(size_t) const;
-    unsigned frameBytesAtIndex(size_t, SubsamplingLevel = SubsamplingLevel::Default) const;
+    bool allowSubsamplingOfFrameAtIndex(size_t) const;
+    unsigned frameBytesAtIndex(size_t, SubsamplingLevel = 0) const;
     
-    NativeImagePtr createFrameImageAtIndex(size_t, SubsamplingLevel = SubsamplingLevel::Default, DecodingMode = DecodingMode::OnDemand) const;
+    NativeImagePtr createFrameImageAtIndex(size_t, SubsamplingLevel) const;
     
-    void setData(SharedBuffer&, bool allDataReceived);
-    bool isAllDataReceived() const { return m_isAllDataReceived; }
-    void clearFrameBufferCache(size_t) { }
+    void setData(CFDataRef, bool allDataReceived);
+    void setData(SharedBuffer*, bool allDataReceived);
     
 protected:
-    bool m_isAllDataReceived { false };
+    mutable IntSize m_size;
     RetainPtr<CGImageSourceRef> m_nativeDecoder;
 };
 
 }
+
+#endif // ImageDecoderCG_h
diff --git a/Source/WebCore/platform/graphics/cg/ImageSourceCG.cpp b/Source/WebCore/platform/graphics/cg/ImageSourceCG.cpp
new file mode 100644
index 00000000000..49d4e15c9ff
--- /dev/null
+++ b/Source/WebCore/platform/graphics/cg/ImageSourceCG.cpp
@@ -0,0 +1,215 @@
+/*
+ * Copyright (C) 2004, 2005, 2006, 2008, 2016 Apple Inc. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
+ * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
+ */
+
+#include "config.h"
+#include "ImageSource.h"
+
+#if USE(CG)
+#include "ImageSourceCG.h"
+
+#include "ImageDecoderCG.h"
+#include "ImageOrientation.h"
+#include "SharedBuffer.h"
+
+namespace WebCore {
+
+ImageSource::ImageSource(ImageSource::AlphaOption, ImageSource::GammaAndColorProfileOption)
+{
+    // FIXME: AlphaOption and GammaAndColorProfileOption are ignored.
+}
+
+ImageSource::~ImageSource()
+{
+    clear(true);
+}
+
+void ImageSource::clear(bool destroyAllFrames, size_t, SharedBuffer* data, bool allDataReceived)
+{
+    // Recent versions of ImageIO discard previously decoded image frames if the client
+    // application no longer holds references to them, so there's no need to throw away
+    // the decoder unless we're explicitly asked to destroy all of the frames.
+    if (!destroyAllFrames)
+        return;
+
+    m_decoder = nullptr;
+    
+    if (data)
+        setData(data, allDataReceived);
+}
+    
+void ImageSource::ensureDecoderIsCreated(SharedBuffer*)
+{
+    if (initialized())
+        return;
+    m_decoder = ImageDecoder::create();
+}
+
+void ImageSource::setData(SharedBuffer* data, bool allDataReceived)
+{
+    if (!data)
+        return;
+    
+    ensureDecoderIsCreated(data);
+    
+    if (!initialized()) {
+        ASSERT_NOT_REACHED();
+        return;
+    }
+    
+    m_decoder->setData(data, allDataReceived);
+}
+
+String ImageSource::filenameExtension() const
+{
+    return initialized() ? m_decoder->filenameExtension() : String();
+}
+    
+SubsamplingLevel ImageSource::calculateMaximumSubsamplingLevel() const
+{
+    if (!m_allowSubsampling || !allowSubsamplingOfFrameAtIndex(0))
+        return 0;
+
+    // Values chosen to be appropriate for iOS.
+    const int cMaximumImageAreaBeforeSubsampling = 5 * 1024 * 1024;
+    const SubsamplingLevel maxSubsamplingLevel = 3;
+
+    SubsamplingLevel currentLevel = 0;
+    for ( ; currentLevel <= maxSubsamplingLevel; ++currentLevel) {
+        IntSize frameSize = frameSizeAtIndex(0, currentLevel);
+        if (frameSize.area() < cMaximumImageAreaBeforeSubsampling)
+            break;
+    }
+
+    return currentLevel;
+}
+    
+SubsamplingLevel ImageSource::maximumSubsamplingLevel() const
+{
+#if PLATFORM(IOS)
+    return calculateMaximumSubsamplingLevel();
+#endif
+    return 0;
+}
+
+SubsamplingLevel ImageSource::subsamplingLevelForScale(float scale) const
+{
+    return ImageDecoder::subsamplingLevelForScale(scale, maximumSubsamplingLevel());
+}
+
+bool ImageSource::isSizeAvailable()
+{
+    return initialized() && m_decoder->isSizeAvailable();
+}
+
+bool ImageSource::allowSubsamplingOfFrameAtIndex(size_t index) const
+{
+    return initialized() && m_decoder->allowSubsamplingOfFrameAtIndex(index);
+}
+
+IntSize ImageSource::frameSizeAtIndex(size_t index, SubsamplingLevel subsamplingLevel, RespectImageOrientationEnum shouldRespectImageOrientation) const
+{
+    if (!initialized())
+        return { };
+    
+    IntSize size = m_decoder->frameSizeAtIndex(index, subsamplingLevel);
+    ImageOrientation orientation = m_decoder->orientationAtIndex(index);
+    
+    return shouldRespectImageOrientation == RespectImageOrientation && orientation.usesWidthAsHeight() ? size.transposedSize() : size;
+}
+
+ImageOrientation ImageSource::orientationAtIndex(size_t index) const
+{
+    return initialized() ? m_decoder->orientationAtIndex(index) : ImageOrientation();
+}
+
+IntSize ImageSource::size() const
+{
+    return frameSizeAtIndex(0, 0);
+}
+    
+IntSize ImageSource::sizeRespectingOrientation() const
+{
+    return frameSizeAtIndex(0, 0, RespectImageOrientation);
+}
+
+bool ImageSource::getHotSpot(IntPoint& hotSpot) const
+{
+    return initialized() && m_decoder->hotSpot(hotSpot);
+}
+
+size_t ImageSource::bytesDecodedToDetermineProperties() const
+{
+    return ImageDecoder::bytesDecodedToDetermineProperties();
+}
+    
+int ImageSource::repetitionCount()
+{
+    return initialized() ? m_decoder->repetitionCount() : cAnimationLoopOnce;
+}
+
+size_t ImageSource::frameCount() const
+{
+    return initialized() ? m_decoder->frameCount() : 0;
+}
+
+RetainPtr<CGImageRef> ImageSource::createFrameImageAtIndex(size_t index, SubsamplingLevel subsamplingLevel)
+{
+    return initialized() ? m_decoder->createFrameImageAtIndex(index, subsamplingLevel) : nullptr;
+}
+
+bool ImageSource::frameIsCompleteAtIndex(size_t index)
+{
+    return initialized() && m_decoder->frameIsCompleteAtIndex(index);
+}
+
+float ImageSource::frameDurationAtIndex(size_t index)
+{
+    return initialized() ? m_decoder->frameDurationAtIndex(index) : 0;
+}
+
+bool ImageSource::frameHasAlphaAtIndex(size_t index)
+{
+    return !initialized() || m_decoder->frameHasAlphaAtIndex(index);
+}
+
+unsigned ImageSource::frameBytesAtIndex(size_t index, SubsamplingLevel subsamplingLevel) const
+{
+    IntSize frameSize = frameSizeAtIndex(index, subsamplingLevel);
+    return frameSize.area() * 4;
+}
+    
+void ImageSource::dump(TextStream& ts) const
+{
+    if (m_allowSubsampling)
+        ts.dumpProperty("allow-subsampling", m_allowSubsampling);
+    
+    ImageOrientation orientation = orientationAtIndex(0);
+    if (orientation != OriginTopLeft)
+        ts.dumpProperty("orientation", orientation);
+}
+
+}
+
+#endif // USE(CG)
diff --git a/Source/WebCore/platform/graphics/cg/NativeImageCG.cpp b/Source/WebCore/platform/graphics/cg/NativeImageCG.cpp
deleted file mode 100644
index 23e8fe44a43..00000000000
--- a/Source/WebCore/platform/graphics/cg/NativeImageCG.cpp
+++ /dev/null
@@ -1,109 +0,0 @@
-/*
- * Copyright (C) 2016 Apple Inc. All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS'' AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
- * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#include "config.h"
-#include "NativeImage.h"
-
-#if USE(CG)
-
-#include "Color.h"
-#include "CoreGraphicsSPI.h"
-#include "FloatRect.h"
-#include "GeometryUtilities.h"
-#include "GraphicsContextCG.h"
-#include "IntSize.h"
-#include "SubimageCacheWithTimer.h"
-
-#if PLATFORM(WIN)
-#include <WebKitSystemInterface/WebKitSystemInterface.h>
-#endif
-
-namespace WebCore {
-
-IntSize nativeImageSize(const NativeImagePtr& image)
-{
-    return image ? IntSize(CGImageGetWidth(image.get()), CGImageGetHeight(image.get())) : IntSize();
-}
-
-bool nativeImageHasAlpha(const NativeImagePtr& image)
-{
-    CGImageAlphaInfo info = CGImageGetAlphaInfo(image.get());
-    return (info >= kCGImageAlphaPremultipliedLast) && (info <= kCGImageAlphaFirst);
-}
-
-Color nativeImageSinglePixelSolidColor(const NativeImagePtr& image)
-{
-    if (!image || nativeImageSize(image) != IntSize(1, 1))
-        return Color();
-
-    unsigned char pixel[4]; // RGBA
-    auto bitmapContext = adoptCF(CGBitmapContextCreate(pixel, 1, 1, 8, sizeof(pixel), sRGBColorSpaceRef(), kCGImageAlphaPremultipliedLast | kCGBitmapByteOrder32Big));
-
-    if (!bitmapContext)
-        return Color();
-
-    CGContextSetBlendMode(bitmapContext.get(), kCGBlendModeCopy);
-    CGContextDrawImage(bitmapContext.get(), CGRectMake(0, 0, 1, 1), image.get());
-
-    if (!pixel[3])
-        return Color(0, 0, 0, 0);
-
-    return Color(pixel[0] * 255 / pixel[3], pixel[1] * 255 / pixel[3], pixel[2] * 255 / pixel[3], pixel[3]);
-}
-
-float subsamplingScale(GraphicsContext& context, const FloatRect& destRect, const FloatRect& srcRect)
-{
-    // Never use subsampled images for drawing into PDF contexts.
-    if (wkCGContextIsPDFContext(context.platformContext()))
-        return 1;
-
-    CGRect transformedDestinationRect = CGRectApplyAffineTransform(destRect, CGContextGetCTM(context.platformContext()));
-    return std::min<float>(1, std::max(transformedDestinationRect.size.width / srcRect.width(), transformedDestinationRect.size.height / srcRect.height()));
-}
-
-void drawNativeImage(const NativeImagePtr& image, GraphicsContext& context, const FloatRect& destRect, const FloatRect& srcRect, const IntSize& srcSize, CompositeOperator op, BlendMode mode, const ImageOrientation& orientation)
-{
-    // Subsampling may have given us an image that is smaller than size().
-    IntSize subsampledImageSize = nativeImageSize(image);
-
-    // srcRect is in the coordinates of the unsubsampled image, so we have to map it to the subsampled image.
-    FloatRect adjustedSrcRect = srcRect;
-    if (subsampledImageSize != srcSize)
-        adjustedSrcRect = mapRect(srcRect, FloatRect({ }, srcSize), FloatRect({ }, subsampledImageSize));
-
-    context.drawNativeImage(image, subsampledImageSize, destRect, adjustedSrcRect, op, mode, orientation);
-}
-
-void clearNativeImageSubimages(const NativeImagePtr& image)
-{
-#if CACHE_SUBIMAGES
-    if (image)
-        subimageCache().clearImage(image.get());
-#endif
-}
-
-}
-
-#endif // USE(CG)
diff --git a/Source/WebCore/platform/graphics/cg/PDFDocumentImage.cpp b/Source/WebCore/platform/graphics/cg/PDFDocumentImage.cpp
index 140687433b1..16cfa67a13e 100644
--- a/Source/WebCore/platform/graphics/cg/PDFDocumentImage.cpp
+++ b/Source/WebCore/platform/graphics/cg/PDFDocumentImage.cpp
@@ -183,7 +183,7 @@ void PDFDocumentImage::decodedSizeChanged(size_t newCachedBytes)
         return;
 
     if (imageObserver())
-        imageObserver()->decodedSizeChanged(this, -static_cast<long long>(m_cachedBytes) + newCachedBytes);
+        imageObserver()->decodedSizeChanged(this, -safeCast<int>(m_cachedBytes) + newCachedBytes);
 
     ASSERT(s_allDecodedDataSize >= m_cachedBytes);
     // Update with the difference in two steps to avoid unsigned underflow subtraction.
diff --git a/Source/WebCore/platform/graphics/cg/PDFDocumentImage.h b/Source/WebCore/platform/graphics/cg/PDFDocumentImage.h
index fb9fb0a53fa..71f993f0609 100644
--- a/Source/WebCore/platform/graphics/cg/PDFDocumentImage.h
+++ b/Source/WebCore/platform/graphics/cg/PDFDocumentImage.h
@@ -75,7 +75,7 @@ private:
     void draw(GraphicsContext&, const FloatRect& dstRect, const FloatRect& srcRect, CompositeOperator, BlendMode, ImageOrientationDescription) override;
 
     // FIXME: Implement this to be less conservative.
-    bool currentFrameKnownToBeOpaque() const override { return false; }
+    bool currentFrameKnownToBeOpaque() override { return false; }
 
     void dump(TextStream&) const override;
 
diff --git a/Source/WebCore/platform/graphics/cg/PatternCG.cpp b/Source/WebCore/platform/graphics/cg/PatternCG.cpp
index 718600920a9..5f9ba5b7b88 100644
--- a/Source/WebCore/platform/graphics/cg/PatternCG.cpp
+++ b/Source/WebCore/platform/graphics/cg/PatternCG.cpp
@@ -74,7 +74,7 @@ CGPatternRef Pattern::createPlatformPattern(const AffineTransform& userSpaceTran
     // If we're repeating in both directions, we can use image-backed patterns
     // instead of custom patterns, and avoid tiling-edge pixel cracks.
     if (m_repeatX && m_repeatY)
-        return wkCGPatternCreateWithImageAndTransform(tileImage()->nativeImage().get(), patternTransform, wkPatternTilingConstantSpacing);
+        return wkCGPatternCreateWithImageAndTransform(tileImage()->getCGImageRef(), patternTransform, wkPatternTilingConstantSpacing);
 
     // If FLT_MAX should also be used for xStep or yStep, nothing is rendered. Using fractions of FLT_MAX also
     // result in nothing being rendered.
@@ -85,7 +85,7 @@ CGPatternRef Pattern::createPlatformPattern(const AffineTransform& userSpaceTran
     CGFloat yStep = m_repeatY ? tileRect.height() : (1 << 22);
 
     // The pattern will release the CGImageRef when it's done rendering in patternReleaseCallback
-    CGImageRef platformImage = tileImage()->nativeImage().leakRef();
+    CGImageRef platformImage = CGImageRetain(tileImage()->getCGImageRef());
 
     const CGPatternCallbacks patternCallbacks = { 0, patternCallback, patternReleaseCallback };
     return CGPatternCreate(platformImage, tileRect, patternTransform, xStep, yStep, kCGPatternTilingConstantSpacing, TRUE, &patternCallbacks);
diff --git a/Source/WebCore/platform/graphics/cocoa/TextTrackRepresentationCocoa.mm b/Source/WebCore/platform/graphics/cocoa/TextTrackRepresentationCocoa.mm
index 4476fc5f87c..89720d17365 100644
--- a/Source/WebCore/platform/graphics/cocoa/TextTrackRepresentationCocoa.mm
+++ b/Source/WebCore/platform/graphics/cocoa/TextTrackRepresentationCocoa.mm
@@ -129,7 +129,7 @@ TextTrackRepresentationCocoa::~TextTrackRepresentationCocoa()
 void TextTrackRepresentationCocoa::update()
 {
     if (auto representation = m_client.createTextTrackRepresentationImage())
-        [m_layer.get() setContents:(id)representation->nativeImage().get()];
+        [m_layer.get() setContents:(id)representation->getCGImageRef()];
 }
 
 void TextTrackRepresentationCocoa::setContentScale(float scale)
diff --git a/Source/WebCore/platform/graphics/displaylists/DisplayListItems.cpp b/Source/WebCore/platform/graphics/displaylists/DisplayListItems.cpp
index 4af18265e48..4927eabf8ed 100644
--- a/Source/WebCore/platform/graphics/displaylists/DisplayListItems.cpp
+++ b/Source/WebCore/platform/graphics/displaylists/DisplayListItems.cpp
@@ -532,7 +532,7 @@ static TextStream& operator<<(TextStream& ts, const DrawNativeImage& item)
 }
 #endif
 
-DrawPattern::DrawPattern(Image& image, const FloatRect& destRect, const FloatRect& tileRect, const AffineTransform& patternTransform, const FloatPoint& phase, const FloatSize& spacing, CompositeOperator op, BlendMode blendMode)
+DrawPattern::DrawPattern(Image& image, const FloatRect& tileRect, const AffineTransform& patternTransform, const FloatPoint& phase, const FloatSize& spacing, CompositeOperator op, const FloatRect& destRect, BlendMode blendMode)
     : DrawingItem(ItemType::DrawPattern)
     , m_image(image)
     , m_patternTransform(patternTransform)
@@ -547,7 +547,7 @@ DrawPattern::DrawPattern(Image& image, const FloatRect& destRect, const FloatRec
 
 void DrawPattern::apply(GraphicsContext& context) const
 {
-    context.drawPattern(m_image.get(), m_destination, m_tileRect, m_patternTransform, m_phase, m_spacing, m_op, m_blendMode);
+    context.drawPattern(m_image.get(), m_tileRect, m_patternTransform, m_phase, m_spacing, m_op, m_destination, m_blendMode);
 }
 
 static TextStream& operator<<(TextStream& ts, const DrawPattern& item)
diff --git a/Source/WebCore/platform/graphics/displaylists/DisplayListItems.h b/Source/WebCore/platform/graphics/displaylists/DisplayListItems.h
index a71e3149b88..cf57399cc5d 100644
--- a/Source/WebCore/platform/graphics/displaylists/DisplayListItems.h
+++ b/Source/WebCore/platform/graphics/displaylists/DisplayListItems.h
@@ -670,9 +670,9 @@ private:
 
 class DrawPattern : public DrawingItem {
 public:
-    static Ref<DrawPattern> create(Image& image, const FloatRect& destRect, const FloatRect& tileRect, const AffineTransform& patternTransform, const FloatPoint& phase, const FloatSize& spacing, CompositeOperator op, BlendMode blendMode)
+    static Ref<DrawPattern> create(Image& image, const FloatRect& tileRect, const AffineTransform& patternTransform, const FloatPoint& phase, const FloatSize& spacing, CompositeOperator op, const FloatRect& destRect, BlendMode blendMode)
     {
-        return adoptRef(*new DrawPattern(image, destRect, tileRect, patternTransform, phase, spacing, op, blendMode));
+        return adoptRef(*new DrawPattern(image, tileRect, patternTransform, phase, spacing, op, destRect, blendMode));
     }
 
     const Image& image() const { return m_image.get(); }
@@ -683,7 +683,7 @@ public:
     FloatSize spacing() const { return m_spacing; }
 
 private:
-    DrawPattern(Image&, const FloatRect& destRect, const FloatRect& srcRect, const AffineTransform&, const FloatPoint& phase, const FloatSize& spacing, CompositeOperator, BlendMode = BlendModeNormal);
+    DrawPattern(Image&, const FloatRect& srcRect, const AffineTransform&, const FloatPoint& phase, const FloatSize& spacing, CompositeOperator, const FloatRect& destRect, BlendMode = BlendModeNormal);
 
     void apply(GraphicsContext&) const override;
 
diff --git a/Source/WebCore/platform/graphics/displaylists/DisplayListRecorder.cpp b/Source/WebCore/platform/graphics/displaylists/DisplayListRecorder.cpp
index c9c3c4d49d1..a2242988c06 100644
--- a/Source/WebCore/platform/graphics/displaylists/DisplayListRecorder.cpp
+++ b/Source/WebCore/platform/graphics/displaylists/DisplayListRecorder.cpp
@@ -132,9 +132,9 @@ void Recorder::drawTiledImage(Image& image, const FloatRect& destination, const
     updateItemExtent(newItem);
 }
 
-void Recorder::drawPattern(Image& image, const FloatRect& destRect, const FloatRect& tileRect, const AffineTransform& patternTransform, const FloatPoint& phase, const FloatSize& spacing, CompositeOperator op, BlendMode blendMode)
+void Recorder::drawPattern(Image& image, const FloatRect& tileRect, const AffineTransform& patternTransform, const FloatPoint& phase, const FloatSize& spacing, CompositeOperator op, const FloatRect& destRect, BlendMode blendMode)
 {
-    DrawingItem& newItem = downcast<DrawingItem>(appendItem(DrawPattern::create(image, destRect, tileRect, patternTransform, phase, spacing, op, blendMode)));
+    DrawingItem& newItem = downcast<DrawingItem>(appendItem(DrawPattern::create(image, tileRect, patternTransform, phase, spacing, op, destRect, blendMode)));
     updateItemExtent(newItem);
 }
 
diff --git a/Source/WebCore/platform/graphics/displaylists/DisplayListRecorder.h b/Source/WebCore/platform/graphics/displaylists/DisplayListRecorder.h
index 95c626fd607..52ea106eda8 100644
--- a/Source/WebCore/platform/graphics/displaylists/DisplayListRecorder.h
+++ b/Source/WebCore/platform/graphics/displaylists/DisplayListRecorder.h
@@ -88,7 +88,7 @@ public:
 #if USE(CG) || USE(CAIRO)
     void drawNativeImage(const NativeImagePtr&, const FloatSize& selfSize, const FloatRect& destRect, const FloatRect& srcRect, CompositeOperator, BlendMode, ImageOrientation);
 #endif
-    void drawPattern(Image&, const FloatRect& destRect, const FloatRect& srcRect, const AffineTransform&, const FloatPoint& phase, const FloatSize& spacing, CompositeOperator, BlendMode = BlendModeNormal);
+    void drawPattern(Image&, const FloatRect& srcRect, const AffineTransform&, const FloatPoint& phase, const FloatSize& spacing, CompositeOperator, const FloatRect& destRect, BlendMode = BlendModeNormal);
 
     void drawRect(const FloatRect&, float borderThickness);
     void drawLine(const FloatPoint&, const FloatPoint&);
diff --git a/Source/WebCore/platform/graphics/efl/GraphicsContext3DEfl.cpp b/Source/WebCore/platform/graphics/efl/GraphicsContext3DEfl.cpp
index 046a053e4a2..d3f86146040 100644
--- a/Source/WebCore/platform/graphics/efl/GraphicsContext3DEfl.cpp
+++ b/Source/WebCore/platform/graphics/efl/GraphicsContext3DEfl.cpp
@@ -249,9 +249,7 @@ bool GraphicsContext3D::ImageExtractor::extractImage(bool premultiplyAlpha, bool
         return false;
 
     // We need this to stay in scope because the native image is just a shallow copy of the data.
-    AlphaOption alphaOption = premultiplyAlpha ? AlphaOption::Premultiplied : AlphaOption::NotPremultiplied;
-    GammaAndColorProfileOption gammaAndColorProfileOption = ignoreGammaAndColorProfile ? GammaAndColorProfileOption::Ignored : GammaAndColorProfileOption::Applied;
-    m_decoder = new ImageSource(nullptr, alphaOption, gammaAndColorProfileOption);
+    m_decoder = new ImageSource(premultiplyAlpha ? ImageSource::AlphaPremultiplied : ImageSource::AlphaNotPremultiplied, ignoreGammaAndColorProfile ? ImageSource::GammaAndColorProfileIgnored : ImageSource::GammaAndColorProfileApplied);
 
     if (!m_decoder)
         return false;
diff --git a/Source/WebCore/platform/graphics/gstreamer/MediaPlayerPrivateGStreamer.cpp b/Source/WebCore/platform/graphics/gstreamer/MediaPlayerPrivateGStreamer.cpp
index 76948c436c4..826b3701ee8 100644
--- a/Source/WebCore/platform/graphics/gstreamer/MediaPlayerPrivateGStreamer.cpp
+++ b/Source/WebCore/platform/graphics/gstreamer/MediaPlayerPrivateGStreamer.cpp
@@ -584,7 +584,7 @@ void MediaPlayerPrivateGStreamer::seek(const MediaTime& mediaTime)
         return;
 
     GstClockTime clockTime = toGstClockTime(time);
-    GST_INFO("[Seek] seeking to %" GST_TIME_FORMAT " (%f)", GST_TIME_ARGS(clockTime), time);
+//    GST_INFO("[Seek] seeking to %" GST_TIME_FORMAT " (%f)", GST_TIME_ARGS(clockTime), time);
 
     if (m_seeking) {
         m_timeOfOverlappingSeek = time;
diff --git a/Source/WebCore/platform/graphics/mac/ImageMac.mm b/Source/WebCore/platform/graphics/mac/ImageMac.mm
index 2dba80a47c1..1c87741ce17 100644
--- a/Source/WebCore/platform/graphics/mac/ImageMac.mm
+++ b/Source/WebCore/platform/graphics/mac/ImageMac.mm
@@ -47,7 +47,7 @@ namespace WebCore {
 
 void BitmapImage::invalidatePlatformData()
 {
-    if (frameCount() != 1)
+    if (m_frames.size() != 1)
         return;
 
 #if USE(APPKIT)
@@ -74,68 +74,56 @@ PassRefPtr<Image> Image::loadPlatformResource(const char *name)
     return Image::nullImage();
 }
 
-RetainPtr<CFDataRef> BitmapImage::tiffRepresentation(const Vector<NativeImagePtr>& nativeImages)
+CFDataRef BitmapImage::getTIFFRepresentation()
 {
-    // If nativeImages.size() is zero, we know for certain this image doesn't have valid data
+    if (m_tiffRep)
+        return m_tiffRep.get();
+
+    unsigned numFrames = frameCount();
+
+    // If numFrames is zero, we know for certain this image doesn't have valid data
     // Even though the call to CGImageDestinationCreateWithData will fail and we'll handle it gracefully,
     // in certain circumstances that call will spam the console with an error message
-    if (!nativeImages.size())
-        return nullptr;
+    if (!numFrames)
+        return 0;
+
+    Vector<CGImageRef> images;
+    for (unsigned i = 0; i < numFrames; ++i ) {
+        CGImageRef cgImage = frameImageAtIndex(i).get();
+        if (cgImage)
+            images.append(cgImage);
+    }
+
+    unsigned numValidFrames = images.size();
 
     RetainPtr<CFMutableDataRef> data = adoptCF(CFDataCreateMutable(0, 0));
-    RetainPtr<CGImageDestinationRef> destination = adoptCF(CGImageDestinationCreateWithData(data.get(), kUTTypeTIFF, nativeImages.size(), 0));
+    RetainPtr<CGImageDestinationRef> destination = adoptCF(CGImageDestinationCreateWithData(data.get(), kUTTypeTIFF, numValidFrames, 0));
 
     if (!destination)
-        return nullptr;
+        return 0;
 
-    for (auto nativeImage : nativeImages)
-        CGImageDestinationAddImage(destination.get(), nativeImage.get(), 0);
+    for (unsigned i = 0; i < numValidFrames; ++i)
+        CGImageDestinationAddImage(destination.get(), images[i], 0);
 
     CGImageDestinationFinalize(destination.get());
-    return data;
-}
-
-CFDataRef BitmapImage::tiffRepresentation()
-{
-    if (m_tiffRep)
-        return m_tiffRep.get();
-
-    auto data = tiffRepresentation(framesNativeImages());
-    if (!data)
-        return nullptr;
 
     m_tiffRep = data;
     return m_tiffRep.get();
-
-    
 }
 
 #if USE(APPKIT)
-NSImage* BitmapImage::nsImage()
+NSImage* BitmapImage::getNSImage()
 {
     if (m_nsImage)
         return m_nsImage.get();
 
-    CFDataRef data = tiffRepresentation();
+    CFDataRef data = getTIFFRepresentation();
     if (!data)
-        return nullptr;
+        return 0;
     
     m_nsImage = adoptNS([[NSImage alloc] initWithData:(NSData*)data]);
     return m_nsImage.get();
 }
-
-RetainPtr<NSImage> BitmapImage::snapshotNSImage()
-{
-    auto nativeImage = this->nativeImageForCurrentFrame();
-    if (!nativeImage)
-        return nullptr;
-
-    auto data = tiffRepresentation({ nativeImage });
-    if (!data)
-        return nullptr;
-
-    return adoptNS([[NSImage alloc] initWithData:(NSData*)data.get()]);
-}
 #endif
 
 }
diff --git a/Source/WebCore/platform/graphics/win/ColorDirect2D.cpp b/Source/WebCore/platform/graphics/win/ColorDirect2D.cpp
index deaddd6f8f8..724a105e24f 100644
--- a/Source/WebCore/platform/graphics/win/ColorDirect2D.cpp
+++ b/Source/WebCore/platform/graphics/win/ColorDirect2D.cpp
@@ -29,7 +29,6 @@
 #if PLATFORM(WIN)
 
 #include <d2d1.h>
-#include <d2d1_1helper.h>
 
 namespace WebCore {
 
@@ -45,13 +44,6 @@ Color::operator D2D1_COLOR_F() const
     return D2D1::ColorF(rgb(), colorAlpha);
 }
 
-Color::operator D2D1_VECTOR_4F() const
-{
-    float r, g, b, a;
-    getRGBA(r, g, b, a);
-    return D2D1::Vector4F(r, g, b, a);
-}
-
 }
 
 #endif // PLATFORM(WIN)
diff --git a/Source/WebCore/platform/graphics/win/GradientDirect2D.cpp b/Source/WebCore/platform/graphics/win/GradientDirect2D.cpp
index a0380e63a6d..14f4e4f466a 100644
--- a/Source/WebCore/platform/graphics/win/GradientDirect2D.cpp
+++ b/Source/WebCore/platform/graphics/win/GradientDirect2D.cpp
@@ -120,11 +120,20 @@ void Gradient::fill(GraphicsContext* context, const FloatRect& rect)
     if (!m_cachedHash || !m_gradient)
         generateGradient(d2dContext);
 
+    if (!context->didBeginDraw())
+        d2dContext->BeginDraw();
+
     d2dContext->SetTags(GRADIENT_DRAWING, __LINE__);
 
     const D2D1_RECT_F d2dRect = rect;
     d2dContext->FillRectangle(&d2dRect, m_gradient);
 
+    if (!context->didBeginDraw()) {
+        D2D1_TAG first, second;
+        HRESULT hr = d2dContext->EndDraw(&first, &second);
+        RELEASE_ASSERT(SUCCEEDED(hr));
+    }
+
     if (needScaling)
         context->restore();
 }
diff --git a/Source/WebCore/platform/graphics/win/GraphicsContextCGWin.cpp b/Source/WebCore/platform/graphics/win/GraphicsContextCGWin.cpp
index f7b8aee923d..9f80769fe40 100644
--- a/Source/WebCore/platform/graphics/win/GraphicsContextCGWin.cpp
+++ b/Source/WebCore/platform/graphics/win/GraphicsContextCGWin.cpp
@@ -26,8 +26,6 @@
 #include "config.h"
 #include "GraphicsContextCG.h"
 
-#if USE(CG)
-
 #include "AffineTransform.h"
 #include "GraphicsContextPlatformPrivateCG.h"
 #include "Path.h"
@@ -264,4 +262,3 @@ void GraphicsContextPlatformPrivate::flush()
 }
 
 }
-#endif
diff --git a/Source/WebCore/platform/graphics/win/GraphicsContextDirect2D.cpp b/Source/WebCore/platform/graphics/win/GraphicsContextDirect2D.cpp
deleted file mode 100644
index 6405970f275..00000000000
--- a/Source/WebCore/platform/graphics/win/GraphicsContextDirect2D.cpp
+++ /dev/null
@@ -1,2041 +0,0 @@
-/*
- * Copyright (C) 2016 Apple Inc. All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS'' AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
- * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#include "config.h"
-#include "GraphicsContext.h"
-
-#include "COMPtr.h"
-#include "CurrentTime.h"
-#include "DisplayListRecorder.h"
-#include "FloatRoundedRect.h"
-#include "GraphicsContextPlatformPrivateDirect2D.h"
-#include "ImageBuffer.h"
-#include "Logging.h"
-#include "NotImplemented.h"
-#include "URL.h"
-#include <d2d1.h>
-#include <d2d1effects.h>
-#include <dwrite.h>
-
-#pragma warning (disable : 4756)
-
-using namespace std;
-
-namespace WebCore {
-
-GraphicsContext::GraphicsContext(HDC hdc, bool hasAlpha)
-{
-    platformInit(hdc, hasAlpha);
-}
-
-GraphicsContext::GraphicsContext(HDC hdc, ID2D1DCRenderTarget** renderTarget, RECT rect, bool hasAlpha)
-{
-    m_data->m_hdc = hdc;
-
-    // Create a DC render target.
-    auto targetProperties = D2D1::RenderTargetProperties(D2D1_RENDER_TARGET_TYPE_DEFAULT,
-        D2D1::PixelFormat(DXGI_FORMAT_B8G8R8A8_UNORM, D2D1_ALPHA_MODE_IGNORE),
-        0, 0, D2D1_RENDER_TARGET_USAGE_NONE, D2D1_FEATURE_LEVEL_DEFAULT);
-
-    HRESULT hr = GraphicsContext::systemFactory()->CreateDCRenderTarget(&targetProperties, renderTarget);
-    RELEASE_ASSERT(SUCCEEDED(hr));
-
-    (*renderTarget)->BindDC(hdc, &rect);
-
-    m_data = new GraphicsContextPlatformPrivate(*renderTarget);
-}
-
-ID2D1Factory* GraphicsContext::systemFactory()
-{
-    static ID2D1Factory* direct2DFactory = nullptr;
-    if (!direct2DFactory) {
-#ifndef NDEBUG
-        D2D1_FACTORY_OPTIONS options = { };
-        options.debugLevel = D2D1_DEBUG_LEVEL_INFORMATION;
-        HRESULT hr = D2D1CreateFactory(D2D1_FACTORY_TYPE_MULTI_THREADED, options, &direct2DFactory);
-#else
-        HRESULT hr = D2D1CreateFactory(D2D1_FACTORY_TYPE_MULTI_THREADED, &direct2DFactory);
-#endif
-        RELEASE_ASSERT(SUCCEEDED(hr));
-    }
-
-    return direct2DFactory;
-}
-
-ID2D1RenderTarget* GraphicsContext::defaultRenderTarget()
-{
-    static ID2D1RenderTarget* defaultRenderTarget = nullptr;
-    if (!defaultRenderTarget) {
-        auto renderTargetProperties = D2D1::RenderTargetProperties();
-        renderTargetProperties.usage = D2D1_RENDER_TARGET_USAGE_GDI_COMPATIBLE;
-        auto hwndRenderTargetProperties = D2D1::HwndRenderTargetProperties(::GetDesktopWindow(), D2D1::SizeU(10, 10));
-        HRESULT hr = systemFactory()->CreateHwndRenderTarget(&renderTargetProperties, &hwndRenderTargetProperties, reinterpret_cast<ID2D1HwndRenderTarget**>(&defaultRenderTarget));
-        RELEASE_ASSERT(SUCCEEDED(hr));
-    }
-
-    return defaultRenderTarget;
-}
-
-void GraphicsContext::platformInit(HDC hdc, bool hasAlpha)
-{
-    if (!hdc)
-        return;
-
-    HBITMAP bitmap = static_cast<HBITMAP>(GetCurrentObject(hdc, OBJ_BITMAP));
-
-    DIBPixelData pixelData(bitmap);
-
-    auto targetProperties = D2D1::RenderTargetProperties();
-    targetProperties.pixelFormat = D2D1::PixelFormat(DXGI_FORMAT_B8G8R8A8_UNORM, D2D1_ALPHA_MODE_IGNORE);
-
-    COMPtr<ID2D1DCRenderTarget> renderTarget;
-    HRESULT hr = systemFactory()->CreateDCRenderTarget(&targetProperties, &renderTarget);
-    if (!SUCCEEDED(hr))
-        return;
-
-    RECT clientRect = IntRect(IntPoint(), pixelData.size());
-    hr = renderTarget->BindDC(hdc, &clientRect);
-    if (!SUCCEEDED(hr))
-        return;
-
-    m_data = new GraphicsContextPlatformPrivate(renderTarget.get());
-    m_data->m_hdc = hdc;
-    // Make sure the context starts in sync with our state.
-    setPlatformFillColor(fillColor());
-    setPlatformStrokeColor(strokeColor());
-    setPlatformStrokeThickness(strokeThickness());
-    // FIXME: m_state.imageInterpolationQuality = convertInterpolationQuality(CGContextGetInterpolationQuality(platformContext()));
-}
-
-void GraphicsContext::platformInit(ID2D1RenderTarget* renderTarget)
-{
-    if (!renderTarget)
-        return;
-
-    m_data = new GraphicsContextPlatformPrivate(renderTarget);
-
-    // Make sure the context starts in sync with our state.
-    setPlatformFillColor(fillColor());
-    setPlatformStrokeColor(strokeColor());
-    setPlatformStrokeThickness(strokeThickness());
-    // FIXME: m_state.imageInterpolationQuality = convertInterpolationQuality(CGContextGetInterpolationQuality(platformContext()));
-}
-
-void GraphicsContext::platformDestroy()
-{
-    delete m_data;
-}
-
-ID2D1RenderTarget* GraphicsContext::platformContext() const
-{
-    ASSERT(!paintingDisabled());
-    return m_data->renderTarget();
-}
-
-ID2D1RenderTarget* GraphicsContextPlatformPrivate::renderTarget()
-{
-    if (!m_transparencyLayerStack.isEmpty())
-        return m_transparencyLayerStack.last().renderTarget.get();
-
-    return m_renderTarget.get();
-}
-
-void GraphicsContextPlatformPrivate::setAlpha(float alpha)
-{
-    ASSERT(m_transparencyLayerStack.isEmpty());
-    m_alpha = alpha;
-}
-
-float GraphicsContextPlatformPrivate::currentGlobalAlpha() const
-{
-    if (!m_transparencyLayerStack.isEmpty())
-        return m_transparencyLayerStack.last().opacity;
-
-    return m_alpha;
-}
-
-void GraphicsContext::savePlatformState()
-{
-    ASSERT(!paintingDisabled());
-    ASSERT(!isRecording());
-
-    // Note: Do not use this function within this class implementation, since we want to avoid the extra
-    // save of the secondary context (in GraphicsContextPlatformPrivateDirect2D.h).
-    m_data->save();
-}
-
-void GraphicsContext::restorePlatformState()
-{
-    ASSERT(!paintingDisabled());
-    ASSERT(!isRecording());
-
-    // Note: Do not use this function within this class implementation, since we want to avoid the extra
-    // restore of the secondary context (in GraphicsContextPlatformPrivateDirect2D.h).
-    m_data->restore();
-    // FIXME: m_data->m_userToDeviceTransformKnownToBeIdentity = false;
-}
-
-void GraphicsContext::drawNativeImage(const COMPtr<ID2D1Bitmap>& image, const FloatSize& imageSize, const FloatRect& destRect, const FloatRect& srcRect, CompositeOperator op, BlendMode blendMode, ImageOrientation orientation)
-{
-    if (paintingDisabled())
-        return;
-
-    if (isRecording()) {
-        // FIXME: Implement DisplayListRecorder support for drawNativeImage.
-        // m_displayListRecorder->drawNativeImage(image, imageSize, destRect, srcRect, op, blendMode, orientation);
-        notImplemented();
-        return;
-    }
-
-    auto bitmapSize = image->GetSize();
-
-    float currHeight = orientation.usesWidthAsHeight() ? bitmapSize.width : bitmapSize.height;
-    if (currHeight <= srcRect.y())
-        return;
-
-    auto context = platformContext();
-
-    D2D1_MATRIX_3X2_F ctm;
-    context->GetTransform(&ctm);
-
-    AffineTransform transform(ctm);
-
-    D2DContextStateSaver stateSaver(*m_data);
-
-    bool shouldUseSubimage = false;
-
-    // If the source rect is a subportion of the image, then we compute an inflated destination rect that will hold the entire image
-    // and then set a clip to the portion that we want to display.
-    FloatRect adjustedDestRect = destRect;
-
-    if (srcRect.size() != imageSize) {
-        // FIXME: Implement image scaling
-        notImplemented();
-    }
-
-    // If the image is only partially loaded, then shrink the destination rect that we're drawing into accordingly.
-    if (!shouldUseSubimage && currHeight < imageSize.height())
-        adjustedDestRect.setHeight(adjustedDestRect.height() * currHeight / imageSize.height());
-
-    setPlatformCompositeOperation(op, blendMode);
-
-    // ImageOrientation expects the origin to be at (0, 0).
-    transform.translate(adjustedDestRect.x(), adjustedDestRect.y());
-    context->SetTransform(transform);
-    adjustedDestRect.setLocation(FloatPoint());
-
-    if (orientation != DefaultImageOrientation) {
-        this->concatCTM(orientation.transformFromDefault(adjustedDestRect.size()));
-        if (orientation.usesWidthAsHeight()) {
-            // The destination rect will have it's width and height already reversed for the orientation of
-            // the image, as it was needed for page layout, so we need to reverse it back here.
-            adjustedDestRect = FloatRect(adjustedDestRect.x(), adjustedDestRect.y(), adjustedDestRect.height(), adjustedDestRect.width());
-        }
-    }
-
-    context->SetTags(1, __LINE__);
-
-    drawWithoutShadow(adjustedDestRect, [this, image, adjustedDestRect, srcRect](ID2D1RenderTarget* renderTarget) {
-        renderTarget->DrawBitmap(image.get(), adjustedDestRect, 1.0f, D2D1_BITMAP_INTERPOLATION_MODE_LINEAR, static_cast<D2D1_RECT_F>(srcRect));
-    });
-
-    flush();
-
-    if (!stateSaver.didSave())
-        context->SetTransform(ctm);
-}
-
-void GraphicsContext::releaseWindowsContext(HDC hdc, const IntRect& dstRect, bool supportAlphaBlend, bool mayCreateBitmap)
-{
-    bool createdBitmap = mayCreateBitmap && (!m_data->m_hdc || isInTransparencyLayer());
-    if (!createdBitmap) {
-        m_data->restore();
-        return;
-    }
-
-    if (!hdc || dstRect.isEmpty())
-        return;
-
-    auto sourceBitmap = adoptGDIObject(static_cast<HBITMAP>(::GetCurrentObject(hdc, OBJ_BITMAP)));
-
-    DIBPixelData pixelData(sourceBitmap.get());
-    ASSERT(pixelData.bitsPerPixel() == 32);
-
-    auto bitmapProperties = D2D1::BitmapProperties(D2D1::PixelFormat(DXGI_FORMAT_B8G8R8A8_UNORM, D2D1_ALPHA_MODE_IGNORE));
-
-    COMPtr<ID2D1Bitmap> bitmap;
-    HRESULT hr = platformContext()->CreateBitmap(pixelData.size(), pixelData.buffer(), pixelData.bytesPerRow(), &bitmapProperties, &bitmap);
-    ASSERT(SUCCEEDED(hr));
-
-    D2DContextStateSaver stateSaver(*m_data);
-
-    // Note: The content in the HDC is inverted compared to Direct2D, so it needs to be flipped.
-    auto context = platformContext();
-
-    D2D1_MATRIX_3X2_F currentTransform;
-    context->GetTransform(&currentTransform);
-
-    AffineTransform transform(currentTransform);
-    transform.translate(dstRect.location());
-    transform.scale(1.0, -1.0);
-    transform.translate(0, -dstRect.height());
-
-    context->SetTransform(transform);
-    context->DrawBitmap(bitmap.get(), D2D1::RectF(0, 0, dstRect.width(), dstRect.height()));
-
-    ::DeleteDC(hdc);
-}
-
-void GraphicsContext::drawWindowsBitmap(WindowsBitmap* image, const IntPoint& point)
-{
-}
-
-void GraphicsContext::drawFocusRing(const Path& path, float width, float offset, const Color& color)
-{
-}
-
-void GraphicsContext::drawFocusRing(const Vector<FloatRect>& rects, float width, float offset, const Color& color)
-{
-}
-
-void GraphicsContext::updateDocumentMarkerResources()
-{
-}
-
-void GraphicsContext::drawLineForDocumentMarker(const FloatPoint& point, float width, DocumentMarkerLineStyle style)
-{
-}
-
-GraphicsContextPlatformPrivate::GraphicsContextPlatformPrivate(ID2D1RenderTarget* renderTarget)
-    : m_renderTarget(renderTarget)
-{
-    if (!m_renderTarget)
-        return;
-
-    beginDraw();
-}
-
-GraphicsContextPlatformPrivate::~GraphicsContextPlatformPrivate()
-{
-    if (!m_renderTarget)
-        return;
-
-    endDraw();
-}
-
-COMPtr<ID2D1SolidColorBrush> GraphicsContextPlatformPrivate::brushWithColor(const D2D1_COLOR_F& color)
-{
-    RGBA32 colorKey = makeRGBA32FromFloats(color.r, color.g, color.b, color.a);
-
-    if (!colorKey) {
-        if (!m_zeroBrush)
-            m_renderTarget->CreateSolidColorBrush(color, &m_zeroBrush);
-        return m_zeroBrush;
-    }
-
-    if (colorKey == 0xFFFFFFFF) {
-        if (!m_whiteBrush)
-            m_renderTarget->CreateSolidColorBrush(color, &m_whiteBrush);
-        return m_whiteBrush;
-    }
-
-    auto existingBrush = m_solidColoredBrushCache.ensure(colorKey, [this, color] {
-        COMPtr<ID2D1SolidColorBrush> colorBrush;
-        m_renderTarget->CreateSolidColorBrush(color, &colorBrush);
-        return colorBrush;
-    });
-
-    return existingBrush.iterator->value;
-}
-
-ID2D1SolidColorBrush* GraphicsContext::brushWithColor(const Color& color)
-{
-    return m_data->brushWithColor(colorWithGlobalAlpha(color)).get();
-}
-
-void GraphicsContextPlatformPrivate::clip(const FloatRect& rect)
-{
-    if (m_renderStates.isEmpty())
-        save();
-
-    m_renderTarget->PushAxisAlignedClip(rect, D2D1_ANTIALIAS_MODE_PER_PRIMITIVE);
-    m_renderStates.last().m_clips.append(GraphicsContextPlatformPrivate::AxisAlignedClip);
-}
-
-void GraphicsContextPlatformPrivate::clip(const Path& path)
-{
-    clip(path.platformPath());
-}
-
-void GraphicsContextPlatformPrivate::clip(ID2D1Geometry* path)
-{
-    ASSERT(m_renderStates.size());
-    if (!m_renderStates.size())
-        return;
-
-    COMPtr<ID2D1Layer> clipLayer;
-    HRESULT hr = m_renderTarget->CreateLayer(&clipLayer);
-    ASSERT(SUCCEEDED(hr));
-    if (!SUCCEEDED(hr))
-        return;
-
-    m_renderTarget->PushLayer(D2D1::LayerParameters(D2D1::InfiniteRect(), path), clipLayer.get());
-    m_renderStates.last().m_clips.append(GraphicsContextPlatformPrivate::LayerClip);
-    m_renderStates.last().m_activeLayer = clipLayer;
-}
-
-void GraphicsContextPlatformPrivate::concatCTM(const AffineTransform& affineTransform)
-{
-    ASSERT(m_renderTarget.get());
-
-    D2D1_MATRIX_3X2_F currentTransform;
-    m_renderTarget->GetTransform(&currentTransform);
-
-    D2D1_MATRIX_3X2_F transformToConcat = affineTransform;
-    m_renderTarget->SetTransform(transformToConcat * currentTransform);
-}
-
-void GraphicsContextPlatformPrivate::flush()
-{
-    ASSERT(m_renderTarget.get());
-    D2D1_TAG first, second;
-    HRESULT hr = m_renderTarget->Flush(&first, &second);
-
-    RELEASE_ASSERT(SUCCEEDED(hr));
-}
-
-void GraphicsContextPlatformPrivate::beginDraw()
-{
-    ASSERT(m_renderTarget.get());
-    m_renderTarget->BeginDraw();
-}
-
-void GraphicsContextPlatformPrivate::endDraw()
-{
-    ASSERT(m_renderTarget.get());
-    D2D1_TAG first, second;
-    HRESULT hr = m_renderTarget->EndDraw(&first, &second);
-
-    if (!SUCCEEDED(hr))
-        WTFLogAlways("Failed in GraphicsContextPlatformPrivate::endDraw: hr=%ld, first=%ld, second=%ld", hr, first, second);
-}
-
-void GraphicsContextPlatformPrivate::restore()
-{
-    ASSERT(m_renderTarget.get());
-
-    auto restoreState = m_renderStates.takeLast();
-    m_renderTarget->RestoreDrawingState(restoreState.m_drawingStateBlock.get());
-
-    for (auto clipType = restoreState.m_clips.rbegin(); clipType != restoreState.m_clips.rend(); ++clipType) {
-        if (*clipType == GraphicsContextPlatformPrivate::AxisAlignedClip)
-            m_renderTarget->PopAxisAlignedClip();
-        else
-            m_renderTarget->PopLayer();
-    }
-}
-
-void GraphicsContextPlatformPrivate::save()
-{
-    ASSERT(m_renderTarget.get());
-
-    RenderState currentState;
-    GraphicsContext::systemFactory()->CreateDrawingStateBlock(&currentState.m_drawingStateBlock);
-
-    m_renderTarget->SaveDrawingState(currentState.m_drawingStateBlock.get());
-
-    m_renderStates.append(currentState);
-}
-
-void GraphicsContextPlatformPrivate::scale(const FloatSize& size)
-{
-    ASSERT(m_renderTarget.get());
-
-    D2D1_MATRIX_3X2_F currentTransform;
-    m_renderTarget->GetTransform(&currentTransform);
-
-    auto scale = D2D1::Matrix3x2F::Scale(size);
-    m_renderTarget->SetTransform(scale * currentTransform);
-}
-
-void GraphicsContextPlatformPrivate::setCTM(const AffineTransform& transform)
-{
-    ASSERT(m_renderTarget.get());
-    m_renderTarget->SetTransform(transform);
-}
-
-void GraphicsContextPlatformPrivate::translate(float x, float y)
-{
-    ASSERT(m_renderTarget.get());
-
-    D2D1_MATRIX_3X2_F currentTransform;
-    m_renderTarget->GetTransform(&currentTransform);
-
-    auto translation = D2D1::Matrix3x2F::Translation(x, y);
-    m_renderTarget->SetTransform(translation * currentTransform);
-}
-
-void GraphicsContextPlatformPrivate::rotate(float angle)
-{
-    ASSERT(m_renderTarget.get());
-
-    D2D1_MATRIX_3X2_F currentTransform;
-    m_renderTarget->GetTransform(&currentTransform);
-
-    auto rotation = D2D1::Matrix3x2F::Rotation(rad2deg(angle));
-    m_renderTarget->SetTransform(rotation * currentTransform);
-}
-
-D2D1_COLOR_F GraphicsContext::colorWithGlobalAlpha(const Color& color) const
-{
-    float colorAlpha = color.alphaAsFloat();
-    float globalAlpha = m_data->currentGlobalAlpha();
-
-    return D2D1::ColorF(color.rgb(), globalAlpha * colorAlpha);
-}
-
-ID2D1Brush* GraphicsContext::solidStrokeBrush() const
-{
-    return m_data->m_solidStrokeBrush.get();
-}
-
-ID2D1Brush* GraphicsContext::solidFillBrush() const
-{
-    return m_data->m_solidFillBrush.get();
-}
-
-ID2D1Brush* GraphicsContext::patternStrokeBrush() const
-{
-    return m_data->m_patternStrokeBrush.get();
-}
-
-ID2D1Brush* GraphicsContext::patternFillBrush() const
-{
-    return m_data->m_patternFillBrush.get();
-}
-
-void GraphicsContext::beginDraw()
-{
-    m_data->beginDraw();
-}
-
-void GraphicsContext::endDraw()
-{
-    m_data->endDraw();
-}
-
-void GraphicsContext::flush()
-{
-    m_data->flush();
-}
-
-void GraphicsContext::drawPattern(Image& image, const FloatRect& destRect, const FloatRect& tileRect, const AffineTransform& patternTransform, const FloatPoint& phase, const FloatSize& spacing, CompositeOperator op, BlendMode blendMode)
-{
-    if (paintingDisabled() || !patternTransform.isInvertible())
-        return;
-
-    if (isRecording()) {
-        m_displayListRecorder->drawPattern(image, destRect, tileRect, patternTransform, phase, spacing, op, blendMode);
-        return;
-    }
-
-    auto context = platformContext();
-    D2DContextStateSaver stateSaver(*m_data);
-
-    m_data->clip(destRect);
-
-    setPlatformCompositeOperation(op, blendMode);
-
-    auto bitmapBrushProperties = D2D1::BitmapBrushProperties();
-    bitmapBrushProperties.extendModeX = D2D1_EXTEND_MODE_WRAP;
-    bitmapBrushProperties.extendModeY = D2D1_EXTEND_MODE_WRAP;
-
-    // Create a brush transformation so we paint using the section of the image we care about.
-    AffineTransform transformation = patternTransform;
-    transformation.translate(destRect.location());
-
-    auto brushProperties = D2D1::BrushProperties();
-    brushProperties.transform = transformation;
-    brushProperties.opacity = 1.0f;
-
-    auto tileImage = image.nativeImageForCurrentFrame();
-
-    // If we only want a subset of the bitmap, we need to create a cropped bitmap image. According to the documentation,
-    // this does not allocate new bitmap memory.
-    if (image.width() > destRect.width() || image.height() > destRect.height()) {
-        float dpiX = 0;
-        float dpiY = 0;
-        tileImage->GetDpi(&dpiX, &dpiY);
-        auto bitmapProperties = D2D1::BitmapProperties(tileImage->GetPixelFormat(), dpiX, dpiY);
-        COMPtr<ID2D1Bitmap> subImage;
-        HRESULT hr = context->CreateBitmap(IntSize(tileRect.size()), bitmapProperties, &subImage);
-        if (SUCCEEDED(hr)) {
-            D2D1_RECT_U finishRect = IntRect(tileRect);
-            hr = subImage->CopyFromBitmap(nullptr, tileImage.get(), &finishRect);
-            if (SUCCEEDED(hr))
-                tileImage = subImage;
-        }
-    }
-
-    COMPtr<ID2D1BitmapBrush> patternBrush;
-    HRESULT hr = context->CreateBitmapBrush(tileImage.get(), &bitmapBrushProperties, &brushProperties, &patternBrush);
-
-    drawWithoutShadow(destRect, [this, destRect, patternBrush](ID2D1RenderTarget* renderTarget) {
-        const D2D1_RECT_F d2dRect = destRect;
-        renderTarget->FillRectangle(&d2dRect, patternBrush.get());
-    });
-}
-
-void GraphicsContext::clipToImageBuffer(ImageBuffer& buffer, const FloatRect& destRect)
-{
-    if (paintingDisabled())
-        return;
-
-    FloatSize bufferDestinationSize = buffer.sizeForDestinationSize(destRect.size());
-    notImplemented();
-}
-
-// Draws a filled rectangle with a stroked border.
-void GraphicsContext::drawRect(const FloatRect& rect, float borderThickness)
-{
-    if (paintingDisabled())
-        return;
-
-    if (isRecording()) {
-        m_displayListRecorder->drawRect(rect, borderThickness);
-        return;
-    }
-
-    // FIXME: this function does not handle patterns and gradients like drawPath does, it probably should.
-    ASSERT(!rect.isEmpty());
-
-    auto context = platformContext();
-
-    context->SetTags(1, __LINE__);
-
-    drawWithoutShadow(rect, [this, rect](ID2D1RenderTarget* renderTarget) {
-        const D2D1_RECT_F d2dRect = rect;
-        renderTarget->FillRectangle(&d2dRect, solidFillBrush());
-        renderTarget->DrawRectangle(&d2dRect, solidStrokeBrush(), strokeThickness(), m_data->strokeStyle());
-    });
-}
-
-void GraphicsContextPlatformPrivate::setLineCap(LineCap cap)
-{
-    if (m_lineCap == cap)
-        return;
-
-    D2D1_CAP_STYLE capStyle = D2D1_CAP_STYLE_FLAT;
-    switch (cap) {
-    case RoundCap:
-        capStyle = D2D1_CAP_STYLE_ROUND;
-        break;
-    case SquareCap:
-        capStyle = D2D1_CAP_STYLE_SQUARE;
-        break;
-    case ButtCap:
-    default:
-        capStyle = D2D1_CAP_STYLE_FLAT;
-        break;
-    }
-
-    m_lineCap = capStyle;
-    m_strokeSyleIsDirty = true;
-}
-
-void GraphicsContextPlatformPrivate::setLineJoin(LineJoin join)
-{
-    if (m_lineJoin == join)
-        return;
-
-    D2D1_LINE_JOIN joinStyle = D2D1_LINE_JOIN_MITER;
-    switch (join) {
-    case RoundJoin:
-        joinStyle = D2D1_LINE_JOIN_ROUND;
-        break;
-    case BevelJoin:
-        joinStyle = D2D1_LINE_JOIN_BEVEL;
-        break;
-    case MiterJoin:
-    default:
-        joinStyle = D2D1_LINE_JOIN_MITER;
-        break;
-    }
-
-    m_lineJoin = joinStyle;
-    m_strokeSyleIsDirty = true;
-}
-
-void GraphicsContextPlatformPrivate::setStrokeStyle(StrokeStyle strokeStyle)
-{
-    if (m_strokeStyle == strokeStyle)
-        return;
-
-    m_strokeStyle = strokeStyle;
-    m_strokeSyleIsDirty = true;
-}
-
-void GraphicsContextPlatformPrivate::setMiterLimit(float miterLimit)
-{
-    if (WTF::areEssentiallyEqual(miterLimit, m_miterLimit))
-        return;
-
-    m_miterLimit = miterLimit;
-    m_strokeSyleIsDirty = true;
-}
-
-void GraphicsContextPlatformPrivate::setDashOffset(float dashOffset)
-{
-    if (WTF::areEssentiallyEqual(dashOffset, m_dashOffset))
-        return;
-
-    m_dashOffset = dashOffset;
-    m_strokeSyleIsDirty = true;
-}
-
-void GraphicsContextPlatformPrivate::setPatternWidth(float patternWidth)
-{
-    if (WTF::areEssentiallyEqual(patternWidth, m_patternWidth))
-        return;
-
-    m_patternWidth = patternWidth;
-    m_strokeSyleIsDirty = true;
-}
-
-void GraphicsContextPlatformPrivate::setPatternOffset(float patternOffset)
-{
-    if (WTF::areEssentiallyEqual(patternOffset, m_patternOffset))
-        return;
-
-    m_patternOffset = patternOffset;
-    m_strokeSyleIsDirty = true;
-}
-
-void GraphicsContextPlatformPrivate::setStrokeThickness(float thickness)
-{
-    if (WTF::areEssentiallyEqual(thickness, m_strokeThickness))
-        return;
-
-    m_strokeThickness = thickness;
-    m_strokeSyleIsDirty = true;
-}
-
-void GraphicsContextPlatformPrivate::setDashes(const DashArray& dashes)
-{
-    if (m_dashes == dashes)
-        return;
-
-    m_dashes = dashes;
-    m_strokeSyleIsDirty = true;
-}
-
-void GraphicsContextPlatformPrivate::recomputeStrokeStyle()
-{
-    if (!m_strokeSyleIsDirty)
-        return;
-
-    m_d2dStrokeStyle = nullptr;
-
-    if ((m_strokeStyle != SolidStroke) && (m_strokeStyle != NoStroke)) {
-        float patternOffset = m_patternOffset / m_strokeThickness;
-
-        DashArray dashes = m_dashes;
-
-        // In Direct2D, dashes and dots are defined in terms of the ratio of the dash length to the line thickness.
-        for (auto& dash : dashes)
-            dash /= m_strokeThickness;
-
-        auto strokeStyleProperties = D2D1::StrokeStyleProperties(m_lineCap, m_lineCap, m_lineCap, m_lineJoin, m_strokeThickness, D2D1_DASH_STYLE_CUSTOM, patternOffset);
-        GraphicsContext::systemFactory()->CreateStrokeStyle(&strokeStyleProperties, dashes.data(), dashes.size(), &m_d2dStrokeStyle);
-    }
-
-    m_strokeSyleIsDirty = false;
-}
-
-ID2D1StrokeStyle* GraphicsContextPlatformPrivate::strokeStyle()
-{
-    recomputeStrokeStyle();
-    return m_d2dStrokeStyle.get();
-}
-
-ID2D1StrokeStyle* GraphicsContext::platformStrokeStyle() const
-{
-    return m_data->strokeStyle();
-}
-
-// This is only used to draw borders.
-void GraphicsContext::drawLine(const FloatPoint& point1, const FloatPoint& point2)
-{
-    if (paintingDisabled())
-        return;
-
-    if (strokeStyle() == NoStroke)
-        return;
-
-    if (isRecording()) {
-        m_displayListRecorder->drawLine(point1, point2);
-        return;
-    }
-
-    float thickness = strokeThickness();
-    bool isVerticalLine = (point1.x() + thickness == point2.x());
-    float strokeWidth = isVerticalLine ? point2.y() - point1.y() : point2.x() - point1.x();
-    if (!thickness || !strokeWidth)
-        return;
-
-    auto context = platformContext();
-
-    StrokeStyle strokeStyle = this->strokeStyle();
-    float cornerWidth = 0;
-    bool drawsDashedLine = strokeStyle == DottedStroke || strokeStyle == DashedStroke;
-
-    COMPtr<ID2D1StrokeStyle> d2dStrokeStyle;
-    D2DContextStateSaver stateSaver(*m_data, drawsDashedLine);
-    if (drawsDashedLine) {
-        // Figure out end points to ensure we always paint corners.
-        cornerWidth = dashedLineCornerWidthForStrokeWidth(strokeWidth);
-        strokeWidth -= 2 * cornerWidth;
-        float patternWidth = dashedLinePatternWidthForStrokeWidth(strokeWidth);
-        // Check if corner drawing sufficiently covers the line.
-        if (strokeWidth <= patternWidth + 1)
-            return;
-
-        float patternOffset = dashedLinePatternOffsetForPatternAndStrokeWidth(patternWidth, strokeWidth);
-        const float dashes[2] = { patternWidth, patternWidth };
-        auto strokeStyleProperties = D2D1::StrokeStyleProperties();
-        GraphicsContext::systemFactory()->CreateStrokeStyle(&strokeStyleProperties, dashes, ARRAYSIZE(dashes), &d2dStrokeStyle);
-
-        m_data->setPatternWidth(patternWidth);
-        m_data->setPatternOffset(patternOffset);
-        m_data->setDashes(DashArray(2, patternWidth));
-
-        d2dStrokeStyle = m_data->strokeStyle();
-    }
-
-    auto centeredPoints = centerLineAndCutOffCorners(isVerticalLine, cornerWidth, point1, point2);
-    auto p1 = centeredPoints[0];
-    auto p2 = centeredPoints[1];
-
-    context->SetTags(1, __LINE__);
-
-    FloatRect boundingRect(p1, p2);
-
-    drawWithoutShadow(boundingRect, [this, p1, p2, d2dStrokeStyle](ID2D1RenderTarget* renderTarget) {
-        renderTarget->DrawLine(p1, p2, solidStrokeBrush(), strokeThickness(), d2dStrokeStyle.get());
-    });
-}
-
-void GraphicsContext::drawEllipse(const FloatRect& rect)
-{
-    if (paintingDisabled())
-        return;
-
-    if (isRecording()) {
-        m_displayListRecorder->drawEllipse(rect);
-        return;
-    }
-
-    auto ellipse = D2D1::Ellipse(rect.center(), 0.5 * rect.width(), 0.5 * rect.height());
-
-    auto context = platformContext();
-
-    context->SetTags(1, __LINE__);
-
-    drawWithoutShadow(rect, [this, ellipse](ID2D1RenderTarget* renderTarget) {
-        renderTarget->FillEllipse(&ellipse, solidFillBrush());
-
-        renderTarget->DrawEllipse(&ellipse, solidStrokeBrush(), strokeThickness(), m_data->strokeStyle());
-    });
-}
-
-void GraphicsContext::applyStrokePattern()
-{
-    if (paintingDisabled())
-        return;
-
-    auto context = platformContext();
-    AffineTransform userToBaseCTM; // FIXME: This isn't really needed on Windows
-
-    const float patternAlpha = 1;
-    m_data->m_patternStrokeBrush = adoptCOM(m_state.strokePattern->createPlatformPattern(*this, patternAlpha, userToBaseCTM));
-}
-
-void GraphicsContext::applyFillPattern()
-{
-    if (paintingDisabled())
-        return;
-
-    auto context = platformContext();
-    AffineTransform userToBaseCTM; // FIXME: This isn't really needed on Windows
-
-    const float patternAlpha = 1;
-    m_data->m_patternFillBrush = adoptCOM(m_state.fillPattern->createPlatformPattern(*this, patternAlpha, userToBaseCTM));
-}
-
-void GraphicsContext::drawPath(const Path& path)
-{
-    if (paintingDisabled() || path.isEmpty())
-        return;
-
-    if (isRecording()) {
-        m_displayListRecorder->drawPath(path);
-        return;
-    }
-
-    auto context = platformContext();
-    const GraphicsContextState& state = m_state;
-
-    if (state.fillGradient || state.strokeGradient) {
-        // We don't have any optimized way to fill & stroke a path using gradients
-        // FIXME: Be smarter about this.
-        fillPath(path);
-        strokePath(path);
-        return;
-    }
-
-    if (state.fillPattern)
-        applyFillPattern();
-
-    if (state.strokePattern)
-        applyStrokePattern();
-
-    if (path.activePath())
-        path.activePath()->Close();
-
-    context->SetTags(1, __LINE__);
-
-    auto rect = path.fastBoundingRect();
-    drawWithoutShadow(rect, [this, &path](ID2D1RenderTarget* renderTarget) {
-        auto brush = m_state.strokePattern ? patternStrokeBrush() : solidStrokeBrush();
-        renderTarget->DrawGeometry(path.platformPath(), brush, strokeThickness(), m_data->strokeStyle());
-    });
-
-    flush();
-}
-
-void GraphicsContext::drawWithoutShadow(const FloatRect& /*boundingRect*/, const std::function<void(ID2D1RenderTarget*)>& drawCommands)
-{
-    drawCommands(platformContext());
-}
-
-static void drawWithShadowHelper(ID2D1RenderTarget* context, ID2D1Bitmap* bitmap, const Color& shadowColor, const FloatSize& shadowOffset, float shadowBlur)
-{
-    COMPtr<ID2D1DeviceContext> deviceContext;
-    HRESULT hr = context->QueryInterface(&deviceContext);
-    RELEASE_ASSERT(SUCCEEDED(hr));
-
-    // Create the shadow effect
-    COMPtr<ID2D1Effect> shadowEffect;
-    hr = deviceContext->CreateEffect(CLSID_D2D1Shadow, &shadowEffect);
-    RELEASE_ASSERT(SUCCEEDED(hr));
-
-    shadowEffect->SetInput(0, bitmap);
-    shadowEffect->SetValue(D2D1_SHADOW_PROP_COLOR, static_cast<D2D1_VECTOR_4F>(shadowColor));
-    shadowEffect->SetValue(D2D1_SHADOW_PROP_BLUR_STANDARD_DEVIATION, shadowBlur);
-
-    COMPtr<ID2D1Effect> transformEffect;
-    hr = deviceContext->CreateEffect(CLSID_D2D12DAffineTransform, &transformEffect);
-    RELEASE_ASSERT(SUCCEEDED(hr));
-
-    transformEffect->SetInputEffect(0, shadowEffect.get());
-
-    auto translation = D2D1::Matrix3x2F::Translation(shadowOffset.width(), shadowOffset.height());
-    transformEffect->SetValue(D2D1_2DAFFINETRANSFORM_PROP_TRANSFORM_MATRIX, translation);
-
-    COMPtr<ID2D1Effect> compositor;
-    hr = deviceContext->CreateEffect(CLSID_D2D1Composite, &compositor);
-    RELEASE_ASSERT(SUCCEEDED(hr));
-
-    compositor->SetInputEffect(0, transformEffect.get());
-    compositor->SetInput(1, bitmap);
-
-    // Flip the context
-    D2D1_MATRIX_3X2_F ctm;
-    deviceContext->GetTransform(&ctm);
-    auto translate = D2D1::Matrix3x2F::Translation(0.0f, deviceContext->GetSize().height);
-    auto flip = D2D1::Matrix3x2F::Scale(D2D1::SizeF(1.0f, -1.0f));
-    deviceContext->SetTransform(ctm * flip * translate);
-
-    deviceContext->DrawImage(compositor.get(), D2D1_INTERPOLATION_MODE_LINEAR);
-}
-
-void GraphicsContext::drawWithShadow(const FloatRect& boundingRect, const std::function<void(ID2D1RenderTarget*)>& drawCommands)
-{
-    auto context = platformContext();
-
-    // Render the current geometry to a bitmap context
-    COMPtr<ID2D1BitmapRenderTarget> bitmapTarget;
-    HRESULT hr = context->CreateCompatibleRenderTarget(&bitmapTarget);
-    RELEASE_ASSERT(SUCCEEDED(hr));
-
-    bitmapTarget->BeginDraw();
-    drawCommands(bitmapTarget.get());
-    hr = bitmapTarget->EndDraw();
-    RELEASE_ASSERT(SUCCEEDED(hr));
-
-    COMPtr<ID2D1Bitmap> bitmap;
-    hr = bitmapTarget->GetBitmap(&bitmap);
-    RELEASE_ASSERT(SUCCEEDED(hr));
-
-    drawWithShadowHelper(context, bitmap.get(), m_state.shadowColor, m_state.shadowOffset, m_state.shadowBlur);
-}
-
-void GraphicsContext::fillPath(const Path& path)
-{
-    if (paintingDisabled() || path.isEmpty())
-        return;
-
-    if (isRecording()) {
-        m_displayListRecorder->fillPath(path);
-        return;
-    }
-
-    if (path.activePath()) {
-        // Make sure it's closed. This might fail if the path was already closed, so
-        // ignore the return value.
-        path.activePath()->Close();
-    }
-
-    D2DContextStateSaver stateSaver(*m_data);
-
-    auto context = platformContext();
-
-    context->SetTags(1, __LINE__);
-
-    if (m_state.fillGradient) {
-        context->SetTags(1, __LINE__);
-
-        FloatRect boundingRect = path.fastBoundingRect();
-        auto drawFunction = [this, &path](ID2D1RenderTarget* renderTarget) {
-            renderTarget->FillGeometry(path.platformPath(), m_state.fillGradient->createPlatformGradientIfNecessary(renderTarget));
-        };
-
-        if (hasShadow())
-            drawWithShadow(boundingRect, drawFunction);
-        else
-            drawWithoutShadow(boundingRect, drawFunction);
-        return;
-    }
-
-    if (m_state.fillPattern)
-        applyFillPattern();
-
-    COMPtr<ID2D1GeometryGroup> pathToFill;
-    path.createGeometryWithFillMode(fillRule(), pathToFill);
-
-    context->SetTags(1, __LINE__);
-
-    FloatRect contextRect(FloatPoint(), context->GetSize());
-    drawWithoutShadow(contextRect, [this, &pathToFill](ID2D1RenderTarget* renderTarget) {
-        auto brush = m_state.fillPattern ? patternFillBrush() : solidFillBrush();
-        renderTarget->FillGeometry(pathToFill.get(), brush);
-    });
-
-    flush();
-}
-
-void GraphicsContext::strokePath(const Path& path)
-{
-    if (paintingDisabled() || path.isEmpty())
-        return;
-
-    if (isRecording()) {
-        m_displayListRecorder->strokePath(path);
-        return;
-    }
-
-    auto context = platformContext();
-    
-    context->SetTags(1, __LINE__);
-
-    if (m_state.strokeGradient) {
-        context->SetTags(1, __LINE__);
-
-        D2DContextStateSaver stateSaver(*m_data);
-        auto boundingRect = path.fastBoundingRect();
-        auto drawFunction = [this, &path](ID2D1RenderTarget* renderTarget) {
-            renderTarget->DrawGeometry(path.platformPath(), m_state.strokeGradient->createPlatformGradientIfNecessary(renderTarget));
-        };
-
-        if (hasShadow())
-            drawWithShadow(boundingRect, drawFunction);
-        else
-            drawWithoutShadow(boundingRect, drawFunction);
-
-        return;
-    }
-
-    if (m_state.strokePattern)
-        applyStrokePattern();
-
-    context->SetTags(1, __LINE__);
-
-    FloatRect contextRect(FloatPoint(), context->GetSize());
-    drawWithoutShadow(contextRect, [this, &path](ID2D1RenderTarget* renderTarget) {
-        auto brush = m_state.strokePattern ? patternStrokeBrush() : solidStrokeBrush();
-        renderTarget->DrawGeometry(path.platformPath(), brush, strokeThickness(), m_data->strokeStyle());
-    });
-
-    flush();
-}
-
-void GraphicsContext::fillRect(const FloatRect& rect)
-{
-    if (paintingDisabled())
-        return;
-
-    if (isRecording()) {
-        m_displayListRecorder->fillRect(rect);
-        return;
-    }
-
-    auto context = platformContext();
-
-    if (m_state.fillGradient) {
-        context->SetTags(1, __LINE__);
-        D2DContextStateSaver stateSaver(*m_data);
-        auto drawFunction = [this, rect](ID2D1RenderTarget* renderTarget) {
-            const D2D1_RECT_F d2dRect = rect;
-            renderTarget->FillRectangle(&d2dRect, m_state.fillGradient->createPlatformGradientIfNecessary(renderTarget));
-        };
-
-        if (hasShadow())
-            drawWithShadow(rect, drawFunction);
-        else
-            drawWithoutShadow(rect, drawFunction);
-        return;
-    }
-
-    if (m_state.fillPattern)
-        applyFillPattern();
-
-    context->SetTags(1, __LINE__);
-
-    bool drawOwnShadow = !isAcceleratedContext() && hasBlurredShadow() && !m_state.shadowsIgnoreTransforms; // Don't use ShadowBlur for canvas yet.
-    if (drawOwnShadow) {
-        // FIXME: Get ShadowBlur working on Direct2D
-        // ShadowBlur contextShadow(m_state);
-        // contextShadow.drawRectShadow(*this, FloatRoundedRect(rect));
-        notImplemented();
-    }
-
-    drawWithoutShadow(rect, [this, rect](ID2D1RenderTarget* renderTarget) {
-        const D2D1_RECT_F d2dRect = rect;
-        auto brush = m_state.fillPattern ? patternFillBrush() : solidFillBrush();
-        renderTarget->FillRectangle(&d2dRect, brush);
-    });
-}
-
-void GraphicsContext::fillRect(const FloatRect& rect, const Color& color)
-{
-    if (paintingDisabled())
-        return;
-
-    if (isRecording()) {
-        m_displayListRecorder->fillRect(rect, color);
-        return;
-    }
-
-    auto context = platformContext();
-
-    bool drawOwnShadow = !isAcceleratedContext() && hasBlurredShadow() && !m_state.shadowsIgnoreTransforms; // Don't use ShadowBlur for canvas yet.
-    if (drawOwnShadow) {
-        // FIXME: Get ShadowBlur working on Direct2D
-        // ShadowBlur contextShadow(m_state);
-        // contextShadow.drawRectShadow(*this, FloatRoundedRect(rect));
-        notImplemented();
-    }
-
-    context->SetTags(1, __LINE__);
-
-    drawWithoutShadow(rect, [this, rect, color](ID2D1RenderTarget* renderTarget) {
-        const D2D1_RECT_F d2dRect = rect;
-        renderTarget->FillRectangle(&d2dRect, brushWithColor(color));
-    });
-}
-
-void GraphicsContext::platformFillRoundedRect(const FloatRoundedRect& rect, const Color& color)
-{
-    if (paintingDisabled())
-        return;
-
-    ASSERT(!isRecording());
-
-    auto context = platformContext();
-
-    bool drawOwnShadow = !isAcceleratedContext() && hasBlurredShadow() && !m_state.shadowsIgnoreTransforms; // Don't use ShadowBlur for canvas yet.
-    D2DContextStateSaver stateSaver(*m_data, drawOwnShadow);
-    if (drawOwnShadow) {
-        // FIXME: Get ShadowBlur working on Direct2D
-        // ShadowBlur contextShadow(m_state);
-        // contextShadow.drawRectShadow(*this, rect);
-        notImplemented();
-    }
-
-    context->SetTags(1, __LINE__);
-
-    const FloatRect& r = rect.rect();
-    const FloatRoundedRect::Radii& radii = rect.radii();
-    bool equalWidths = (radii.topLeft().width() == radii.topRight().width() && radii.topRight().width() == radii.bottomLeft().width() && radii.bottomLeft().width() == radii.bottomRight().width());
-    bool equalHeights = (radii.topLeft().height() == radii.bottomLeft().height() && radii.bottomLeft().height() == radii.topRight().height() && radii.topRight().height() == radii.bottomRight().height());
-    bool hasCustomFill = m_state.fillGradient || m_state.fillPattern;
-    if (!hasCustomFill && equalWidths && equalHeights && radii.topLeft().width() * 2 == r.width() && radii.topLeft().height() * 2 == r.height()) {
-        auto roundedRect = D2D1::RoundedRect(r, radii.topLeft().width(), radii.topLeft().height());
-        context->FillRoundedRectangle(roundedRect, brushWithColor(color));
-    } else {
-        D2DContextStateSaver stateSaver(*m_data);
-        setFillColor(color);
-
-        Path path;
-        path.addRoundedRect(rect);
-        fillPath(path);
-    }
-
-    if (drawOwnShadow)
-        stateSaver.restore();
-}
-
-void GraphicsContext::fillRectWithRoundedHole(const FloatRect& rect, const FloatRoundedRect& roundedHoleRect, const Color& color)
-{
-    if (paintingDisabled())
-        return;
-
-    if (isRecording()) {
-        m_displayListRecorder->fillRectWithRoundedHole(rect, roundedHoleRect, color);
-        return;
-    }
-
-    auto context = platformContext();
-
-    context->SetTags(1, __LINE__);
-
-    Path path;
-    path.addRect(rect);
-
-    if (!roundedHoleRect.radii().isZero())
-        path.addRoundedRect(roundedHoleRect);
-    else
-        path.addRect(roundedHoleRect.rect());
-
-    WindRule oldFillRule = fillRule();
-    Color oldFillColor = fillColor();
-
-    setFillRule(RULE_EVENODD);
-    setFillColor(color);
-
-    // fillRectWithRoundedHole() assumes that the edges of rect are clipped out, so we only care about shadows cast around inside the hole.
-    bool drawOwnShadow = !isAcceleratedContext() && hasBlurredShadow() && !m_state.shadowsIgnoreTransforms;
-    D2DContextStateSaver stateSaver(*m_data, drawOwnShadow);
-    if (drawOwnShadow) {
-        // FIXME: Get ShadowBlur working on Direct2D
-        // ShadowBlur contextShadow(m_state);
-        // contextShadow.drawRectShadow(*this, rect);
-        notImplemented();
-    }
-
-    fillPath(path);
-
-    if (drawOwnShadow)
-        stateSaver.restore();
-
-    setFillRule(oldFillRule);
-    setFillColor(oldFillColor);
-}
-
-void GraphicsContext::clip(const FloatRect& rect)
-{
-    if (paintingDisabled())
-        return;
-
-    if (isRecording()) {
-        m_displayListRecorder->clip(rect);
-        return;
-    }
-
-    m_data->clip(rect);
-}
-
-void GraphicsContext::clipOut(const FloatRect& rect)
-{
-    if (paintingDisabled())
-        return;
-
-    if (isRecording()) {
-        m_displayListRecorder->clipOut(rect);
-        return;
-    }
-
-    Path path;
-    path.addRect(rect);
-
-    clipOut(path);
-}
-
-void GraphicsContext::clipOut(const Path& path)
-{
-    if (paintingDisabled())
-        return;
-
-    if (isRecording()) {
-        m_displayListRecorder->clipOut(path);
-        return;
-    }
-
-    // To clip Out we need the intersection of the infinite
-    // clipping rect and the path we just created.
-    D2D1_SIZE_F rendererSize = platformContext()->GetSize();
-    FloatRect clipBounds(0, 0, rendererSize.width, rendererSize.height);
-
-    Path boundingRect;
-    boundingRect.addRect(clipBounds);
-    boundingRect.appendGeometry(path.platformPath());
-
-    COMPtr<ID2D1GeometryGroup> pathToClip;
-    boundingRect.createGeometryWithFillMode(RULE_EVENODD, pathToClip);
-
-    m_data->clip(pathToClip.get());
-}
-
-void GraphicsContext::clipPath(const Path& path, WindRule clipRule)
-{
-    if (paintingDisabled())
-        return;
-
-    if (isRecording()) {
-        m_displayListRecorder->clipPath(path, clipRule);
-        return;
-    }
-
-    auto context = platformContext();
-    if (path.isEmpty()) {
-        m_data->clip(FloatRect());
-        return;
-    }
-
-    COMPtr<ID2D1GeometryGroup> pathToClip;
-    path.createGeometryWithFillMode(clipRule, pathToClip);
-
-    m_data->clip(pathToClip.get());
-}
-
-IntRect GraphicsContext::clipBounds() const
-{
-    if (paintingDisabled())
-        return IntRect();
-
-    if (isRecording()) {
-        WTFLogAlways("Getting the clip bounds not yet supported with display lists");
-        return IntRect(-2048, -2048, 4096, 4096); // FIXME: display lists.
-    }
-
-    D2D1_SIZE_F clipSize;
-    if (auto clipLayer = m_data->clipLayer())
-        clipSize = clipLayer->GetSize();
-    else
-        clipSize = platformContext()->GetSize();
-
-    FloatRect clipBounds(IntPoint(), clipSize);
-
-    return enclosingIntRect(clipBounds);
-}
-
-void GraphicsContextPlatformPrivate::beginTransparencyLayer(float opacity)
-{
-    TransparencyLayerState transparencyLayer;
-    transparencyLayer.opacity = opacity;
-
-    HRESULT hr = m_renderTarget->CreateCompatibleRenderTarget(&transparencyLayer.renderTarget);
-    RELEASE_ASSERT(SUCCEEDED(hr));
-    m_transparencyLayerStack.append(WTFMove(transparencyLayer));
-
-    m_transparencyLayerStack.last().renderTarget->BeginDraw();
-    m_transparencyLayerStack.last().renderTarget->Clear(D2D1::ColorF(0, 0, 0, 0));
-}
-
-void GraphicsContext::beginPlatformTransparencyLayer(float opacity)
-{
-    if (paintingDisabled())
-        return;
-
-    ASSERT(!isRecording());
-
-    save();
-
-    m_state.alpha = opacity;
-
-    m_data->beginTransparencyLayer(opacity);
-}
-
-void GraphicsContextPlatformPrivate::endTransparencyLayer()
-{
-    auto currentLayer = m_transparencyLayerStack.takeLast();
-    auto renderTarget = currentLayer.renderTarget;
-    if (!renderTarget)
-        return;
-
-    HRESULT hr = renderTarget->EndDraw();
-    RELEASE_ASSERT(SUCCEEDED(hr));
-
-    COMPtr<ID2D1Bitmap> bitmap;
-    hr = renderTarget->GetBitmap(&bitmap);
-    RELEASE_ASSERT(SUCCEEDED(hr));
-
-    auto context = this->renderTarget();
-
-    if (currentLayer.hasShadow)
-        drawWithShadowHelper(context, bitmap.get(), currentLayer.shadowColor, currentLayer.shadowOffset, currentLayer.shadowBlur);
-    else {
-        COMPtr<ID2D1BitmapBrush> bitmapBrush;
-        auto bitmapBrushProperties = D2D1::BitmapBrushProperties();
-        auto brushProperties = D2D1::BrushProperties();
-        HRESULT hr = context->CreateBitmapBrush(bitmap.get(), bitmapBrushProperties, brushProperties, &bitmapBrush);
-        RELEASE_ASSERT(SUCCEEDED(hr));
-
-        auto size = bitmap->GetSize();
-        auto rectInDIP = D2D1::RectF(0, 0, size.width, size.height);
-        context->FillRectangle(rectInDIP, bitmapBrush.get());
-    }
-}
-
-void GraphicsContext::endPlatformTransparencyLayer()
-{
-    if (paintingDisabled())
-        return;
-
-    m_data->endTransparencyLayer();
-
-    ASSERT(!isRecording());
-
-    m_state.alpha = m_data->currentGlobalAlpha();
-
-    restore();
-}
-
-bool GraphicsContext::supportsTransparencyLayers()
-{
-    return false;
-}
-
-void GraphicsContext::setPlatformShadow(const FloatSize& offset, float blur, const Color& color)
-{
-    (void)offset;
-    (void)blur;
-    (void)color;
-    notImplemented();
-}
-
-void GraphicsContext::clearPlatformShadow()
-{
-    if (paintingDisabled())
-        return;
-    notImplemented();
-}
-
-void GraphicsContext::setPlatformStrokeStyle(StrokeStyle style)
-{
-    if (paintingDisabled())
-        return;
-
-    m_data->setStrokeStyle(style);
-}
-
-void GraphicsContext::setMiterLimit(float limit)
-{
-    if (paintingDisabled())
-        return;
-
-    if (isRecording()) {
-        // Maybe this should be part of the state.
-        m_displayListRecorder->setMiterLimit(limit);
-        return;
-    }
-
-    m_data->setMiterLimit(limit);
-}
-
-void GraphicsContext::clearRect(const FloatRect& rect)
-{
-    if (paintingDisabled())
-        return;
-
-    if (isRecording()) {
-        m_displayListRecorder->clearRect(rect);
-        return;
-    }
-
-    drawWithoutShadow(rect, [this, rect](ID2D1RenderTarget* renderTarget) {
-        FloatRect renderTargetRect(FloatPoint(), renderTarget->GetSize());
-        FloatRect rectToClear(rect);
-
-        if (rectToClear.contains(renderTargetRect)) {
-            renderTarget->SetTags(1, __LINE__);
-            renderTarget->Clear(D2D1::ColorF(0, 0, 0, 0));
-            return;
-        }
-
-        if (!rectToClear.intersects(renderTargetRect))
-            return;
-
-        renderTarget->SetTags(1, __LINE__);
-        rectToClear.intersect(renderTargetRect);
-        renderTarget->FillRectangle(rectToClear, brushWithColor(Color(D2D1::ColorF(0, 0, 0, 0))));
-    });
-}
-
-void GraphicsContext::strokeRect(const FloatRect& rect, float lineWidth)
-{
-    if (paintingDisabled())
-        return;
-
-    if (isRecording()) {
-        m_displayListRecorder->strokeRect(rect, lineWidth);
-        return;
-    }
-
-    if (m_state.strokeGradient) {
-        auto drawFunction = [this, rect, lineWidth](ID2D1RenderTarget* renderTarget) {
-            renderTarget->SetTags(1, __LINE__);
-            const D2D1_RECT_F d2dRect = rect;
-            renderTarget->DrawRectangle(&d2dRect, m_state.strokeGradient->createPlatformGradientIfNecessary(renderTarget), lineWidth, m_data->strokeStyle());
-        };
-
-        if (hasShadow())
-            drawWithShadow(rect, drawFunction);
-        else
-            drawWithoutShadow(rect, drawFunction);
-        return;
-    }
-
-    if (m_state.strokePattern)
-        applyStrokePattern();
-
-    drawWithoutShadow(rect, [this, rect, lineWidth](ID2D1RenderTarget* renderTarget) {
-        renderTarget->SetTags(1, __LINE__);
-        const D2D1_RECT_F d2dRect = rect;
-        auto brush = m_state.strokePattern ? patternStrokeBrush() : solidStrokeBrush();
-        renderTarget->DrawRectangle(&d2dRect, brush, lineWidth, m_data->strokeStyle());
-    });
-}
-
-void GraphicsContext::setLineCap(LineCap cap)
-{
-    if (paintingDisabled())
-        return;
-
-    if (isRecording()) {
-        m_displayListRecorder->setLineCap(cap);
-        return;
-    }
-
-    m_data->setLineCap(cap);
-}
-
-void GraphicsContext::setLineDash(const DashArray& dashes, float dashOffset)
-{
-    if (paintingDisabled())
-        return;
-
-    if (isRecording()) {
-        m_displayListRecorder->setLineDash(dashes, dashOffset);
-        return;
-    }
-
-    if (dashOffset < 0) {
-        float length = 0;
-        for (size_t i = 0; i < dashes.size(); ++i)
-            length += static_cast<float>(dashes[i]);
-        if (length)
-            dashOffset = fmod(dashOffset, length) + length;
-    }
-
-    m_data->setDashes(dashes);
-    m_data->setDashOffset(dashOffset);
-}
-
-void GraphicsContext::setLineJoin(LineJoin join)
-{
-    if (paintingDisabled())
-        return;
-
-    if (isRecording()) {
-        m_displayListRecorder->setLineJoin(join);
-        return;
-    }
-
-    m_data->setLineJoin(join);
-}
-
-void GraphicsContext::canvasClip(const Path& path, WindRule fillRule)
-{
-    clipPath(path, fillRule);
-}
-
-void GraphicsContext::scale(const FloatSize& size)
-{
-    if (paintingDisabled())
-        return;
-
-    if (isRecording()) {
-        m_displayListRecorder->scale(size);
-        return;
-    }
-
-    m_data->scale(size);
-    // FIXME: m_data->m_userToDeviceTransformKnownToBeIdentity = false;
-}
-
-void GraphicsContext::rotate(float angle)
-{
-    if (paintingDisabled())
-        return;
-
-    if (isRecording()) {
-        m_displayListRecorder->rotate(angle);
-        return;
-    }
-
-    m_data->rotate(angle);
-    // FIXME: m_data->m_userToDeviceTransformKnownToBeIdentity = false;
-}
-
-void GraphicsContext::translate(float x, float y)
-{
-    if (paintingDisabled())
-        return;
-
-    if (isRecording()) {
-        m_displayListRecorder->translate(x, y);
-        return;
-    }
-
-    m_data->translate(x, y);
-    // FIXME: m_data->m_userToDeviceTransformKnownToBeIdentity = false;
-}
-
-void GraphicsContext::concatCTM(const AffineTransform& transform)
-{
-    if (paintingDisabled())
-        return;
-
-    if (isRecording()) {
-        m_displayListRecorder->concatCTM(transform);
-        return;
-    }
-
-    m_data->concatCTM(transform);
-    // FIXME: m_data->m_userToDeviceTransformKnownToBeIdentity = false;
-}
-
-void GraphicsContext::setCTM(const AffineTransform& transform)
-{
-    if (paintingDisabled())
-        return;
-
-    if (isRecording()) {
-        WTFLogAlways("GraphicsContext::setCTM() is not compatible with recording contexts.");
-        return;
-    }
-
-    m_data->setCTM(transform);
-    // FIXME: m_data->m_userToDeviceTransformKnownToBeIdentity = false;
-}
-
-AffineTransform GraphicsContext::getCTM(IncludeDeviceScale includeScale) const
-{
-    if (paintingDisabled())
-        return AffineTransform();
-
-    if (isRecording()) {
-        WTFLogAlways("GraphicsContext::getCTM() is not yet compatible with recording contexts.");
-        return AffineTransform();
-    }
-
-    D2D1_MATRIX_3X2_F currentTransform;
-    platformContext()->GetTransform(&currentTransform);
-    return currentTransform;
-}
-
-FloatRect GraphicsContext::roundToDevicePixels(const FloatRect& rect, RoundingMode roundingMode)
-{
-    if (paintingDisabled())
-        return rect;
-
-    if (isRecording()) {
-        WTFLogAlways("GraphicsContext::roundToDevicePixels() is not yet compatible with recording contexts.");
-        return rect;
-    }
-
-    notImplemented();
-
-    return rect;
-}
-
-void GraphicsContext::drawLineForText(const FloatPoint& point, float width, bool printing, bool doubleLines, StrokeStyle strokeStyle)
-{
-    DashArray widths;
-    widths.append(width);
-    widths.append(0);
-    drawLinesForText(point, widths, printing, doubleLines, strokeStyle);
-}
-
-void GraphicsContext::drawLinesForText(const FloatPoint& point, const DashArray& widths, bool printing, bool doubleLines, StrokeStyle strokeStyle)
-{
-    if (paintingDisabled())
-        return;
-
-    if (!widths.size())
-        return;
-
-    if (isRecording()) {
-        m_displayListRecorder->drawLinesForText(point, widths, printing, doubleLines, strokeThickness());
-        return;
-    }
-
-    notImplemented();
-}
-
-void GraphicsContext::setURLForRect(const URL& link, const FloatRect& destRect)
-{
-    if (paintingDisabled())
-        return;
-
-    if (isRecording()) {
-        WTFLogAlways("GraphicsContext::setURLForRect() is not yet compatible with recording contexts.");
-        return; // FIXME for display lists.
-    }
-
-    RetainPtr<CFURLRef> urlRef = link.createCFURL();
-    if (!urlRef)
-        return;
-
-    notImplemented();
-}
-
-void GraphicsContext::setPlatformImageInterpolationQuality(InterpolationQuality mode)
-{
-    ASSERT(!paintingDisabled());
-
-    D2D1_INTERPOLATION_MODE quality = D2D1_INTERPOLATION_MODE_NEAREST_NEIGHBOR;
-
-    switch (mode) {
-    case InterpolationDefault:
-        quality = D2D1_INTERPOLATION_MODE_NEAREST_NEIGHBOR;
-        break;
-    case InterpolationNone:
-        quality = D2D1_INTERPOLATION_MODE_NEAREST_NEIGHBOR;
-        break;
-    case InterpolationLow:
-        quality = D2D1_INTERPOLATION_MODE_LINEAR;
-        break;
-    case InterpolationMedium:
-        quality = D2D1_INTERPOLATION_MODE_CUBIC;
-        break;
-    case InterpolationHigh:
-        quality = D2D1_INTERPOLATION_MODE_HIGH_QUALITY_CUBIC;
-        break;
-    }
-    // FIXME: SetInterpolationQuality(platformContext(), quality);
-}
-
-void GraphicsContext::setIsCALayerContext(bool isLayerContext)
-{
-    if (paintingDisabled())
-        return;
-
-    if (isRecording())
-        return;
-
-    // This function is probabaly not needed.
-    notImplemented();
-}
-
-bool GraphicsContext::isCALayerContext() const
-{
-    if (paintingDisabled())
-        return false;
-
-    // FIXME
-    if (isRecording())
-        return false;
-
-    // This function is probabaly not needed.
-    notImplemented();
-    return false;
-}
-
-void GraphicsContext::setIsAcceleratedContext(bool isAccelerated)
-{
-    if (paintingDisabled())
-        return;
-
-    // FIXME
-    if (isRecording())
-        return;
-
-    notImplemented();
-}
-
-bool GraphicsContext::isAcceleratedContext() const
-{
-    if (paintingDisabled())
-        return false;
-
-    // FIXME
-    if (isRecording())
-        return false;
-
-    // This function is probabaly not needed.
-    notImplemented();
-    return false;
-}
-
-void GraphicsContext::setPlatformTextDrawingMode(TextDrawingModeFlags mode)
-{
-    (void)mode;
-    notImplemented();
-}
-
-void GraphicsContext::setPlatformStrokeColor(const Color& color)
-{
-    ASSERT(m_state.strokeColor == color);
-
-    m_data->m_solidStrokeBrush = nullptr;
-
-    m_data->m_solidStrokeBrush = brushWithColor(strokeColor());
-}
-
-void GraphicsContext::setPlatformStrokeThickness(float thickness)
-{
-    ASSERT(m_state.strokeThickness == thickness);
-    m_data->setStrokeThickness(thickness);
-}
-
-void GraphicsContext::setPlatformFillColor(const Color& color)
-{
-    ASSERT(m_state.fillColor == color);
-
-    m_data->m_solidFillBrush = nullptr;
-
-    m_data->m_solidFillBrush = brushWithColor(fillColor());
-}
-
-void GraphicsContext::setPlatformShouldAntialias(bool enable)
-{
-    if (paintingDisabled())
-        return;
-
-    ASSERT(!isRecording());
-
-    auto antialiasMode = enable ? D2D1_ANTIALIAS_MODE_PER_PRIMITIVE : D2D1_ANTIALIAS_MODE_ALIASED;
-    platformContext()->SetAntialiasMode(antialiasMode);
-}
-
-void GraphicsContext::setPlatformShouldSmoothFonts(bool enable)
-{
-    if (paintingDisabled())
-        return;
-
-    ASSERT(!isRecording());
-
-    auto fontSmoothingMode = enable ? D2D1_TEXT_ANTIALIAS_MODE_CLEARTYPE : D2D1_TEXT_ANTIALIAS_MODE_ALIASED;
-    platformContext()->SetTextAntialiasMode(fontSmoothingMode);
-}
-
-void GraphicsContext::setPlatformAlpha(float alpha)
-{
-    if (paintingDisabled())
-        return;
-
-    ASSERT(m_state.alpha == alpha);
-    m_data->setAlpha(alpha);
-}
-
-void GraphicsContext::setPlatformCompositeOperation(CompositeOperator mode, BlendMode blendMode)
-{
-    if (paintingDisabled())
-        return;
-
-    ASSERT(!isRecording());
-
-    D2D1_BLEND_MODE targetBlendMode = D2D1_BLEND_MODE_SCREEN;
-    D2D1_COMPOSITE_MODE targetCompositeMode = D2D1_COMPOSITE_MODE_SOURCE_ATOP; // ???
-
-    if (blendMode != BlendModeNormal) {
-        switch (blendMode) {
-        case BlendModeMultiply:
-            targetBlendMode = D2D1_BLEND_MODE_MULTIPLY;
-            break;
-        case BlendModeScreen:
-            targetBlendMode = D2D1_BLEND_MODE_SCREEN;
-            break;
-        case BlendModeOverlay:
-            targetBlendMode = D2D1_BLEND_MODE_OVERLAY;
-            break;
-        case BlendModeDarken:
-            targetBlendMode = D2D1_BLEND_MODE_DARKEN;
-            break;
-        case BlendModeLighten:
-            targetBlendMode = D2D1_BLEND_MODE_LIGHTEN;
-            break;
-        case BlendModeColorDodge:
-            targetBlendMode = D2D1_BLEND_MODE_COLOR_DODGE;
-            break;
-        case BlendModeColorBurn:
-            targetBlendMode = D2D1_BLEND_MODE_COLOR_BURN;
-            break;
-        case BlendModeHardLight:
-            targetBlendMode = D2D1_BLEND_MODE_HARD_LIGHT;
-            break;
-        case BlendModeSoftLight:
-            targetBlendMode = D2D1_BLEND_MODE_SOFT_LIGHT;
-            break;
-        case BlendModeDifference:
-            targetBlendMode = D2D1_BLEND_MODE_DIFFERENCE;
-            break;
-        case BlendModeExclusion:
-            targetBlendMode = D2D1_BLEND_MODE_EXCLUSION;
-            break;
-        case BlendModeHue:
-            targetBlendMode = D2D1_BLEND_MODE_HUE;
-            break;
-        case BlendModeSaturation:
-            targetBlendMode = D2D1_BLEND_MODE_SATURATION;
-            break;
-        case BlendModeColor:
-            targetBlendMode = D2D1_BLEND_MODE_COLOR;
-            break;
-        case BlendModeLuminosity:
-            targetBlendMode = D2D1_BLEND_MODE_LUMINOSITY;
-            break;
-        case BlendModePlusDarker:
-            targetBlendMode = D2D1_BLEND_MODE_DARKER_COLOR;
-            break;
-        case BlendModePlusLighter:
-            targetBlendMode = D2D1_BLEND_MODE_LIGHTER_COLOR;
-            break;
-        default:
-            break;
-        }
-    } else {
-        switch (mode) {
-        case CompositeClear:
-            // FIXME: targetBlendMode = D2D1_BLEND_MODE_CLEAR;
-            break;
-        case CompositeCopy:
-            // FIXME: targetBlendMode = D2D1_BLEND_MODE_COPY;
-            break;
-        case CompositeSourceOver:
-            // FIXME: kCGBlendModeNormal
-            break;
-        case CompositeSourceIn:
-            targetCompositeMode = D2D1_COMPOSITE_MODE_SOURCE_IN;
-            break;
-        case CompositeSourceOut:
-            targetCompositeMode = D2D1_COMPOSITE_MODE_SOURCE_OUT;
-            break;
-        case CompositeSourceAtop:
-            targetCompositeMode = D2D1_COMPOSITE_MODE_SOURCE_ATOP;
-            break;
-        case CompositeDestinationOver:
-            targetCompositeMode = D2D1_COMPOSITE_MODE_DESTINATION_OVER;
-            break;
-        case CompositeDestinationIn:
-            targetCompositeMode = D2D1_COMPOSITE_MODE_DESTINATION_IN;
-            break;
-        case CompositeDestinationOut:
-            targetCompositeMode = D2D1_COMPOSITE_MODE_DESTINATION_OUT;
-            break;
-        case CompositeDestinationAtop:
-            targetCompositeMode = D2D1_COMPOSITE_MODE_DESTINATION_ATOP;
-            break;
-        case CompositeXOR:
-            targetCompositeMode = D2D1_COMPOSITE_MODE_XOR;
-            break;
-        case CompositePlusDarker:
-            targetBlendMode = D2D1_BLEND_MODE_DARKER_COLOR;
-            break;
-        case CompositePlusLighter:
-            targetBlendMode = D2D1_BLEND_MODE_LIGHTER_COLOR;
-            break;
-        case CompositeDifference:
-            targetBlendMode = D2D1_BLEND_MODE_DIFFERENCE;
-            break;
-        }
-    }
-
-    m_data->m_blendMode = targetBlendMode;
-    m_data->m_compositeMode = targetCompositeMode;
-}
-
-void GraphicsContext::platformApplyDeviceScaleFactor(float deviceScaleFactor)
-{
-    // This is a no-op for Direct2D.
-}
-
-void GraphicsContext::platformFillEllipse(const FloatRect& ellipse)
-{
-    if (paintingDisabled())
-        return;
-
-    ASSERT(!isRecording());
-
-    if (m_state.fillGradient || m_state.fillPattern) {
-        // FIXME: We should be able to fill ellipses with pattern/gradient brushes in D2D.
-        fillEllipseAsPath(ellipse);
-        return;
-    }
-
-    auto d2dEllipse = D2D1::Ellipse(ellipse.center(), 0.5 * ellipse.width(), 0.5 * ellipse.height());
-
-    platformContext()->SetTags(1, __LINE__);
-
-    drawWithoutShadow(ellipse, [this, d2dEllipse](ID2D1RenderTarget* renderTarget) {
-        renderTarget->FillEllipse(&d2dEllipse, solidFillBrush());
-    });
-}
-
-void GraphicsContext::platformStrokeEllipse(const FloatRect& ellipse)
-{
-    if (paintingDisabled())
-        return;
-
-    ASSERT(!isRecording());
-
-    if (m_state.strokeGradient || m_state.strokePattern) {
-        // FIXME: We should be able to stroke ellipses with pattern/gradient brushes in D2D.
-        strokeEllipseAsPath(ellipse);
-        return;
-    }
-
-    auto d2dEllipse = D2D1::Ellipse(ellipse.center(), 0.5 * ellipse.width(), 0.5 * ellipse.height());
-
-    platformContext()->SetTags(1, __LINE__);
-
-    drawWithoutShadow(ellipse, [this, d2dEllipse](ID2D1RenderTarget* renderTarget) {
-        renderTarget->DrawEllipse(&d2dEllipse, solidStrokeBrush(), strokeThickness(), m_data->strokeStyle());
-    });
-}
-
-}
diff --git a/Source/WebCore/platform/graphics/win/GraphicsContextPlatformPrivateDirect2D.h b/Source/WebCore/platform/graphics/win/GraphicsContextPlatformPrivateDirect2D.h
deleted file mode 100644
index 74278305dfe..00000000000
--- a/Source/WebCore/platform/graphics/win/GraphicsContextPlatformPrivateDirect2D.h
+++ /dev/null
@@ -1,175 +0,0 @@
-/*
- * Copyright (C) 2016 Apple Inc. All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS'' AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
- * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#pragma once
-
-#include "COMPtr.h"
-#include "Color.h"
-#include <d2d1.h>
-#include <d2d1_1.h>
-#include <d2d1effects.h>
-#include <d2d1helper.h>
-#include <windows.h>
-#include <wtf/TinyLRUCache.h>
-
-namespace WebCore {
-
-class GraphicsContextPlatformPrivate {
-    WTF_MAKE_FAST_ALLOCATED;
-public:
-    GraphicsContextPlatformPrivate(ID2D1RenderTarget*);
-    ~GraphicsContextPlatformPrivate();
-
-    enum Direct2DLayerType { AxisAlignedClip, LayerClip };
-
-    void beginTransparencyLayer(float opacity);
-    void endTransparencyLayer();
-
-    void clip(const FloatRect&);
-    void clip(const Path&);
-    void clip(ID2D1Geometry*);
-
-    void beginDraw();
-    void endDraw();
-    void flush();
-    void save();
-    void scale(const FloatSize&);
-    void restore();
-    void rotate(float);
-    void translate(float, float);
-    void concatCTM(const AffineTransform&);
-    void setCTM(const AffineTransform&);
-
-    void setLineCap(LineCap);
-    void setLineJoin(LineJoin);
-    void setStrokeStyle(StrokeStyle);
-    void setMiterLimit(float);
-    void setDashOffset(float);
-    void setPatternWidth(float);
-    void setPatternOffset(float);
-    void setStrokeThickness(float);
-    void setDashes(const DashArray&);
-    void setAlpha(float);
-
-    ID2D1RenderTarget* renderTarget();
-    ID2D1Layer* clipLayer() const { return m_renderStates.last().m_activeLayer.get(); }
-    ID2D1StrokeStyle* strokeStyle();
-
-    COMPtr<ID2D1SolidColorBrush> brushWithColor(const D2D1_COLOR_F&);
-
-    HDC m_hdc { nullptr };
-    D2D1_BLEND_MODE m_blendMode { D2D1_BLEND_MODE_MULTIPLY };
-    D2D1_COMPOSITE_MODE m_compositeMode { D2D1_COMPOSITE_MODE_SOURCE_OVER };
-    bool m_shouldIncludeChildWindows { false };
-    bool m_strokeSyleIsDirty { false };
-
-    COMPtr<ID2D1SolidColorBrush> m_solidStrokeBrush;
-    COMPtr<ID2D1SolidColorBrush> m_solidFillBrush;
-    COMPtr<ID2D1BitmapBrush> m_patternStrokeBrush;
-    COMPtr<ID2D1BitmapBrush> m_patternFillBrush;
-
-    float currentGlobalAlpha() const;
-
-private:
-    void recomputeStrokeStyle();
-
-    COMPtr<ID2D1RenderTarget> m_renderTarget;
-    HashMap<RGBA32, COMPtr<ID2D1SolidColorBrush>> m_solidColoredBrushCache;
-    COMPtr<ID2D1SolidColorBrush> m_whiteBrush;
-    COMPtr<ID2D1SolidColorBrush> m_zeroBrush;
-    COMPtr<ID2D1StrokeStyle> m_d2dStrokeStyle;
-
-    struct RenderState {
-        COMPtr<ID2D1DrawingStateBlock> m_drawingStateBlock;
-        COMPtr<ID2D1Layer> m_activeLayer;
-        Vector<Direct2DLayerType> m_clips;
-    };
-
-    Vector<RenderState> m_renderStates;
-
-    struct TransparencyLayerState {
-        COMPtr<ID2D1BitmapRenderTarget> renderTarget;
-        Color shadowColor;
-        FloatSize shadowOffset;
-        float opacity { 1.0 };
-        float shadowBlur { 0 };
-        bool hasShadow { false };
-    };
-    Vector<TransparencyLayerState> m_transparencyLayerStack;
-
-    D2D1_CAP_STYLE m_lineCap { D2D1_CAP_STYLE_FLAT };
-    D2D1_LINE_JOIN m_lineJoin { D2D1_LINE_JOIN_MITER };
-    StrokeStyle m_strokeStyle { SolidStroke };
-    DashArray m_dashes;
-
-    float m_miterLimit { 1.0f };
-    float m_dashOffset { 0 };
-    float m_patternWidth { 1.0f };
-    float m_patternOffset { 0 };
-    float m_strokeThickness { 0 };
-    float m_alpha { 1.0 };
-};
-
-class D2DContextStateSaver {
-public:
-    D2DContextStateSaver(GraphicsContextPlatformPrivate& context, bool saveAndRestore = true)
-        : m_context(context)
-        , m_saveAndRestore(saveAndRestore)
-    {
-        if (m_saveAndRestore)
-            m_context.save();
-    }
-
-    ~D2DContextStateSaver()
-    {
-        if (m_saveAndRestore)
-            m_context.restore();
-    }
-
-    void save()
-    {
-        ASSERT(!m_saveAndRestore);
-        m_context.save();
-        m_saveAndRestore = true;
-    }
-
-    void restore()
-    {
-        ASSERT(m_saveAndRestore);
-        m_context.restore();
-        m_saveAndRestore = false;
-    }
-
-    bool didSave() const
-    {
-        return m_saveAndRestore;
-    }
-
-private:
-    GraphicsContextPlatformPrivate& m_context;
-    bool m_saveAndRestore { false };
-};
-
-}
diff --git a/Source/WebCore/platform/graphics/win/GraphicsContextWin.cpp b/Source/WebCore/platform/graphics/win/GraphicsContextWin.cpp
index 9cad16c5282..54cba34c6d3 100644
--- a/Source/WebCore/platform/graphics/win/GraphicsContextWin.cpp
+++ b/Source/WebCore/platform/graphics/win/GraphicsContextWin.cpp
@@ -28,8 +28,6 @@
 
 #if USE(CG)
 #include "GraphicsContextPlatformPrivateCG.h"
-#elif USE(DIRECT2D)
-#include "GraphicsContextPlatformPrivateDirect2D.h"
 #elif USE(CAIRO)
 #include "GraphicsContextPlatformPrivateCairo.h"
 #endif
@@ -146,7 +144,7 @@ HDC GraphicsContext::hdc() const
     return m_data->m_hdc;
 }
 
-#if PLATFORM(WIN) && !USE(DIRECT2D)
+#if PLATFORM(WIN)
 void GraphicsContextPlatformPrivate::save()
 {
     if (!m_hdc)
diff --git a/Source/WebCore/platform/graphics/win/ImageBufferDataDirect2D.cpp b/Source/WebCore/platform/graphics/win/ImageBufferDataDirect2D.cpp
index fd3d4e73d4a..a2a4a592a7b 100644
--- a/Source/WebCore/platform/graphics/win/ImageBufferDataDirect2D.cpp
+++ b/Source/WebCore/platform/graphics/win/ImageBufferDataDirect2D.cpp
@@ -33,6 +33,7 @@
 #include "HWndDC.h"
 #include "IntRect.h"
 #include "NotImplemented.h"
+#include "RenderTargetScopedDrawing.h"
 #include <d2d1.h>
 #include <runtime/JSCInlines.h>
 #include <runtime/TypedArrayInlines.h>
@@ -63,18 +64,24 @@ RefPtr<Uint8ClampedArray> ImageBufferData::getData(const IntRect& rect, const In
     auto bitmapDC = adoptGDIObject(::CreateCompatibleDC(windowDC));
     HGDIOBJ oldBitmap = ::SelectObject(bitmapDC.get(), bitmap.get());
 
-    COMPtr<ID2D1GdiInteropRenderTarget> gdiRenderTarget;
-    HRESULT hr = platformContext->QueryInterface(__uuidof(ID2D1GdiInteropRenderTarget), (void**)&gdiRenderTarget);
-    if (FAILED(hr))
-        return nullptr;
+    BOOL ok = TRUE;
+
+    {
+        RenderTargetScopedDrawing scopedDraw(*context);
 
-    HDC hdc = nullptr;
-    hr = gdiRenderTarget->GetDC(D2D1_DC_INITIALIZE_MODE_COPY, &hdc);
+        COMPtr<ID2D1GdiInteropRenderTarget> gdiRenderTarget;
+        HRESULT hr = platformContext->QueryInterface(__uuidof(ID2D1GdiInteropRenderTarget), (void**)&gdiRenderTarget);
+        if (FAILED(hr))
+            return nullptr;
 
-    BOOL ok = ::BitBlt(bitmapDC.get(), 0, 0, rect.width(), rect.height(), hdc, rect.x(), rect.y(), SRCCOPY);
+        HDC hdc = nullptr;
+        hr = gdiRenderTarget->GetDC(D2D1_DC_INITIALIZE_MODE_COPY, &hdc);
 
-    RECT updateRect = { 0, 0, 0, 0 };
-    hr = gdiRenderTarget->ReleaseDC(&updateRect);
+        ok = ::BitBlt(bitmapDC.get(), 0, 0, rect.width(), rect.height(), hdc, rect.x(), rect.y(), SRCCOPY);
+
+        RECT updateRect = { 0, 0, 0, 0 };
+        hr = gdiRenderTarget->ReleaseDC(&updateRect);
+    }
 
     if (!ok)
         return nullptr;
diff --git a/Source/WebCore/platform/graphics/win/ImageBufferDataDirect2D.h b/Source/WebCore/platform/graphics/win/ImageBufferDataDirect2D.h
deleted file mode 100644
index bbf3c726577..00000000000
--- a/Source/WebCore/platform/graphics/win/ImageBufferDataDirect2D.h
+++ /dev/null
@@ -1,50 +0,0 @@
-/*
- * Copyright (C) 2016 Apple Inc. All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS'' AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
- * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#include "Image.h"
-#include "IntSize.h"
-#include <runtime/Uint8ClampedArray.h>
-#include <wtf/CheckedArithmetic.h>
-#include <wtf/RefPtr.h>
-#include <wtf/RetainPtr.h>
-
-interface ID2D1RenderTarget;
-
-namespace WebCore {
-
-struct ImageBufferData {
-    IntSize backingStoreSize;
-    Checked<unsigned, RecordOverflow> bytesPerRow;
-
-    // Only for software ImageBuffers.
-    void* data { nullptr };
-    std::unique_ptr<GraphicsContext> context;
-    ID2D1RenderTarget* m_compatibleTarget { nullptr };
-
-    RefPtr<Uint8ClampedArray> getData(const IntRect&, const IntSize&, bool accelerateRendering, bool unmultiplied, float resolutionScale) const;
-    void putData(Uint8ClampedArray*& source, const IntSize& sourceSize, const IntRect& sourceRect, const IntPoint& destPoint, const IntSize&, bool accelerateRendering, bool unmultiplied, float resolutionScale);
-};
-
-} // namespace WebCore
diff --git a/Source/WebCore/platform/graphics/win/ImageBufferDirect2D.cpp b/Source/WebCore/platform/graphics/win/ImageBufferDirect2D.cpp
index 710a0bbf4d9..35cfefa4dc9 100644
--- a/Source/WebCore/platform/graphics/win/ImageBufferDirect2D.cpp
+++ b/Source/WebCore/platform/graphics/win/ImageBufferDirect2D.cpp
@@ -44,6 +44,10 @@
 #include <wtf/text/Base64.h>
 #include <wtf/text/WTFString.h>
 
+#if PLATFORM(COCOA)
+#include "WebCoreSystemInterface.h"
+#endif
+
 
 namespace WebCore {
 
@@ -62,7 +66,7 @@ std::unique_ptr<ImageBuffer> ImageBuffer::createCompatibleBuffer(const FloatSize
     RenderingMode renderingMode = context.renderingMode();
     IntSize scaledSize = ImageBuffer::compatibleBufferSize(size, context);
     bool success = false;
-    std::unique_ptr<ImageBuffer> buffer(new ImageBuffer(scaledSize, 1, ColorSpaceSRGB, renderingMode, &context, success));
+    std::unique_ptr<ImageBuffer> buffer(new ImageBuffer(scaledSize, 1, ColorSpaceSRGB, renderingMode, context.platformContext(), success));
 
     if (!success)
         return nullptr;
@@ -72,7 +76,7 @@ std::unique_ptr<ImageBuffer> ImageBuffer::createCompatibleBuffer(const FloatSize
     return buffer;
 }
 
-ImageBuffer::ImageBuffer(const FloatSize& size, float resolutionScale, ColorSpace /*colorSpace*/, RenderingMode renderingMode, const GraphicsContext* targetContext, bool& success)
+ImageBuffer::ImageBuffer(const FloatSize& size, float resolutionScale, ColorSpace /*colorSpace*/, RenderingMode renderingMode, ID2D1RenderTarget* renderTarget, bool& success)
     : m_logicalSize(size)
     , m_resolutionScale(resolutionScale)
 {
@@ -97,7 +101,6 @@ ImageBuffer::ImageBuffer(const FloatSize& size, float resolutionScale, ColorSpac
     if (numBytes.hasOverflowed())
         return;
 
-    auto renderTarget = targetContext ? targetContext->platformContext() : nullptr;
     if (!renderTarget)
         renderTarget = GraphicsContext::defaultRenderTarget();
     RELEASE_ASSERT(renderTarget);
@@ -136,7 +139,11 @@ GraphicsContext& ImageBuffer::context() const
 
 void ImageBuffer::flushContext() const
 {
-    context().flush();
+    if (!context().didBeginDraw())
+        return;
+
+    HRESULT hr = context().platformContext()->Flush();
+    ASSERT(SUCCEEDED(hr));
 }
 
 RefPtr<Image> ImageBuffer::copyImage(BackingStoreCopy copyBehavior, ScaleBehavior scaleBehavior) const
@@ -192,8 +199,6 @@ void ImageBuffer::draw(GraphicsContext& destContext, const FloatRect& destRect,
     adjustedSrcRect.scale(m_resolutionScale, m_resolutionScale);
 
     destContext.drawNativeImage(image, image->GetSize(), destRect, adjustedSrcRect, op, blendMode);
-
-    destContext.flush();
 }
 
 void ImageBuffer::drawPattern(GraphicsContext& destContext, const FloatRect& destRect, const FloatRect& srcRect, const AffineTransform& patternTransform, const FloatPoint& phase, const FloatSize& spacing, CompositeOperator op, BlendMode blendMode)
diff --git a/Source/WebCore/platform/graphics/win/ImageCGWin.cpp b/Source/WebCore/platform/graphics/win/ImageCGWin.cpp
index d11253adf70..9ac559c8157 100644
--- a/Source/WebCore/platform/graphics/win/ImageCGWin.cpp
+++ b/Source/WebCore/platform/graphics/win/ImageCGWin.cpp
@@ -26,8 +26,6 @@
 #include "config.h"
 #include "Image.h"
 
-#if USE(CG)
-
 #include "BitmapImage.h"
 #include "BitmapInfo.h"
 #include "GraphicsContextCG.h"
@@ -108,5 +106,3 @@ void BitmapImage::drawFrameMatchingSourceSize(GraphicsContext& ctxt, const Float
 }
 
 } // namespace WebCore
-
-#endif
diff --git a/Source/WebCore/platform/graphics/win/ImageDecoderDirect2D.cpp b/Source/WebCore/platform/graphics/win/ImageDecoderDirect2D.cpp
index 3fde832642b..5460987dd83 100644
--- a/Source/WebCore/platform/graphics/win/ImageDecoderDirect2D.cpp
+++ b/Source/WebCore/platform/graphics/win/ImageDecoderDirect2D.cpp
@@ -175,14 +175,14 @@ unsigned ImageDecoder::frameBytesAtIndex(size_t index, SubsamplingLevel subsampl
     return (frameSize.area() * 4).unsafeGet();
 }
 
-void ImageDecoder::setTargetContext(ID2D1RenderTarget* renderTarget)
+void ImageDecoder::setRenderTarget(ID2D1RenderTarget* renderTarget)
 {
     m_renderTarget = renderTarget;
 }
 
-NativeImagePtr ImageDecoder::createFrameImageAtIndex(size_t index, SubsamplingLevel subsamplingLevel, DecodingMode) const
+NativeImagePtr ImageDecoder::createFrameImageAtIndex(size_t index, SubsamplingLevel subsamplingLevel) const
 {
-    if (!m_nativeDecoder || !m_renderTarget)
+    if (!m_nativeDecoder)
         return nullptr;
 
     COMPtr<IWICBitmapFrameDecode> frame;
@@ -199,6 +199,10 @@ NativeImagePtr ImageDecoder::createFrameImageAtIndex(size_t index, SubsamplingLe
     if (!SUCCEEDED(hr))
         return nullptr;
 
+    ASSERT(m_renderTarget);
+    if (!m_renderTarget)
+        return nullptr;
+
     COMPtr<ID2D1Bitmap> bitmap;
     hr = m_renderTarget->CreateBitmapFromWicBitmap(converter.get(), nullptr, &bitmap);
     if (!SUCCEEDED(hr))
diff --git a/Source/WebCore/platform/graphics/win/ImageDecoderDirect2D.h b/Source/WebCore/platform/graphics/win/ImageDecoderDirect2D.h
deleted file mode 100644
index e5382670844..00000000000
--- a/Source/WebCore/platform/graphics/win/ImageDecoderDirect2D.h
+++ /dev/null
@@ -1,87 +0,0 @@
-/*
- * Copyright (C) 2016 Apple Inc. All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS'' AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
- * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#pragma once
-
-#include "COMPtr.h"
-#include "ImageSource.h"
-#include "IntSize.h"
-#include <wtf/Optional.h>
-
-interface ID2D1RenderTarget;
-interface IWICBitmapDecoder;
-interface IWICImagingFactory;
-
-namespace WebCore {
-
-class ImageDecoder {
-    WTF_MAKE_FAST_ALLOCATED;
-public:
-    ImageDecoder();
-    
-    static std::unique_ptr<ImageDecoder> create(const SharedBuffer&, AlphaOption, GammaAndColorProfileOption)
-    {
-        return std::make_unique<ImageDecoder>();
-    }
-    
-    static size_t bytesDecodedToDetermineProperties();
-    
-    String filenameExtension() const;
-    bool isSizeAvailable() const;
-    
-    // Always original size, without subsampling.
-    IntSize size() const;
-    size_t frameCount() const;
-
-    RepetitionCount repetitionCount() const;
-    Optional<IntPoint> hotSpot() const;
-    
-    IntSize frameSizeAtIndex(size_t, SubsamplingLevel = SubsamplingLevel::Default) const;
-    bool frameIsCompleteAtIndex(size_t) const;
-    ImageOrientation frameOrientationAtIndex(size_t) const;
-    
-    float frameDurationAtIndex(size_t) const;
-    bool frameHasAlphaAtIndex(size_t) const;
-    bool frameAllowSubsamplingAtIndex(size_t) const;
-    unsigned frameBytesAtIndex(size_t, SubsamplingLevel = SubsamplingLevel::Default) const;
-    
-    NativeImagePtr createFrameImageAtIndex(size_t, SubsamplingLevel = SubsamplingLevel::Default, DecodingMode = DecodingMode::OnDemand) const;
-    
-    void setData(SharedBuffer&, bool allDataReceived);
-    bool isAllDataReceived() const { return m_isAllDataReceived; }
-    void clearFrameBufferCache(size_t) { }
-
-    void setTargetContext(ID2D1RenderTarget*);
-
-    static IWICImagingFactory* systemImagingFactory();
-
-protected:
-    bool m_isAllDataReceived { false };
-    mutable IntSize m_size;
-    COMPtr<IWICBitmapDecoder> m_nativeDecoder;
-    COMPtr<ID2D1RenderTarget> m_renderTarget;
-};
-
-}
diff --git a/Source/WebCore/platform/graphics/win/ImageDirect2D.cpp b/Source/WebCore/platform/graphics/win/ImageDirect2D.cpp
deleted file mode 100644
index 2507c1cd42e..00000000000
--- a/Source/WebCore/platform/graphics/win/ImageDirect2D.cpp
+++ /dev/null
@@ -1,107 +0,0 @@
-/*
- * Copyright (C) 2006-2016 Apple Inc.  All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS'' AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
- * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#include "config.h"
-#include "Image.h"
-
-#include "BitmapImage.h"
-#include "BitmapInfo.h"
-#include "GraphicsContext.h"
-#include "ImageObserver.h"
-#include "NotImplemented.h"
-#include <d2d1.h>
-#include <windows.h>
-#include <wtf/RetainPtr.h>
-#include <wtf/text/WTFString.h>
-
-namespace WebCore {
-
-RefPtr<BitmapImage> BitmapImage::create(HBITMAP hBitmap)
-{
-    DIBSECTION dibSection;
-    if (!GetObject(hBitmap, sizeof(DIBSECTION), &dibSection))
-        return nullptr;
-
-    ASSERT(dibSection.dsBm.bmBitsPixel == 32);
-    if (dibSection.dsBm.bmBitsPixel != 32)
-        return nullptr;
-
-    ASSERT(dibSection.dsBm.bmBits);
-    if (!dibSection.dsBm.bmBits)
-        return nullptr;
-
-    notImplemented();
-
-    return nullptr;
-}
-
-bool BitmapImage::getHBITMAPOfSize(HBITMAP bmp, const IntSize* size)
-{
-    ASSERT(bmp);
-
-    BITMAP bmpInfo;
-    GetObject(bmp, sizeof(BITMAP), &bmpInfo);
-
-    ASSERT(bmpInfo.bmBitsPixel == 32);
-    int bufferSize = bmpInfo.bmWidthBytes * bmpInfo.bmHeight;
-    
-    notImplemented();
-
-    return true;
-}
-
-void BitmapImage::drawFrameMatchingSourceSize(GraphicsContext& ctxt, const FloatRect& dstRect, const IntSize& srcSize, CompositeOperator compositeOp)
-{
-    size_t frames = frameCount();
-    for (size_t i = 0; i < frames; ++i) {
-        auto image = frameImageAtIndex(i).get();
-        auto imageSize = image->GetSize();
-        if (image && clampTo<size_t>(imageSize.height) == static_cast<size_t>(srcSize.height()) && clampTo<size_t>(imageSize.width) == static_cast<size_t>(srcSize.width())) {
-            size_t currentFrame = m_currentFrame;
-            m_currentFrame = i;
-            draw(ctxt, dstRect, FloatRect(0.0f, 0.0f, srcSize.width(), srcSize.height()), compositeOp, BlendModeNormal, ImageOrientationDescription());
-            m_currentFrame = currentFrame;
-            return;
-        }
-    }
-
-    // No image of the correct size was found, fallback to drawing the current frame
-    FloatSize imageSize = BitmapImage::size();
-    draw(ctxt, dstRect, FloatRect(0.0f, 0.0f, imageSize.width(), imageSize.height()), compositeOp, BlendModeNormal, ImageOrientationDescription());
-}
-
-void Image::drawPattern(GraphicsContext& ctxt, const FloatRect& destRect, const FloatRect& tileRect, const AffineTransform& patternTransform,
-    const FloatPoint& phase, const FloatSize& spacing, CompositeOperator op, BlendMode blendMode)
-{
-    if (!nativeImageForCurrentFrame())
-        return;
-
-    ctxt.drawPattern(*this, destRect, tileRect, patternTransform, phase, spacing, op, blendMode);
-
-    if (imageObserver())
-        imageObserver()->didDraw(this);
-}
-
-} // namespace WebCore
diff --git a/Source/WebCore/platform/graphics/win/NativeImageDirect2D.cpp b/Source/WebCore/platform/graphics/win/NativeImageDirect2D.cpp
deleted file mode 100644
index 04a4e131bd5..00000000000
--- a/Source/WebCore/platform/graphics/win/NativeImageDirect2D.cpp
+++ /dev/null
@@ -1,103 +0,0 @@
-/*
- * Copyright (C) 2016 Apple Inc. All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS'' AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
- * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
- */
-
-#include "config.h"
-#include "NativeImage.h"
-
-#include "Color.h"
-#include "FloatRect.h"
-#include "GeometryUtilities.h"
-#include "GraphicsContext.h"
-#include "IntSize.h"
-#include "NotImplemented.h"
-#include <d2d1.h>
-
-namespace WebCore {
-
-IntSize nativeImageSize(const NativeImagePtr& image)
-{
-    return image ? IntSize(image->GetSize()) : IntSize();
-}
-
-bool nativeImageHasAlpha(const NativeImagePtr& image)
-{
-    if (!image)
-        return false;
-
-    auto alphaMode = image->GetPixelFormat().alphaMode;
-    return (alphaMode >= D2D1_ALPHA_MODE_PREMULTIPLIED) && (alphaMode <= D2D1_ALPHA_MODE_STRAIGHT);
-}
-
-Color nativeImageSinglePixelSolidColor(const NativeImagePtr& image)
-{
-    if (!image || nativeImageSize(image) != IntSize(1, 1))
-        return Color();
-
-    notImplemented();
-
-    return Color();
-}
-
-float subsamplingScale(GraphicsContext& context, const FloatRect& destRect, const FloatRect& srcRect)
-{
-    D2D1_MATRIX_3X2_F ctm;
-    context.platformContext()->GetTransform(&ctm);
-
-    AffineTransform transform(ctm);
-
-    auto transformedDestinationRect = transform.mapRect(destRect);
-    return std::min<float>(1, std::max(transformedDestinationRect.width() / srcRect.width(), transformedDestinationRect.height() / srcRect.height()));
-}
-
-void drawNativeImage(const NativeImagePtr& image, GraphicsContext& context, const FloatRect& destRect, const FloatRect& srcRect, const IntSize& srcSize, CompositeOperator compositeOp, BlendMode blendMode, const ImageOrientation& orientation)
-{
-    auto platformContext = context.platformContext();
-
-    // Subsampling may have given us an image that is smaller than size().
-    IntSize subsampledImageSize = nativeImageSize(image);
-
-    // srcRect is in the coordinates of the unsubsampled image, so we have to map it to the subsampled image.
-    FloatRect adjustedSrcRect = srcRect;
-    if (subsampledImageSize != srcSize)
-        adjustedSrcRect = mapRect(srcRect, FloatRect({ }, srcSize), FloatRect({ }, subsampledImageSize));
-
-    float opacity = 1.0f;
-
-    platformContext->DrawBitmap(image.get(), destRect, opacity, D2D1_BITMAP_INTERPOLATION_MODE_NEAREST_NEIGHBOR, adjustedSrcRect);
-    context.flush();
-}
-
-void clearNativeImageSubimages(const NativeImagePtr& image)
-{
-    notImplemented();
-
-#if CACHE_SUBIMAGES
-    if (image)
-        subimageCache().clearImage(image.get());
-#endif
-}
-
-
-}
diff --git a/Source/WebCore/platform/graphics/win/PatternDirect2D.cpp b/Source/WebCore/platform/graphics/win/PatternDirect2D.cpp
index 1b9229e8665..2f4fd4b9832 100644
--- a/Source/WebCore/platform/graphics/win/PatternDirect2D.cpp
+++ b/Source/WebCore/platform/graphics/win/PatternDirect2D.cpp
@@ -37,8 +37,12 @@
 
 namespace WebCore {
 
-ID2D1BitmapBrush* Pattern::createPlatformPattern(const GraphicsContext& context, float alpha, const AffineTransform& userSpaceTransformation) const
+ID2D1BitmapBrush* Pattern::createPlatformPattern(ID2D1RenderTarget* renderTarget, float alpha, const AffineTransform& userSpaceTransformation) const
 {
+    RELEASE_ASSERT(renderTarget);
+
+    FloatRect tileRect = tileImage()->rect();
+
     AffineTransform patternTransform = userSpaceTransformation * m_patternSpaceTransformation;
     auto bitmapBrushProperties = D2D1::BitmapBrushProperties();
     bitmapBrushProperties.extendModeX = m_repeatX ? D2D1_EXTEND_MODE_WRAP : D2D1_EXTEND_MODE_CLAMP;
@@ -48,14 +52,9 @@ ID2D1BitmapBrush* Pattern::createPlatformPattern(const GraphicsContext& context,
     brushProperties.transform = patternTransform;
     brushProperties.opacity = alpha;
 
-    auto patternImage = tileImage();
-
-    auto platformContext = context.platformContext();
-    RELEASE_ASSERT(platformContext);
-
     ID2D1BitmapBrush* patternBrush = nullptr;
-    HRESULT hr = platformContext->CreateBitmapBrush(patternImage->nativeImage(&context).get(), &bitmapBrushProperties, &brushProperties, &patternBrush);
-    ASSERT(SUCCEEDED(hr));
+    HRESULT hr = renderTarget->CreateBitmapBrush(tileImage()->nativeImage().get(), &bitmapBrushProperties, &brushProperties, &patternBrush);
+    ASSERT(hr);
     return patternBrush;
 }
 
diff --git a/Source/WebCore/platform/graphics/win/TransformationMatrixDirect2D.cpp b/Source/WebCore/platform/graphics/win/TransformationMatrixDirect2D.cpp
index bcab4bc0fe5..f81f9ecc685 100644
--- a/Source/WebCore/platform/graphics/win/TransformationMatrixDirect2D.cpp
+++ b/Source/WebCore/platform/graphics/win/TransformationMatrixDirect2D.cpp
@@ -72,4 +72,4 @@ AffineTransform::operator D2D1_MATRIX_3X2_F() const
 
 }
 
-#endif
+#endif // USE(DIRECT2D)
diff --git a/Source/WebCore/platform/image-decoders/ImageDecoder.cpp b/Source/WebCore/platform/image-decoders/ImageDecoder.cpp
index babda89a508..6ebcd4634a2 100644
--- a/Source/WebCore/platform/image-decoders/ImageDecoder.cpp
+++ b/Source/WebCore/platform/image-decoders/ImageDecoder.cpp
@@ -1,5 +1,4 @@
 /*
- * Copyright (C) 2016 Apple Inc.  All rights reserved.
  * Copyright (C) 2008-2009 Torch Mobile, Inc.
  * Copyright (C) Research In Motion Limited 2009-2010. All rights reserved.
  *
@@ -96,35 +95,138 @@ bool matchesCURSignature(char* contents)
 
 }
 
-std::unique_ptr<ImageDecoder> ImageDecoder::create(const SharedBuffer& data, AlphaOption alphaOption, GammaAndColorProfileOption gammaAndColorProfileOption)
+ImageDecoder* ImageDecoder::create(const SharedBuffer& data, ImageSource::AlphaOption alphaOption, ImageSource::GammaAndColorProfileOption gammaAndColorProfileOption)
 {
     static const unsigned lengthOfLongestSignature = 14; // To wit: "RIFF????WEBPVP"
     char contents[lengthOfLongestSignature];
     unsigned length = copyFromSharedBuffer(contents, lengthOfLongestSignature, data, 0);
     if (length < lengthOfLongestSignature)
-        return nullptr;
+        return 0;
 
     if (matchesGIFSignature(contents))
-        return std::unique_ptr<ImageDecoder> { std::make_unique<GIFImageDecoder>(alphaOption, gammaAndColorProfileOption) };
+        return new GIFImageDecoder(alphaOption, gammaAndColorProfileOption);
 
     if (matchesPNGSignature(contents))
-        return std::unique_ptr<ImageDecoder> { std::make_unique<PNGImageDecoder>(alphaOption, gammaAndColorProfileOption) };
+        return new PNGImageDecoder(alphaOption, gammaAndColorProfileOption);
 
     if (matchesICOSignature(contents) || matchesCURSignature(contents))
-        return std::unique_ptr<ImageDecoder> { std::make_unique<ICOImageDecoder>(alphaOption, gammaAndColorProfileOption) };
+        return new ICOImageDecoder(alphaOption, gammaAndColorProfileOption);
 
     if (matchesJPEGSignature(contents))
-        return std::unique_ptr<ImageDecoder> { std::make_unique<JPEGImageDecoder>(alphaOption, gammaAndColorProfileOption) };
+        return new JPEGImageDecoder(alphaOption, gammaAndColorProfileOption);
 
 #if USE(WEBP)
     if (matchesWebPSignature(contents))
-        return std::unique_ptr<ImageDecoder> { std::make_unique<WEBPImageDecoder>(alphaOption, gammaAndColorProfileOption) };
+        return new WEBPImageDecoder(alphaOption, gammaAndColorProfileOption);
 #endif
 
     if (matchesBMPSignature(contents))
-        return std::unique_ptr<ImageDecoder> { std::make_unique<BMPImageDecoder>(alphaOption, gammaAndColorProfileOption) };
+        return new BMPImageDecoder(alphaOption, gammaAndColorProfileOption);
+
+    return 0;
+}
+
+ImageFrame::ImageFrame()
+    : m_hasAlpha(false)
+    , m_status(FrameEmpty)
+    , m_duration(0)
+    , m_disposalMethod(DisposeNotSpecified)
+    , m_premultiplyAlpha(true)
+{
+} 
+
+ImageFrame& ImageFrame::operator=(const ImageFrame& other)
+{
+    if (this == &other)
+        return *this;
+
+    copyBitmapData(other);
+    setOriginalFrameRect(other.originalFrameRect());
+    setStatus(other.status());
+    setDuration(other.duration());
+    setDisposalMethod(other.disposalMethod());
+    setPremultiplyAlpha(other.premultiplyAlpha());
+    return *this;
+}
+
+void ImageFrame::clearPixelData()
+{
+    m_backingStore.clear();
+    m_bytes = 0;
+    m_status = FrameEmpty;
+    // NOTE: Do not reset other members here; clearFrameBufferCache() calls this
+    // to free the bitmap data, but other functions like initFrameBuffer() and
+    // frameComplete() may still need to read other metadata out of this frame
+    // later.
+}
+
+void ImageFrame::zeroFillPixelData()
+{
+    memset(m_bytes, 0, m_size.width() * m_size.height() * sizeof(PixelData));
+    m_hasAlpha = true;
+}
+
+void ImageFrame::zeroFillFrameRect(const IntRect& rect)
+{
+    ASSERT(IntRect(IntPoint(), m_size).contains(rect));
+
+    if (rect.isEmpty())
+        return;
+
+    size_t rectWidthInBytes = rect.width() * sizeof(PixelData);
+    PixelData* start = m_bytes + (rect.y() * width()) + rect.x();
+    for (int i = 0; i < rect.height(); ++i) {
+        memset(start, 0, rectWidthInBytes);
+        start += width();
+    }
+
+    setHasAlpha(true);
+}
+
+bool ImageFrame::copyBitmapData(const ImageFrame& other)
+{
+    if (this == &other)
+        return true;
+
+    m_backingStore = other.m_backingStore;
+    m_bytes = m_backingStore.data();
+    m_size = other.m_size;
+    setHasAlpha(other.m_hasAlpha);
+    return true;
+}
+
+bool ImageFrame::setSize(int newWidth, int newHeight)
+{
+    ASSERT(!width() && !height());
+    size_t backingStoreSize = newWidth * newHeight;
+    if (!m_backingStore.tryReserveCapacity(backingStoreSize))
+        return false;
+    m_backingStore.resize(backingStoreSize);
+    m_bytes = m_backingStore.data();
+    m_size = IntSize(newWidth, newHeight);
+
+    zeroFillPixelData();
+    return true;
+}
+
+bool ImageFrame::hasAlpha() const
+{
+    return m_hasAlpha;
+}
+
+void ImageFrame::setHasAlpha(bool alpha)
+{
+    m_hasAlpha = alpha;
+}
+
+void ImageFrame::setColorProfile(const ColorProfile& colorProfile)
+{
+    m_colorProfile = colorProfile;
+}
 
-    return nullptr;
+void ImageFrame::setStatus(FrameStatus status)
+{
+    m_status = status;
 }
 
 namespace {
@@ -168,17 +270,11 @@ template <MatchType type> int getScaledValue(const Vector<int>& scaledValues, in
 
 }
 
-bool ImageDecoder::frameIsCompleteAtIndex(size_t index)
-{
-    ImageFrame* buffer = frameBufferAtIndex(index);
-    return buffer && buffer->isComplete();
-}
-
 bool ImageDecoder::frameHasAlphaAtIndex(size_t index) const
 {
     if (m_frameBufferCache.size() <= index)
         return true;
-    if (m_frameBufferCache[index].isComplete())
+    if (m_frameBufferCache[index].status() == ImageFrame::FrameComplete)
         return m_frameBufferCache[index].hasAlpha();
     return true;
 }
@@ -188,38 +284,7 @@ unsigned ImageDecoder::frameBytesAtIndex(size_t index) const
     if (m_frameBufferCache.size() <= index)
         return 0;
     // FIXME: Use the dimension of the requested frame.
-    return (m_size.area() * sizeof(RGBA32)).unsafeGet();
-}
-
-float ImageDecoder::frameDurationAtIndex(size_t index)
-{
-    ImageFrame* buffer = frameBufferAtIndex(index);
-    if (!buffer || buffer->isEmpty())
-        return 0;
-    
-    // Many annoying ads specify a 0 duration to make an image flash as quickly as possible.
-    // We follow Firefox's behavior and use a duration of 100 ms for any frames that specify
-    // a duration of <= 10 ms. See <rdar://problem/7689300> and <http://webkit.org/b/36082>
-    // for more information.
-    const float duration = buffer->duration() / 1000.0f;
-    if (duration < 0.011f)
-        return 0.100f;
-    return duration;
-}
-
-NativeImagePtr ImageDecoder::createFrameImageAtIndex(size_t index, SubsamplingLevel, DecodingMode)
-{
-    // Zero-height images can cause problems for some ports. If we have an empty image dimension, just bail.
-    if (size().isEmpty())
-        return nullptr;
-
-    ImageFrame* buffer = frameBufferAtIndex(index);
-    if (!buffer || buffer->isEmpty() || !buffer->hasBackingStore())
-        return nullptr;
-
-    // Return the buffer contents as a native image. For some ports, the data
-    // is already in a native container, and this just increments its refcount.
-    return buffer->backingStore()->image();
+    return (m_size.area() * sizeof(ImageFrame::PixelData)).unsafeGet();
 }
 
 void ImageDecoder::prepareScaleDataIfNecessary()
diff --git a/Source/WebCore/platform/image-decoders/ImageDecoder.h b/Source/WebCore/platform/image-decoders/ImageDecoder.h
index 5fd4f1b7771..81b8c6a6179 100644
--- a/Source/WebCore/platform/image-decoders/ImageDecoder.h
+++ b/Source/WebCore/platform/image-decoders/ImageDecoder.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2006, 2016 Apple Inc.  All rights reserved.
+ * Copyright (C) 2006 Apple Inc.  All rights reserved.
  * Copyright (C) 2008-2009 Torch Mobile, Inc.
  * Copyright (C) Research In Motion Limited 2009-2010. All rights reserved.
  * Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies)
@@ -28,19 +28,204 @@
 
 #pragma once
 
-#include "ImageFrame.h"
 #include "IntRect.h"
-#include "IntSize.h"
+#include "ImageSource.h"
 #include "PlatformScreen.h"
 #include "SharedBuffer.h"
 #include <wtf/Assertions.h>
-#include <wtf/Optional.h>
 #include <wtf/RefPtr.h>
 #include <wtf/Vector.h>
 #include <wtf/text/WTFString.h>
 
 namespace WebCore {
 
+using ColorProfile = Vector<char>;
+
+    // ImageFrame represents the decoded image data.  This buffer is what all
+    // decoders write a single frame into.
+    class ImageFrame {
+    public:
+        enum FrameStatus { FrameEmpty, FramePartial, FrameComplete };
+        enum FrameDisposalMethod {
+            // If you change the numeric values of these, make sure you audit
+            // all users, as some users may cast raw values to/from these
+            // constants.
+            DisposeNotSpecified,      // Leave frame in framebuffer
+            DisposeKeep,              // Leave frame in framebuffer
+            DisposeOverwriteBgcolor,  // Clear frame to transparent
+            DisposeOverwritePrevious  // Clear frame to previous framebuffer
+                                      // contents
+        };
+        typedef unsigned PixelData;
+
+        ImageFrame();
+
+        ImageFrame(const ImageFrame& other) { operator=(other); }
+
+        // For backends which refcount their data, this operator doesn't need to
+        // create a new copy of the image data, only increase the ref count.
+        ImageFrame& operator=(const ImageFrame& other);
+
+        // These do not touch other metadata, only the raw pixel data.
+        void clearPixelData();
+        void zeroFillPixelData();
+        void zeroFillFrameRect(const IntRect&);
+
+        // Makes this frame have an independent copy of the provided image's
+        // pixel data, so that modifications in one frame are not reflected in
+        // the other.  Returns whether the copy succeeded.
+        bool copyBitmapData(const ImageFrame&);
+
+        // Copies the pixel data at [(startX, startY), (endX, startY)) to the
+        // same X-coordinates on each subsequent row up to but not including
+        // endY.
+        void copyRowNTimes(int startX, int endX, int startY, int endY)
+        {
+            ASSERT(startX < width());
+            ASSERT(endX <= width());
+            ASSERT(startY < height());
+            ASSERT(endY <= height());
+            const int rowBytes = (endX - startX) * sizeof(PixelData);
+            const PixelData* const startAddr = getAddr(startX, startY);
+            for (int destY = startY + 1; destY < endY; ++destY)
+                memcpy(getAddr(startX, destY), startAddr, rowBytes);
+        }
+
+        // Allocates space for the pixel data.  Must be called before any pixels
+        // are written.  Must only be called once.  Returns whether allocation
+        // succeeded.
+        bool setSize(int newWidth, int newHeight);
+
+        // Returns a caller-owned pointer to the underlying native image data.
+        // (Actual use: This pointer will be owned by BitmapImage and freed in
+        // FrameData::clear()).
+        NativeImagePtr asNewNativeImage() const;
+
+        bool hasAlpha() const;
+        const IntRect& originalFrameRect() const { return m_originalFrameRect; }
+        FrameStatus status() const { return m_status; }
+        unsigned duration() const { return m_duration; }
+        FrameDisposalMethod disposalMethod() const { return m_disposalMethod; }
+        bool premultiplyAlpha() const { return m_premultiplyAlpha; }
+
+        void setHasAlpha(bool alpha);
+        void setColorProfile(const ColorProfile&);
+        void setOriginalFrameRect(const IntRect& r) { m_originalFrameRect = r; }
+        void setStatus(FrameStatus status);
+        void setDuration(unsigned duration) { m_duration = duration; }
+        void setDisposalMethod(FrameDisposalMethod method) { m_disposalMethod = method; }
+        void setPremultiplyAlpha(bool premultiplyAlpha) { m_premultiplyAlpha = premultiplyAlpha; }
+
+        inline void setRGBA(int x, int y, unsigned r, unsigned g, unsigned b, unsigned a)
+        {
+            setRGBA(getAddr(x, y), r, g, b, a);
+        }
+
+        inline PixelData* getAddr(int x, int y)
+        {
+            return m_bytes + (y * width()) + x;
+        }
+
+        inline bool hasPixelData() const
+        {
+            return m_bytes;
+        }
+
+        // Use fix point multiplier instead of integer division or floating point math.
+        // This multipler produces exactly the same result for all values in range 0 - 255.
+        static const unsigned fixPointShift = 24;
+        static const unsigned fixPointMult = static_cast<unsigned>(1.0 / 255.0 * (1 << fixPointShift)) + 1;
+        // Multiplies unsigned value by fixpoint value and converts back to unsigned.
+        static unsigned fixPointUnsignedMultiply(unsigned fixed, unsigned v)
+        {
+            return  (fixed * v) >> fixPointShift;
+        }
+
+        inline void setRGBA(PixelData* dest, unsigned r, unsigned g, unsigned b, unsigned a)
+        {
+            if (m_premultiplyAlpha && a < 255) {
+                if (!a) {
+                    *dest = 0;
+                    return;
+                }
+
+                unsigned alphaMult = a * fixPointMult;
+                r = fixPointUnsignedMultiply(r, alphaMult);
+                g = fixPointUnsignedMultiply(g, alphaMult);
+                b = fixPointUnsignedMultiply(b, alphaMult);
+            }
+            *dest = (a << 24 | r << 16 | g << 8 | b);
+        }
+
+#if ENABLE(APNG)
+        static inline unsigned divide255(unsigned a)
+        {
+            return (a + (a >> 8) + 1) >> 8;
+        }
+
+        inline void overRGBA(PixelData* dest, unsigned r, unsigned g, unsigned b, unsigned a)
+        {
+            if (!a)
+                return;
+
+            if (a < 255) {
+                unsigned aDest = ((*dest) >> 24) & 255;
+                if (aDest) {
+                    unsigned rDest = ((*dest) >> 16) & 255;
+                    unsigned gDest = ((*dest) >> 8) & 255;
+                    unsigned bDest = (*dest) & 255;
+                    unsigned aAux = 255 - a;
+                    if (!m_premultiplyAlpha) {
+                        rDest = divide255(rDest * aDest);
+                        gDest = divide255(gDest * aDest);
+                        bDest = divide255(bDest * aDest);
+                    }
+                    r = divide255(r * a + rDest * aAux);
+                    g = divide255(g * a + gDest * aAux);
+                    b = divide255(b * a + bDest * aAux);
+                    a += divide255(aDest * aAux);
+                    if (!m_premultiplyAlpha) {
+                        r = (r * 255 + a - 1) / a;
+                        g = (g * 255 + a - 1) / a;
+                        b = (b * 255 + a - 1) / a;
+                    }
+                } else if (m_premultiplyAlpha) {
+                    r = divide255(r * a);
+                    g = divide255(g * a);
+                    b = divide255(b * a);
+                }
+            }
+            *dest = (a << 24 | r << 16 | g << 8 | b);
+        }
+#endif
+
+    private:
+        int width() const
+        {
+            return m_size.width();
+        }
+
+        int height() const
+        {
+            return m_size.height();
+        }
+
+        Vector<PixelData> m_backingStore;
+        PixelData* m_bytes; // The memory is backed by m_backingStore.
+        IntSize m_size;
+        // FIXME: Do we need m_colorProfile anymore?
+        ColorProfile m_colorProfile;
+        bool m_hasAlpha;
+        IntRect m_originalFrameRect; // This will always just be the entire
+                                     // buffer except for GIF frames whose
+                                     // original rect was smaller than the
+                                     // overall image size.
+        FrameStatus m_status;
+        unsigned m_duration;
+        FrameDisposalMethod m_disposalMethod;
+        bool m_premultiplyAlpha;
+    };
+
     // ImageDecoder is a base for all format-specific decoders
     // (e.g. JPEGImageDecoder).  This base manages the ImageFrame cache.
     //
@@ -50,32 +235,31 @@ namespace WebCore {
     class ImageDecoder {
         WTF_MAKE_NONCOPYABLE(ImageDecoder); WTF_MAKE_FAST_ALLOCATED;
     public:
-        ImageDecoder(AlphaOption alphaOption, GammaAndColorProfileOption gammaAndColorProfileOption)
-            : m_premultiplyAlpha(alphaOption == AlphaOption::Premultiplied)
-            , m_ignoreGammaAndColorProfile(gammaAndColorProfileOption == GammaAndColorProfileOption::Ignored)
-        {
-        }
+        ImageDecoder(ImageSource::AlphaOption alphaOption, ImageSource::GammaAndColorProfileOption gammaAndColorProfileOption)
+            : m_scaled(false)
+            , m_premultiplyAlpha(alphaOption == ImageSource::AlphaPremultiplied)
+            , m_ignoreGammaAndColorProfile(gammaAndColorProfileOption == ImageSource::GammaAndColorProfileIgnored)
+            , m_sizeAvailable(false)
+            , m_maxNumPixels(-1)
+            , m_isAllDataReceived(false)
+            , m_failed(false) { }
 
-        virtual ~ImageDecoder()
-        {
-        }
+        virtual ~ImageDecoder() { }
 
         // Returns a caller-owned decoder of the appropriate type.  Returns 0 if
         // we can't sniff a supported type from the provided data (possibly
         // because there isn't enough data yet).
-        static std::unique_ptr<ImageDecoder> create(const SharedBuffer& data, AlphaOption, GammaAndColorProfileOption);
+        static ImageDecoder* create(const SharedBuffer& data, ImageSource::AlphaOption, ImageSource::GammaAndColorProfileOption);
 
         virtual String filenameExtension() const = 0;
-        
-        bool premultiplyAlpha() const { return m_premultiplyAlpha; }
 
         bool isAllDataReceived() const { return m_isAllDataReceived; }
 
-        virtual void setData(SharedBuffer& data, bool allDataReceived)
+        virtual void setData(SharedBuffer* data, bool allDataReceived)
         {
             if (m_failed)
                 return;
-            m_data = &data;
+            m_data = data;
             m_isAllDataReceived = allDataReceived;
         }
 
@@ -87,9 +271,9 @@ namespace WebCore {
             return !m_failed && m_sizeAvailable;
         }
 
-        virtual IntSize size() { return isSizeAvailable() ? m_size : IntSize(); }
+        virtual IntSize size() const { return m_size; }
 
-        IntSize scaledSize()
+        IntSize scaledSize() const
         {
             return m_scaled ? IntSize(m_scaledColumns.size(), m_scaledRows.size()) : size();
         }
@@ -99,18 +283,18 @@ namespace WebCore {
         // sizes.  This does NOT differ from size() for GIF, since decoding GIFs
         // composites any smaller frames against previous frames to create full-
         // size frames.
-        virtual IntSize frameSizeAtIndex(size_t, SubsamplingLevel)
+        virtual IntSize frameSizeAtIndex(size_t) const
         {
             return size();
         }
 
         // Returns whether the size is legal (i.e. not going to result in
         // overflow elsewhere).  If not, marks decoding as failed.
-        virtual bool setSize(const IntSize& size)
+        virtual bool setSize(unsigned width, unsigned height)
         {
-            if (ImageBackingStore::isOverSize(size))
+            if (isOverSize(width, height))
                 return setFailed();
-            m_size = size;
+            m_size = IntSize(width, height);
             m_sizeAvailable = true;
             return true;
         }
@@ -119,32 +303,24 @@ namespace WebCore {
         // possible), without decoding the individual frames.
         // FIXME: Right now that has to be done by each subclass; factor the
         // decode call out and use it here.
-        virtual size_t frameCount() const { return 1; }
+        virtual size_t frameCount() { return 1; }
 
-        virtual RepetitionCount repetitionCount() const { return RepetitionCountNone; }
+        virtual int repetitionCount() const { return cAnimationNone; }
 
         // Decodes as much of the requested frame as possible, and returns an
         // ImageDecoder-owned pointer.
         virtual ImageFrame* frameBufferAtIndex(size_t) = 0;
 
-        bool frameIsCompleteAtIndex(size_t);
-
         // Make the best effort guess to check if the requested frame has alpha channel.
-        bool frameHasAlphaAtIndex(size_t) const;
+        virtual bool frameHasAlphaAtIndex(size_t) const;
 
         // Number of bytes in the decoded frame requested. Return 0 if not yet decoded.
-        unsigned frameBytesAtIndex(size_t) const;
-        
-        float frameDurationAtIndex(size_t);
-        
-        NativeImagePtr createFrameImageAtIndex(size_t, SubsamplingLevel = SubsamplingLevel::Default, DecodingMode = DecodingMode::OnDemand);
+        virtual unsigned frameBytesAtIndex(size_t) const;
 
         void setIgnoreGammaAndColorProfile(bool flag) { m_ignoreGammaAndColorProfile = flag; }
         bool ignoresGammaAndColorProfile() const { return m_ignoreGammaAndColorProfile; }
 
-        ImageOrientation frameOrientationAtIndex(size_t) const { return m_orientation; }
-        
-        bool frameAllowSubsamplingAtIndex(size_t) const { return false; }
+        ImageOrientation orientation() const { return m_orientation; }
 
         enum { iccColorProfileHeaderLength = 128 };
 
@@ -155,10 +331,6 @@ namespace WebCore {
             return !memcmp(&profileData[16], "RGB ", 4);
         }
 
-        static size_t bytesDecodedToDetermineProperties() { return 0; }
-        
-        static SubsamplingLevel subsamplingLevelForScale(float, SubsamplingLevel) { return SubsamplingLevel::Default; }
-
         static bool inputDeviceColorProfile(const char* profileData, unsigned profileLength)
         {
             ASSERT_UNUSED(profileLength, profileLength >= iccColorProfileHeaderLength);
@@ -183,9 +355,13 @@ namespace WebCore {
         // compositing).
         virtual void clearFrameBufferCache(size_t) { }
 
+#if ENABLE(IMAGE_DECODER_DOWN_SAMPLING)
+        void setMaxNumPixels(int m) { m_maxNumPixels = m; }
+#endif
+
         // If the image has a cursor hot-spot, stores it in the argument
         // and returns true. Otherwise returns false.
-        virtual Optional<IntPoint> hotSpot() const { return Nullopt; }
+        virtual bool hotSpot(IntPoint&) const { return false; }
 
     protected:
         void prepareScaleDataIfNecessary();
@@ -197,7 +373,9 @@ namespace WebCore {
 
         RefPtr<SharedBuffer> m_data; // The encoded data.
         Vector<ImageFrame, 1> m_frameBufferCache;
-        bool m_scaled { false };
+        // FIXME: Do we need m_colorProfile any more, for any port?
+        ColorProfile m_colorProfile;
+        bool m_scaled;
         Vector<int> m_scaledColumns;
         Vector<int> m_scaledRows;
         bool m_premultiplyAlpha;
@@ -205,15 +383,20 @@ namespace WebCore {
         ImageOrientation m_orientation;
 
     private:
+        // Some code paths compute the size of the image as "width * height * 4"
+        // and return it as a (signed) int.  Avoid overflow.
+        static bool isOverSize(unsigned width, unsigned height)
+        {
+            unsigned long long total_size = static_cast<unsigned long long>(width)
+                                          * static_cast<unsigned long long>(height);
+            return total_size > ((1 << 29) - 1);
+        }
+
         IntSize m_size;
-        bool m_sizeAvailable { false };
-#if ENABLE(IMAGE_DECODER_DOWN_SAMPLING)
-        static const int m_maxNumPixels { 1024 * 1024 };
-#else
-        static const int m_maxNumPixels { -1 };
-#endif
-        bool m_isAllDataReceived { false };
-        bool m_failed { false };
+        bool m_sizeAvailable;
+        int m_maxNumPixels;
+        bool m_isAllDataReceived;
+        bool m_failed;
     };
 
 } // namespace WebCore
diff --git a/Source/WebCore/platform/image-decoders/bmp/BMPImageDecoder.cpp b/Source/WebCore/platform/image-decoders/bmp/BMPImageDecoder.cpp
index 368bccad27f..3d76bc2a974 100644
--- a/Source/WebCore/platform/image-decoders/bmp/BMPImageDecoder.cpp
+++ b/Source/WebCore/platform/image-decoders/bmp/BMPImageDecoder.cpp
@@ -40,20 +40,21 @@ namespace WebCore {
 // don't pack).
 static const size_t sizeOfFileHeader = 14;
 
-BMPImageDecoder::BMPImageDecoder(AlphaOption alphaOption, GammaAndColorProfileOption gammaAndColorProfileOption)
+BMPImageDecoder::BMPImageDecoder(ImageSource::AlphaOption alphaOption,
+                                 ImageSource::GammaAndColorProfileOption gammaAndColorProfileOption)
     : ImageDecoder(alphaOption, gammaAndColorProfileOption)
     , m_decodedOffset(0)
 {
 }
 
-void BMPImageDecoder::setData(SharedBuffer& data, bool allDataReceived)
+void BMPImageDecoder::setData(SharedBuffer* data, bool allDataReceived)
 {
     if (failed())
         return;
 
     ImageDecoder::setData(data, allDataReceived);
     if (m_reader)
-        m_reader->setData(&data);
+        m_reader->setData(data);
 }
 
 bool BMPImageDecoder::isSizeAvailable()
@@ -69,11 +70,13 @@ ImageFrame* BMPImageDecoder::frameBufferAtIndex(size_t index)
     if (index)
         return 0;
 
-    if (m_frameBufferCache.isEmpty())
+    if (m_frameBufferCache.isEmpty()) {
         m_frameBufferCache.resize(1);
+        m_frameBufferCache.first().setPremultiplyAlpha(m_premultiplyAlpha);
+    }
 
     ImageFrame* buffer = &m_frameBufferCache.first();
-    if (!buffer->isComplete())
+    if (buffer->status() != ImageFrame::FrameComplete)
         decode(false);
     return buffer;
 }
@@ -95,7 +98,7 @@ void BMPImageDecoder::decode(bool onlySize)
         setFailed();
     // If we're done decoding the image, we don't need the BMPImageReader
     // anymore.  (If we failed, |m_reader| has already been cleared.)
-    else if (!m_frameBufferCache.isEmpty() && m_frameBufferCache.first().isComplete())
+    else if (!m_frameBufferCache.isEmpty() && (m_frameBufferCache.first().status() == ImageFrame::FrameComplete))
         m_reader = nullptr;
 }
 
diff --git a/Source/WebCore/platform/image-decoders/bmp/BMPImageDecoder.h b/Source/WebCore/platform/image-decoders/bmp/BMPImageDecoder.h
index 6b6270ce179..1c882e13995 100644
--- a/Source/WebCore/platform/image-decoders/bmp/BMPImageDecoder.h
+++ b/Source/WebCore/platform/image-decoders/bmp/BMPImageDecoder.h
@@ -28,26 +28,27 @@
  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-#pragma once
+#ifndef BMPImageDecoder_h
+#define BMPImageDecoder_h
 
 #include "BMPImageReader.h"
 
 namespace WebCore {
 
     // This class decodes the BMP image format.
-    class BMPImageDecoder final : public ImageDecoder {
+    class BMPImageDecoder : public ImageDecoder {
     public:
-        BMPImageDecoder(AlphaOption, GammaAndColorProfileOption);
+        BMPImageDecoder(ImageSource::AlphaOption, ImageSource::GammaAndColorProfileOption);
 
         // ImageDecoder
-        String filenameExtension() const override { return "bmp"; }
-        void setData(SharedBuffer&, bool allDataReceived) override;
-        bool isSizeAvailable() override;
-        ImageFrame* frameBufferAtIndex(size_t index) override;
+        virtual String filenameExtension() const { return "bmp"; }
+        virtual void setData(SharedBuffer*, bool allDataReceived);
+        virtual bool isSizeAvailable();
+        virtual ImageFrame* frameBufferAtIndex(size_t index);
         // CAUTION: setFailed() deletes |m_reader|.  Be careful to avoid
         // accessing deleted memory, especially when calling this from inside
         // BMPImageReader!
-        bool setFailed() override;
+        virtual bool setFailed();
 
     private:
         inline uint32_t readUint32(int offset) const
@@ -79,3 +80,5 @@ namespace WebCore {
     };
 
 } // namespace WebCore
+
+#endif
diff --git a/Source/WebCore/platform/image-decoders/bmp/BMPImageReader.cpp b/Source/WebCore/platform/image-decoders/bmp/BMPImageReader.cpp
index 2212f14ff2f..5c005534ecd 100644
--- a/Source/WebCore/platform/image-decoders/bmp/BMPImageReader.cpp
+++ b/Source/WebCore/platform/image-decoders/bmp/BMPImageReader.cpp
@@ -77,13 +77,18 @@ bool BMPImageReader::decodeBMP(bool onlySize)
 
     // Initialize the framebuffer if needed.
     ASSERT(m_buffer);  // Parent should set this before asking us to decode!
-    if (m_buffer->isEmpty()) {
-        if (!m_buffer->initialize(m_parent->size(), m_parent->premultiplyAlpha()))
+    if (m_buffer->status() == ImageFrame::FrameEmpty) {
+        if (!m_buffer->setSize(m_parent->size().width(), m_parent->size().height()))
             return m_parent->setFailed(); // Unable to allocate.
-
-        m_buffer->setDecoding(ImageFrame::Decoding::Partial);
+        m_buffer->setStatus(ImageFrame::FramePartial);
+        // setSize() calls eraseARGB(), which resets the alpha flag, so we force
+        // it back to false here.  We'll set it true below in all cases where
+        // these 0s could actually show through.
         m_buffer->setHasAlpha(false);
 
+        // For BMPs, the frame always fills the entire image.
+        m_buffer->setOriginalFrameRect(IntRect(IntPoint(), m_parent->size()));
+
         if (!m_isTopDown)
             m_coord.setY(m_parent->size().height() - 1);
     }
@@ -117,7 +122,7 @@ bool BMPImageReader::decodeBMP(bool onlySize)
     }
 
     // Done!
-    m_buffer->setDecoding(ImageFrame::Decoding::Complete);
+    m_buffer->setStatus(ImageFrame::FrameComplete);
     return true;
 }
 
@@ -166,7 +171,7 @@ bool BMPImageReader::processInfoHeader()
         return m_parent->setFailed();
 
     // Set our size.
-    if (!m_parent->setSize(IntSize(m_infoHeader.biWidth, m_infoHeader.biHeight)))
+    if (!m_parent->setSize(m_infoHeader.biWidth, m_infoHeader.biHeight))
         return false;
 
     // For paletted images, bitmaps can set biClrUsed to 0 to mean "all
@@ -669,7 +674,7 @@ BMPImageReader::ProcessingResult BMPImageReader::processNonRLEData(bool inRLE, i
                         // transparent, on the assumption that most ICOs on the
                         // web will not be doing a lot of inverting.
                         if (colorIndex) {
-                            setPixel(0, 0, 0, 0);
+                            setRGBA(0, 0, 0, 0);
                             m_buffer->setHasAlpha(true);
                         } else
                             m_coord.move(1, 0);
@@ -702,14 +707,13 @@ BMPImageReader::ProcessingResult BMPImageReader::processNonRLEData(bool inRLE, i
                 } else {
                     m_seenNonZeroAlphaPixel = true;
                     if (m_seenZeroAlphaPixel) {
-                        m_buffer->backingStore()->clear();
-                        m_buffer->setHasAlpha(true);
+                        m_buffer->zeroFillPixelData();
                         m_seenZeroAlphaPixel = false;
                     } else if (alpha != 255)
                         m_buffer->setHasAlpha(true);
                 }
 
-                setPixel(getComponent(pixel, 0), getComponent(pixel, 1),
+                setRGBA(getComponent(pixel, 0), getComponent(pixel, 1),
                         getComponent(pixel, 2), alpha);
             }
         }
diff --git a/Source/WebCore/platform/image-decoders/bmp/BMPImageReader.h b/Source/WebCore/platform/image-decoders/bmp/BMPImageReader.h
index 03bcac60ad1..b5cb96e3f92 100644
--- a/Source/WebCore/platform/image-decoders/bmp/BMPImageReader.h
+++ b/Source/WebCore/platform/image-decoders/bmp/BMPImageReader.h
@@ -239,16 +239,16 @@ namespace WebCore {
         // right by one.
         inline void setI(size_t colorIndex)
         {
-            setPixel(m_colorTable[colorIndex].rgbRed, m_colorTable[colorIndex].rgbGreen, m_colorTable[colorIndex].rgbBlue, 0xff);
+            setRGBA(m_colorTable[colorIndex].rgbRed, m_colorTable[colorIndex].rgbGreen, m_colorTable[colorIndex].rgbBlue, 0xff);
         }
 
         // Like setI(), but with the individual component values specified.
-        inline void setPixel(unsigned red,
+        inline void setRGBA(unsigned red,
                             unsigned green,
                             unsigned blue,
                             unsigned alpha)
         {
-            m_buffer->backingStore()->setPixel(m_coord.x(), m_coord.y(), red, green, blue, alpha);
+            m_buffer->setRGBA(m_coord.x(), m_coord.y(), red, green, blue, alpha);
             m_coord.move(1, 0);
         }
 
@@ -262,10 +262,8 @@ namespace WebCore {
                              unsigned blue,
                              unsigned alpha)
         {
-            if (endCoord <= m_coord.x())
-                return;
-            m_buffer->backingStore()->fillRect(IntRect(m_coord.x(), m_coord.y(), endCoord - m_coord.x(), 1), red, green, blue, alpha);
-            m_coord.setX(endCoord);
+            while (m_coord.x() < endCoord)
+                setRGBA(red, green, blue, alpha);
         }
 
         // Resets the relevant local variables to start drawing at the left edge
diff --git a/Source/WebCore/platform/image-decoders/cairo/ImageBackingStoreCairo.cpp b/Source/WebCore/platform/image-decoders/cairo/ImageDecoderCairo.cpp
similarity index 82%
rename from Source/WebCore/platform/image-decoders/cairo/ImageBackingStoreCairo.cpp
rename to Source/WebCore/platform/image-decoders/cairo/ImageDecoderCairo.cpp
index a734a876cd2..7b41295f857 100644
--- a/Source/WebCore/platform/image-decoders/cairo/ImageBackingStoreCairo.cpp
+++ b/Source/WebCore/platform/image-decoders/cairo/ImageDecoderCairo.cpp
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2016 Apple Inc.  All rights reserved.
+ * Copyright (C) 2006 Apple Inc.  All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
@@ -24,17 +24,17 @@
  */
 
 #include "config.h"
-#include "ImageBackingStore.h"
+#include "ImageDecoder.h"
 
 #include <cairo.h>
 
 namespace WebCore {
 
-NativeImagePtr ImageBackingStore::image() const
+NativeImagePtr ImageFrame::asNewNativeImage() const
 {
     return adoptRef(cairo_image_surface_create_for_data(
-        reinterpret_cast<unsigned char*>(const_cast<RGBA32*>(m_pixelsPtr)),
-        CAIRO_FORMAT_ARGB32, size().width(), size().height(), size().width() * sizeof(RGBA32)));
+        reinterpret_cast<unsigned char*>(const_cast<PixelData*>(m_bytes)),
+        CAIRO_FORMAT_ARGB32, width(), height(), width() * sizeof(PixelData)));
 }
 
 } // namespace WebCore
diff --git a/Source/WebCore/platform/image-decoders/gif/GIFImageDecoder.cpp b/Source/WebCore/platform/image-decoders/gif/GIFImageDecoder.cpp
index 9befa8a4208..cd56e67eb91 100644
--- a/Source/WebCore/platform/image-decoders/gif/GIFImageDecoder.cpp
+++ b/Source/WebCore/platform/image-decoders/gif/GIFImageDecoder.cpp
@@ -31,8 +31,10 @@
 
 namespace WebCore {
 
-GIFImageDecoder::GIFImageDecoder(AlphaOption alphaOption, GammaAndColorProfileOption gammaAndColorProfileOption)
+GIFImageDecoder::GIFImageDecoder(ImageSource::AlphaOption alphaOption,
+                                 ImageSource::GammaAndColorProfileOption gammaAndColorProfileOption)
     : ImageDecoder(alphaOption, gammaAndColorProfileOption)
+    , m_repetitionCount(cAnimationLoopOnce)
 {
 }
 
@@ -40,14 +42,14 @@ GIFImageDecoder::~GIFImageDecoder()
 {
 }
 
-void GIFImageDecoder::setData(SharedBuffer& data, bool allDataReceived)
+void GIFImageDecoder::setData(SharedBuffer* data, bool allDataReceived)
 {
     if (failed())
         return;
 
     ImageDecoder::setData(data, allDataReceived);
     if (m_reader)
-        m_reader->setData(&data);
+        m_reader->setData(data);
 }
 
 bool GIFImageDecoder::isSizeAvailable()
@@ -58,25 +60,25 @@ bool GIFImageDecoder::isSizeAvailable()
     return ImageDecoder::isSizeAvailable();
 }
 
-bool GIFImageDecoder::setSize(const IntSize& size)
+bool GIFImageDecoder::setSize(unsigned width, unsigned height)
 {
-    if (ImageDecoder::isSizeAvailable() && this->size() == size)
+    if (ImageDecoder::isSizeAvailable() && size() == IntSize(width, height))
         return true;
 
-    if (!ImageDecoder::setSize(size))
+    if (!ImageDecoder::setSize(width, height))
         return false;
 
     prepareScaleDataIfNecessary();
     return true;
 }
 
-size_t GIFImageDecoder::frameCount() const
+size_t GIFImageDecoder::frameCount()
 {
-    const_cast<GIFImageDecoder*>(this)->decode(std::numeric_limits<unsigned>::max(), GIFFrameCountQuery);
+    decode(std::numeric_limits<unsigned>::max(), GIFFrameCountQuery);
     return m_frameBufferCache.size();
 }
 
-RepetitionCount GIFImageDecoder::repetitionCount() const
+int GIFImageDecoder::repetitionCount() const
 {
     // This value can arrive at any point in the image data stream.  Most GIFs
     // in the wild declare it near the beginning of the file, so it usually is
@@ -103,7 +105,7 @@ RepetitionCount GIFImageDecoder::repetitionCount() const
     // later in the stream. It is also possible that no frames are in the
     // stream. In these cases we should just loop once.
     if (failed() || (m_reader && (!m_reader->imagesCount())))
-        m_repetitionCount = RepetitionCountOnce;
+        m_repetitionCount = cAnimationLoopOnce;
     else if (m_reader && m_reader->loopCount() != cLoopCountNotSeen)
         m_repetitionCount = m_reader->loopCount();
     return m_repetitionCount;
@@ -115,7 +117,7 @@ ImageFrame* GIFImageDecoder::frameBufferAtIndex(size_t index)
         return 0;
 
     ImageFrame& frame = m_frameBufferCache[index];
-    if (!frame.isComplete())
+    if (frame.status() != ImageFrame::FrameComplete)
         decode(index + 1, GIFFullQuery);
     return &frame;
 }
@@ -154,30 +156,26 @@ void GIFImageDecoder::clearFrameBufferCache(size_t clearBeforeFrame)
     // not to have non-empty frames after the frame we're currently decoding.
     // So, scan backwards from |end| as follows:
     //   * If the frame is empty, we're still past any frames we care about.
-    //   * If the frame is complete, but is DisposalMethod::RestoreToPrevious, we'll
+    //   * If the frame is complete, but is DisposeOverwritePrevious, we'll
     //     skip over it in future initFrameBuffer() calls.  We can clear it
     //     unless it's |end|, and keep scanning.  For any other disposal method,
     //     stop scanning, as we've found the frame initFrameBuffer() will need
     //     next.
     //   * If the frame is partial, we're decoding it, so don't clear it; if it
-    //     has a disposal method other than DisposalMethod::RestoreToPrevious, stop
+    //     has a disposal method other than DisposeOverwritePrevious, stop
     //     scanning, as we'll only need this frame when decoding the next one.
     Vector<ImageFrame>::iterator i(end);
-    for (; (i != m_frameBufferCache.begin()) && (i->isEmpty() || (i->disposalMethod() == ImageFrame::DisposalMethod::RestoreToPrevious)); --i) {
-        if (i->isComplete() && (i != end))
-            i->clear();
+    for (; (i != m_frameBufferCache.begin()) && ((i->status() == ImageFrame::FrameEmpty) || (i->disposalMethod() == ImageFrame::DisposeOverwritePrevious)); --i) {
+        if ((i->status() == ImageFrame::FrameComplete) && (i != end))
+            i->clearPixelData();
     }
 
     // Now |i| holds the last frame we need to preserve; clear prior frames.
     for (Vector<ImageFrame>::iterator j(m_frameBufferCache.begin()); j != i; ++j) {
-        ASSERT(!j->isPartial());
-        if (j->isEmpty())
-            j->clear();
+        ASSERT(j->status() != ImageFrame::FramePartial);
+        if (j->status() != ImageFrame::FrameEmpty)
+            j->clearPixelData();
     }
-
-    // When some frames are cleared, the reader is out of sync, since the caller might ask for any frame not
-    // necessarily in the order expected by the reader. See https://bugs.webkit.org/show_bug.cgi?id=159089.
-    m_reader = nullptr;
 }
 
 bool GIFImageDecoder::haveDecodedRow(unsigned frameIndex, const Vector<unsigned char>& rowBuffer, size_t width, size_t rowNumber, unsigned repeatCount, bool writeTransparentPixels)
@@ -211,16 +209,16 @@ bool GIFImageDecoder::haveDecodedRow(unsigned frameIndex, const Vector<unsigned
 
     // Initialize the frame if necessary.
     ImageFrame& buffer = m_frameBufferCache[frameIndex];
-    if ((buffer.isEmpty() && !initFrameBuffer(frameIndex)) || !buffer.hasBackingStore())
+    if (((buffer.status() == ImageFrame::FrameEmpty) && !initFrameBuffer(frameIndex)) || !buffer.hasPixelData())
         return false;
 
-    RGBA32* currentAddress = buffer.backingStore()->pixelAt(xBegin, yBegin);
+    ImageFrame::PixelData* currentAddress = buffer.getAddr(xBegin, yBegin);
     // Write one row's worth of data into the frame.  
     for (int x = xBegin; x < xEnd; ++x) {
         const unsigned char sourceValue = rowBuffer[(m_scaled ? m_scaledColumns[x] : x) - frameContext->xOffset];
         if ((!frameContext->isTransparent || (sourceValue != frameContext->tpixel)) && (sourceValue < colorMapSize)) {
             const size_t colorIndex = static_cast<size_t>(sourceValue) * 3;
-            buffer.backingStore()->setPixel(currentAddress, colorMap[colorIndex], colorMap[colorIndex + 1], colorMap[colorIndex + 2], 255);
+            buffer.setRGBA(currentAddress, colorMap[colorIndex], colorMap[colorIndex + 1], colorMap[colorIndex + 2], 255);
         } else {
             m_currentBufferSawAlpha = true;
             // We may or may not need to write transparent pixels to the buffer.
@@ -231,36 +229,34 @@ bool GIFImageDecoder::haveDecodedRow(unsigned frameIndex, const Vector<unsigned
             // beyond the first, or the initial passes will "show through" the
             // later ones.
             if (writeTransparentPixels)
-                buffer.backingStore()->setPixel(currentAddress, 0, 0, 0, 0);
+                buffer.setRGBA(currentAddress, 0, 0, 0, 0);
         }
         ++currentAddress;
     }
 
     // Tell the frame to copy the row data if need be.
     if (repeatCount > 1)
-        buffer.backingStore()->repeatFirstRow(IntRect(xBegin, yBegin, xEnd - xBegin , yEnd - yBegin));
+        buffer.copyRowNTimes(xBegin, xEnd, yBegin, yEnd);
 
     return true;
 }
 
-bool GIFImageDecoder::frameComplete(unsigned frameIndex, unsigned frameDuration, ImageFrame::DisposalMethod disposalMethod)
+bool GIFImageDecoder::frameComplete(unsigned frameIndex, unsigned frameDuration, ImageFrame::FrameDisposalMethod disposalMethod)
 {
     // Initialize the frame if necessary.  Some GIFs insert do-nothing frames,
     // in which case we never reach haveDecodedRow() before getting here.
     ImageFrame& buffer = m_frameBufferCache[frameIndex];
-    if (buffer.isEmpty() && !initFrameBuffer(frameIndex))
+    if ((buffer.status() == ImageFrame::FrameEmpty) && !initFrameBuffer(frameIndex))
         return false; // initFrameBuffer() has already called setFailed().
 
-    buffer.setDecoding(ImageFrame::Decoding::Complete);
+    buffer.setStatus(ImageFrame::FrameComplete);
     buffer.setDuration(frameDuration);
     buffer.setDisposalMethod(disposalMethod);
 
     if (!m_currentBufferSawAlpha) {
-        IntRect rect = buffer.backingStore()->frameRect();
-        
         // The whole frame was non-transparent, so it's possible that the entire
         // resulting buffer was non-transparent, and we can setHasAlpha(false).
-        if (rect.contains(IntRect(IntPoint(), scaledSize())))
+        if (buffer.originalFrameRect().contains(IntRect(IntPoint(), scaledSize())))
             buffer.setHasAlpha(false);
         else if (frameIndex) {
             // Tricky case.  This frame does not have alpha only if everywhere
@@ -268,23 +264,22 @@ bool GIFImageDecoder::frameComplete(unsigned frameIndex, unsigned frameDuration,
             // true, we check the start state of the frame -- if it doesn't have
             // alpha, we're safe.
             //
-            // First skip over prior DisposalMethod::RestoreToPrevious frames (since they
+            // First skip over prior DisposeOverwritePrevious frames (since they
             // don't affect the start state of this frame) the same way we do in
             // initFrameBuffer().
             const ImageFrame* prevBuffer = &m_frameBufferCache[--frameIndex];
-            while (frameIndex && (prevBuffer->disposalMethod() == ImageFrame::DisposalMethod::RestoreToPrevious))
+            while (frameIndex && (prevBuffer->disposalMethod() == ImageFrame::DisposeOverwritePrevious))
                 prevBuffer = &m_frameBufferCache[--frameIndex];
 
-            // Now, if we're at a DisposalMethod::Unspecified or DisposalMethod::DoNotDispose frame, then
+            // Now, if we're at a DisposeNotSpecified or DisposeKeep frame, then
             // we can say we have no alpha if that frame had no alpha.  But
             // since in initFrameBuffer() we already copied that frame's alpha
             // state into the current frame's, we need do nothing at all here.
             //
-            // The only remaining case is a DisposalMethod::RestoreToBackground frame. If
+            // The only remaining case is a DisposeOverwriteBgcolor frame.  If
             // it had no alpha, and its rect is contained in the current frame's
             // rect, we know the current frame has no alpha.
-            IntRect prevRect = prevBuffer->backingStore()->frameRect();
-            if ((prevBuffer->disposalMethod() == ImageFrame::DisposalMethod::RestoreToBackground) && !prevBuffer->hasAlpha() && rect.contains(prevRect))
+            if ((prevBuffer->disposalMethod() == ImageFrame::DisposeOverwriteBgcolor) && !prevBuffer->hasAlpha() && buffer.originalFrameRect().contains(prevBuffer->originalFrameRect()))
                 buffer.setHasAlpha(false);
         }
     }
@@ -308,7 +303,7 @@ void GIFImageDecoder::decode(unsigned haltAtFrame, GIFQuery query)
 
     if (!m_reader) {
         m_reader = std::make_unique<GIFImageReader>(this);
-        m_reader->setData(m_data.get());
+        m_reader->setData(m_data);
     }
 
     if (query == GIFSizeQuery) {
@@ -322,7 +317,10 @@ void GIFImageDecoder::decode(unsigned haltAtFrame, GIFQuery query)
         return;
     }
 
+    const size_t oldSize = m_frameBufferCache.size();
     m_frameBufferCache.resize(m_reader->imagesCount());
+    for (size_t i = oldSize; i < m_reader->imagesCount(); ++i)
+        m_frameBufferCache[i].setPremultiplyAlpha(m_premultiplyAlpha);
 
     if (query == GIFFrameCountQuery)
         return;
@@ -343,68 +341,66 @@ bool GIFImageDecoder::initFrameBuffer(unsigned frameIndex)
     // Initialize the frame rect in our buffer.
     const GIFFrameContext* frameContext = m_reader->frameContext();
     IntRect frameRect(frameContext->xOffset, frameContext->yOffset, frameContext->width, frameContext->height);
+
+    // Make sure the frameRect doesn't extend outside the buffer.
+    if (frameRect.maxX() > size().width())
+        frameRect.setWidth(size().width() - frameContext->xOffset);
+    if (frameRect.maxY() > size().height())
+        frameRect.setHeight(size().height() - frameContext->yOffset);
+
     ImageFrame* const buffer = &m_frameBufferCache[frameIndex];
+    int left = upperBoundScaledX(frameRect.x());
+    int right = lowerBoundScaledX(frameRect.maxX(), left);
+    int top = upperBoundScaledY(frameRect.y());
+    int bottom = lowerBoundScaledY(frameRect.maxY(), top);
+    buffer->setOriginalFrameRect(IntRect(left, top, right - left, bottom - top));
 
     if (!frameIndex) {
         // This is the first frame, so we're not relying on any previous data.
-        if (!buffer->initialize(scaledSize(), m_premultiplyAlpha))
+        if (!buffer->setSize(scaledSize().width(), scaledSize().height()))
             return setFailed();
     } else {
         // The starting state for this frame depends on the previous frame's
         // disposal method.
         //
-        // Frames that use the DisposalMethod::RestoreToPrevious method are effectively
+        // Frames that use the DisposeOverwritePrevious method are effectively
         // no-ops in terms of changing the starting state of a frame compared to
         // the starting state of the previous frame, so skip over them.  (If the
         // first frame specifies this method, it will get treated like
-        // DisposalMethod::RestoreToBackground below and reset to a completely empty image.)
+        // DisposeOverwriteBgcolor below and reset to a completely empty image.)
         const ImageFrame* prevBuffer = &m_frameBufferCache[--frameIndex];
-        ImageFrame::DisposalMethod prevMethod = prevBuffer->disposalMethod();
-        while (frameIndex && (prevMethod == ImageFrame::DisposalMethod::RestoreToPrevious)) {
+        ImageFrame::FrameDisposalMethod prevMethod = prevBuffer->disposalMethod();
+        while (frameIndex && (prevMethod == ImageFrame::DisposeOverwritePrevious)) {
             prevBuffer = &m_frameBufferCache[--frameIndex];
             prevMethod = prevBuffer->disposalMethod();
         }
+        ASSERT(prevBuffer->status() == ImageFrame::FrameComplete);
 
-        ASSERT(prevBuffer->isComplete());
-
-        if ((prevMethod == ImageFrame::DisposalMethod::Unspecified) || (prevMethod == ImageFrame::DisposalMethod::DoNotDispose)) {
+        if ((prevMethod == ImageFrame::DisposeNotSpecified) || (prevMethod == ImageFrame::DisposeKeep)) {
             // Preserve the last frame as the starting state for this frame.
-            if (!prevBuffer->backingStore() || !buffer->initialize(*prevBuffer->backingStore()))
+            if (!buffer->copyBitmapData(*prevBuffer))
                 return setFailed();
         } else {
             // We want to clear the previous frame to transparent, without
             // affecting pixels in the image outside of the frame.
-            IntRect prevRect = prevBuffer->backingStore()->frameRect();
+            const IntRect& prevRect = prevBuffer->originalFrameRect();
             const IntSize& bufferSize = scaledSize();
             if (!frameIndex || prevRect.contains(IntRect(IntPoint(), scaledSize()))) {
                 // Clearing the first frame, or a frame the size of the whole
                 // image, results in a completely empty image.
-                if (!buffer->initialize(bufferSize, m_premultiplyAlpha))
+                if (!buffer->setSize(bufferSize.width(), bufferSize.height()))
                     return setFailed();
             } else {
                 // Copy the whole previous buffer, then clear just its frame.
-                if (!prevBuffer->backingStore() || !buffer->initialize(*prevBuffer->backingStore()))
+                if (!buffer->copyBitmapData(*prevBuffer))
                     return setFailed();
-                buffer->backingStore()->clearRect(prevRect);
-                buffer->setHasAlpha(true);
+                buffer->zeroFillFrameRect(prevRect);
             }
         }
     }
 
-    // Make sure the frameRect doesn't extend outside the buffer.
-    if (frameRect.maxX() > size().width())
-        frameRect.setWidth(size().width() - frameContext->xOffset);
-    if (frameRect.maxY() > size().height())
-        frameRect.setHeight(size().height() - frameContext->yOffset);
-
-    int left = upperBoundScaledX(frameRect.x());
-    int right = lowerBoundScaledX(frameRect.maxX(), left);
-    int top = upperBoundScaledY(frameRect.y());
-    int bottom = lowerBoundScaledY(frameRect.maxY(), top);
-    buffer->backingStore()->setFrameRect(IntRect(left, top, right - left, bottom - top));
-
     // Update our status to be partially complete.
-    buffer->setDecoding(ImageFrame::Decoding::Partial);
+    buffer->setStatus(ImageFrame::FramePartial);
 
     // Reset the alpha pixel tracker for this frame.
     m_currentBufferSawAlpha = false;
diff --git a/Source/WebCore/platform/image-decoders/gif/GIFImageDecoder.h b/Source/WebCore/platform/image-decoders/gif/GIFImageDecoder.h
index f6ba680415c..40610895395 100644
--- a/Source/WebCore/platform/image-decoders/gif/GIFImageDecoder.h
+++ b/Source/WebCore/platform/image-decoders/gif/GIFImageDecoder.h
@@ -23,7 +23,8 @@
  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-#pragma once
+#ifndef GIFImageDecoder_h
+#define GIFImageDecoder_h
 
 #include "ImageDecoder.h"
 
@@ -32,30 +33,30 @@ class GIFImageReader;
 namespace WebCore {
 
     // This class decodes the GIF image format.
-    class GIFImageDecoder final : public ImageDecoder {
+    class GIFImageDecoder : public ImageDecoder {
     public:
-        GIFImageDecoder(AlphaOption, GammaAndColorProfileOption);
+        GIFImageDecoder(ImageSource::AlphaOption, ImageSource::GammaAndColorProfileOption);
         virtual ~GIFImageDecoder();
 
         enum GIFQuery { GIFFullQuery, GIFSizeQuery, GIFFrameCountQuery };
 
         // ImageDecoder
-        String filenameExtension() const override { return "gif"; }
-        void setData(SharedBuffer& data, bool allDataReceived) override;
-        bool isSizeAvailable() override;
-        bool setSize(const IntSize&) override;
-        size_t frameCount() const override;
-        RepetitionCount repetitionCount() const override;
-        ImageFrame* frameBufferAtIndex(size_t index) override;
+        virtual String filenameExtension() const { return "gif"; }
+        virtual void setData(SharedBuffer* data, bool allDataReceived);
+        virtual bool isSizeAvailable();
+        virtual bool setSize(unsigned width, unsigned height);
+        virtual size_t frameCount();
+        virtual int repetitionCount() const;
+        virtual ImageFrame* frameBufferAtIndex(size_t index);
         // CAUTION: setFailed() deletes |m_reader|.  Be careful to avoid
         // accessing deleted memory, especially when calling this from inside
         // GIFImageReader!
-        bool setFailed() override;
-        void clearFrameBufferCache(size_t clearBeforeFrame) override;
+        virtual bool setFailed();
+        virtual void clearFrameBufferCache(size_t clearBeforeFrame);
 
         // Callbacks from the GIF reader.
         bool haveDecodedRow(unsigned frameIndex, const Vector<unsigned char>& rowBuffer, size_t width, size_t rowNumber, unsigned repeatCount, bool writeTransparentPixels);
-        bool frameComplete(unsigned frameIndex, unsigned frameDuration, ImageFrame::DisposalMethod);
+        bool frameComplete(unsigned frameIndex, unsigned frameDuration, ImageFrame::FrameDisposalMethod disposalMethod);
         void gifComplete();
 
     private:
@@ -71,8 +72,10 @@ namespace WebCore {
         bool initFrameBuffer(unsigned frameIndex);
 
         bool m_currentBufferSawAlpha;
-        mutable RepetitionCount m_repetitionCount { RepetitionCountOnce };
+        mutable int m_repetitionCount;
         std::unique_ptr<GIFImageReader> m_reader;
     };
 
 } // namespace WebCore
+
+#endif
diff --git a/Source/WebCore/platform/image-decoders/gif/GIFImageReader.cpp b/Source/WebCore/platform/image-decoders/gif/GIFImageReader.cpp
index 0965859fe9e..00d252cefb0 100644
--- a/Source/WebCore/platform/image-decoders/gif/GIFImageReader.cpp
+++ b/Source/WebCore/platform/image-decoders/gif/GIFImageReader.cpp
@@ -77,6 +77,7 @@ mailing address.
 
 #include <string.h>
 #include "GIFImageDecoder.h"
+#include "ImageSource.h"
 
 using WebCore::GIFImageDecoder;
 
@@ -446,7 +447,7 @@ bool GIFImageReader::parse(size_t dataPosition, size_t len, bool parseSizeOnly)
 
             // CALLBACK: Inform the decoderplugin of our size.
             // Note: A subsequent frame might have dimensions larger than the "screen" dimensions.
-            if (m_client && !m_client->setSize(WebCore::IntSize(m_screenWidth, m_screenHeight)))
+            if (m_client && !m_client->setSize(m_screenWidth, m_screenHeight))
                 return false;
 
             m_screenBgcolor = currentComponent[5];
@@ -567,14 +568,14 @@ bool GIFImageReader::parse(size_t dataPosition, size_t len, bool parseSizeOnly)
 
             // We ignore the "user input" bit.
 
-            // NOTE: This relies on the values in the DisposalMethod enum
+            // NOTE: This relies on the values in the FrameDisposalMethod enum
             // matching those in the GIF spec!
             int disposalMethod = ((*currentComponent) >> 2) & 0x7;
-            currentFrame->disposalMethod = static_cast<WebCore::ImageFrame::DisposalMethod>(disposalMethod);
+            currentFrame->disposalMethod = static_cast<WebCore::ImageFrame::FrameDisposalMethod>(disposalMethod);
             // Some specs say that disposal method 3 is "overwrite previous", others that setting
             // the third bit of the field (i.e. method 4) is. We map both to the same value.
             if (disposalMethod == 4)
-                currentFrame->disposalMethod = WebCore::ImageFrame::DisposalMethod::RestoreToPrevious;
+                currentFrame->disposalMethod = WebCore::ImageFrame::DisposeOverwritePrevious;
             currentFrame->delayTime = GETINT16(currentComponent + 1) * 10;
             GETN(1, GIFConsumeBlock);
             break;
@@ -623,7 +624,7 @@ bool GIFImageReader::parse(size_t dataPosition, size_t len, bool parseSizeOnly)
 
                 // Zero loop count is infinite animation loop request.
                 if (!m_loopCount)
-                    m_loopCount = WebCore::RepetitionCountInfinite;
+                    m_loopCount = WebCore::cAnimationLoopInfinite;
 
                 GETN(1, GIFNetscapeExtensionBlock);
             } else if (netscapeExtension == 2) {
@@ -663,7 +664,7 @@ bool GIFImageReader::parse(size_t dataPosition, size_t len, bool parseSizeOnly)
                 yOffset = 0;
 
                 // CALLBACK: Inform the decoderplugin of our size.
-                if (m_client && !m_client->setSize(WebCore::IntSize(m_screenWidth, m_screenHeight)))
+                if (m_client && !m_client->setSize(m_screenWidth, m_screenHeight))
                     return false;
             }
 
diff --git a/Source/WebCore/platform/image-decoders/gif/GIFImageReader.h b/Source/WebCore/platform/image-decoders/gif/GIFImageReader.h
index 40b1d69f12a..fb878ed08e2 100644
--- a/Source/WebCore/platform/image-decoders/gif/GIFImageReader.h
+++ b/Source/WebCore/platform/image-decoders/gif/GIFImageReader.h
@@ -35,7 +35,8 @@
  *
  * ***** END LICENSE BLOCK ***** */
 
-#pragma once
+#ifndef GIFImageReader_h
+#define GIFImageReader_h
 
 // Define ourselves as the clientPtr.  Mozilla just hacked their C++ callback class into this old C decoder,
 // so we will too.
@@ -154,7 +155,7 @@ public:
     unsigned width;
     unsigned height;
     int tpixel; // Index of transparent pixel.
-    WebCore::ImageFrame::DisposalMethod disposalMethod; // Restore to background, leave in place, etc.
+    WebCore::ImageFrame::FrameDisposalMethod disposalMethod; // Restore to background, leave in place, etc.
     size_t localColormapPosition; // Per-image colormap.
     int localColormapSize; // Size of local colormap array.
     int datasize;
@@ -173,7 +174,7 @@ public:
         , width(0)
         , height(0)
         , tpixel(0)
-        , disposalMethod(WebCore::ImageFrame::DisposalMethod::Unspecified)
+        , disposalMethod(WebCore::ImageFrame::DisposeNotSpecified)
         , localColormapPosition(0)
         , localColormapSize(0)
         , datasize(0)
@@ -245,7 +246,7 @@ public:
     {
     }
 
-    void setData(WebCore::SharedBuffer* data) { m_data = data; }
+    void setData(PassRefPtr<WebCore::SharedBuffer> data) { m_data = data; }
     // FIXME: haltAtFrame should be size_t.
     bool decode(WebCore::GIFImageDecoder::GIFQuery, unsigned haltAtFrame);
 
@@ -322,3 +323,5 @@ private:
     RefPtr<WebCore::SharedBuffer> m_data;
     bool m_parseCompleted;
 };
+
+#endif
diff --git a/Source/WebCore/platform/image-decoders/ico/ICOImageDecoder.cpp b/Source/WebCore/platform/image-decoders/ico/ICOImageDecoder.cpp
index d0a2aff652d..56ac921cd08 100644
--- a/Source/WebCore/platform/image-decoders/ico/ICOImageDecoder.cpp
+++ b/Source/WebCore/platform/image-decoders/ico/ICOImageDecoder.cpp
@@ -44,7 +44,8 @@ namespace WebCore {
 static const size_t sizeOfDirectory = 6;
 static const size_t sizeOfDirEntry = 16;
 
-ICOImageDecoder::ICOImageDecoder(AlphaOption alphaOption, GammaAndColorProfileOption gammaAndColorProfileOption)
+ICOImageDecoder::ICOImageDecoder(ImageSource::AlphaOption alphaOption,
+                                 ImageSource::GammaAndColorProfileOption gammaAndColorProfileOption)
     : ImageDecoder(alphaOption, gammaAndColorProfileOption)
     , m_decodedOffset(0)
 {
@@ -54,7 +55,7 @@ ICOImageDecoder::~ICOImageDecoder()
 {
 }
 
-void ICOImageDecoder::setData(SharedBuffer& data, bool allDataReceived)
+void ICOImageDecoder::setData(SharedBuffer* data, bool allDataReceived)
 {
     if (failed())
         return;
@@ -63,7 +64,7 @@ void ICOImageDecoder::setData(SharedBuffer& data, bool allDataReceived)
 
     for (BMPReaders::iterator i(m_bmpReaders.begin()); i != m_bmpReaders.end(); ++i) {
         if (*i)
-            (*i)->setData(&data);
+            (*i)->setData(data);
     }
     for (size_t i = 0; i < m_pngDecoders.size(); ++i)
         setDataForPNGDecoderAtIndex(i);
@@ -77,26 +78,34 @@ bool ICOImageDecoder::isSizeAvailable()
     return ImageDecoder::isSizeAvailable();
 }
 
-IntSize ICOImageDecoder::size()
+IntSize ICOImageDecoder::size() const
 {
     return m_frameSize.isEmpty() ? ImageDecoder::size() : m_frameSize;
 }
 
-IntSize ICOImageDecoder::frameSizeAtIndex(size_t index, SubsamplingLevel)
+IntSize ICOImageDecoder::frameSizeAtIndex(size_t index) const
 {
     return (index && (index < m_dirEntries.size())) ? m_dirEntries[index].m_size : size();
 }
 
-bool ICOImageDecoder::setSize(const IntSize& size)
+bool ICOImageDecoder::setSize(unsigned width, unsigned height)
 {
     // The size calculated inside the BMPImageReader had better match the one in
     // the icon directory.
-    return m_frameSize.isEmpty() ? ImageDecoder::setSize(size) : ((size == m_frameSize) || setFailed());
+    return m_frameSize.isEmpty() ? ImageDecoder::setSize(width, height) : ((IntSize(width, height) == m_frameSize) || setFailed());
 }
 
-size_t ICOImageDecoder::frameCount() const
+size_t ICOImageDecoder::frameCount()
 {
-    const_cast<ICOImageDecoder*>(this)->decode(0, true);
+    decode(0, true);
+    if (m_frameBufferCache.isEmpty()) {
+        m_frameBufferCache.resize(m_dirEntries.size());
+        for (size_t i = 0; i < m_dirEntries.size(); ++i)
+            m_frameBufferCache[i].setPremultiplyAlpha(m_premultiplyAlpha);
+    }
+    // CAUTION: We must not resize m_frameBufferCache again after this, as
+    // decodeAtIndex() may give a BMPImageReader a pointer to one of the
+    // entries.
     return m_frameBufferCache.size();
 }
 
@@ -107,7 +116,7 @@ ImageFrame* ICOImageDecoder::frameBufferAtIndex(size_t index)
         return 0;
 
     ImageFrame* buffer = &m_frameBufferCache[index];
-    if (!buffer->isComplete())
+    if (buffer->status() != ImageFrame::FrameComplete)
         decode(index, false);
     return buffer;
 }
@@ -119,20 +128,21 @@ bool ICOImageDecoder::setFailed()
     return ImageDecoder::setFailed();
 }
 
-Optional<IntPoint> ICOImageDecoder::hotSpot() const
+bool ICOImageDecoder::hotSpot(IntPoint& hotSpot) const
 {
     // When unspecified, the default frame is always frame 0. This is consistent with
     // BitmapImage where currentFrame() starts at 0 and only increases when animation is
     // requested.
-    return hotSpotAtIndex(0);
+    return hotSpotAtIndex(0, hotSpot);
 }
 
-Optional<IntPoint> ICOImageDecoder::hotSpotAtIndex(size_t index) const
+bool ICOImageDecoder::hotSpotAtIndex(size_t index, IntPoint& hotSpot) const
 {
     if (index >= m_dirEntries.size() || m_fileType != CURSOR)
-        return Nullopt;
+        return false;
 
-    return m_dirEntries[index].m_hotSpot;
+    hotSpot = m_dirEntries[index].m_hotSpot;
+    return true;
 }
 
 
@@ -155,7 +165,7 @@ void ICOImageDecoder::setDataForPNGDecoderAtIndex(size_t index)
     // FIXME: Save this copy by making the PNG decoder able to take an
     // optional offset.
     RefPtr<SharedBuffer> pngData(SharedBuffer::create(&m_data->data()[dirEntry.m_imageOffset], m_data->size() - dirEntry.m_imageOffset));
-    m_pngDecoders[index]->setData(*pngData, isAllDataReceived());
+    m_pngDecoders[index]->setData(pngData.get(), isAllDataReceived());
 }
 
 void ICOImageDecoder::decode(size_t index, bool onlySize)
@@ -170,16 +180,10 @@ void ICOImageDecoder::decode(size_t index, bool onlySize)
     // If we're done decoding this frame, we don't need the BMPImageReader or
     // PNGImageDecoder anymore.  (If we failed, these have already been
     // cleared.)
-    else if ((m_frameBufferCache.size() > index) && m_frameBufferCache[index].isComplete()) {
+    else if ((m_frameBufferCache.size() > index) && (m_frameBufferCache[index].status() == ImageFrame::FrameComplete)) {
         m_bmpReaders[index] = nullptr;
         m_pngDecoders[index] = nullptr;
     }
-    
-    if (m_frameBufferCache.isEmpty())
-        m_frameBufferCache.resize(m_dirEntries.size());
-    // CAUTION: We must not resize m_frameBufferCache again after this, as
-    // decodeAtIndex() may give a BMPImageReader a pointer to one of the
-    // entries.
 }
 
 bool ICOImageDecoder::decodeDirectory()
@@ -217,8 +221,8 @@ bool ICOImageDecoder::decodeAtIndex(size_t index)
 
     if (!m_pngDecoders[index]) {
         m_pngDecoders[index] = std::make_unique<
-            PNGImageDecoder>(m_premultiplyAlpha ? AlphaOption::Premultiplied : AlphaOption::NotPremultiplied,
-                m_ignoreGammaAndColorProfile ? GammaAndColorProfileOption::Ignored : GammaAndColorProfileOption::Applied);
+            PNGImageDecoder>(m_premultiplyAlpha ? ImageSource::AlphaPremultiplied : ImageSource::AlphaNotPremultiplied,
+                m_ignoreGammaAndColorProfile ? ImageSource::GammaAndColorProfileIgnored : ImageSource::GammaAndColorProfileApplied);
         setDataForPNGDecoderAtIndex(index);
     }
     // Fail if the size the PNGImageDecoder calculated does not match the size
@@ -276,7 +280,7 @@ bool ICOImageDecoder::processDirectoryEntries()
     const IconDirectoryEntry& dirEntry = m_dirEntries.first();
     // Technically, this next call shouldn't be able to fail, since the width
     // and height here are each <= 256, and |m_frameSize| is empty.
-    return setSize(dirEntry.m_size);
+    return setSize(dirEntry.m_size.width(), dirEntry.m_size.height());
 }
 
 ICOImageDecoder::IconDirectoryEntry ICOImageDecoder::readDirectoryEntry()
diff --git a/Source/WebCore/platform/image-decoders/ico/ICOImageDecoder.h b/Source/WebCore/platform/image-decoders/ico/ICOImageDecoder.h
index 2d47a7bc59e..1494797a9bf 100644
--- a/Source/WebCore/platform/image-decoders/ico/ICOImageDecoder.h
+++ b/Source/WebCore/platform/image-decoders/ico/ICOImageDecoder.h
@@ -28,7 +28,8 @@
  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-#pragma once
+#ifndef ICOImageDecoder_h
+#define ICOImageDecoder_h
 
 #include "BMPImageReader.h"
 
@@ -37,25 +38,25 @@ namespace WebCore {
     class PNGImageDecoder;
 
     // This class decodes the ICO and CUR image formats.
-    class ICOImageDecoder final : public ImageDecoder {
+    class ICOImageDecoder : public ImageDecoder {
     public:
-        ICOImageDecoder(AlphaOption, GammaAndColorProfileOption);
+        ICOImageDecoder(ImageSource::AlphaOption, ImageSource::GammaAndColorProfileOption);
         virtual ~ICOImageDecoder();
 
         // ImageDecoder
-        String filenameExtension() const override { return "ico"; }
-        void setData(SharedBuffer&, bool allDataReceived) override;
-        bool isSizeAvailable() override;
-        IntSize size() override;
-        IntSize frameSizeAtIndex(size_t, SubsamplingLevel) override;
-        bool setSize(const IntSize&) override;
-        size_t frameCount() const override;
-        ImageFrame* frameBufferAtIndex(size_t) override;
+        virtual String filenameExtension() const { return "ico"; }
+        virtual void setData(SharedBuffer*, bool allDataReceived);
+        virtual bool isSizeAvailable();
+        virtual IntSize size() const;
+        virtual IntSize frameSizeAtIndex(size_t) const;
+        virtual bool setSize(unsigned width, unsigned height);
+        virtual size_t frameCount();
+        virtual ImageFrame* frameBufferAtIndex(size_t);
         // CAUTION: setFailed() deletes all readers and decoders.  Be careful to
         // avoid accessing deleted memory, especially when calling this from
         // inside BMPImageReader!
-        bool setFailed() override;
-        Optional<IntPoint> hotSpot() const override;
+        virtual bool setFailed();
+        virtual bool hotSpot(IntPoint&) const;
 
     private:
         enum ImageType {
@@ -115,8 +116,9 @@ namespace WebCore {
         // could be decoded.
         bool processDirectoryEntries();
 
-        // Returns the hot-spot for |index|, returns Nullopt if there is none.
-        Optional<IntPoint> hotSpotAtIndex(size_t) const;
+        // Stores the hot-spot for |index| in |hotSpot| and returns true,
+        // or returns false if there is none.
+        bool hotSpotAtIndex(size_t index, IntPoint& hotSpot) const;
 
         // Reads and returns a directory entry from the current offset into
         // |data|.
@@ -150,3 +152,5 @@ namespace WebCore {
     };
 
 } // namespace WebCore
+
+#endif
diff --git a/Source/WebCore/platform/image-decoders/jpeg/JPEGImageDecoder.cpp b/Source/WebCore/platform/image-decoders/jpeg/JPEGImageDecoder.cpp
index 40bd88bbc2d..ee66ac14d4b 100644
--- a/Source/WebCore/platform/image-decoders/jpeg/JPEGImageDecoder.cpp
+++ b/Source/WebCore/platform/image-decoders/jpeg/JPEGImageDecoder.cpp
@@ -196,6 +196,36 @@ static ImageOrientation readImageOrientation(jpeg_decompress_struct* info)
     return ImageOrientation();
 }
 
+static ColorProfile readColorProfile(jpeg_decompress_struct* info)
+{
+#if USE(ICCJPEG)
+    JOCTET* profile;
+    unsigned int profileLength;
+
+    if (!read_icc_profile(info, &profile, &profileLength))
+        return ColorProfile();
+
+    // Only accept RGB color profiles from input class devices.
+    bool ignoreProfile = false;
+    char* profileData = reinterpret_cast<char*>(profile);
+    if (profileLength < ImageDecoder::iccColorProfileHeaderLength)
+        ignoreProfile = true;
+    else if (!ImageDecoder::rgbColorProfile(profileData, profileLength))
+        ignoreProfile = true;
+    else if (!ImageDecoder::inputDeviceColorProfile(profileData, profileLength))
+        ignoreProfile = true;
+
+    ColorProfile colorProfile;
+    if (!ignoreProfile)
+        colorProfile.append(profileData, profileLength);
+    free(profile);
+    return colorProfile;
+#else
+    UNUSED_PARAM(info);
+    return ColorProfile();
+#endif
+}
+
 class JPEGImageReader {
     WTF_MAKE_FAST_ALLOCATED;
 public:
@@ -322,7 +352,7 @@ public:
             m_state = JPEG_START_DECOMPRESS;
 
             // We can fill in the size now that the header is available.
-            if (!m_decoder->setSize(IntSize(m_info.image_width, m_info.image_height)))
+            if (!m_decoder->setSize(m_info.image_width, m_info.image_height))
                 return false;
 
             m_decoder->setOrientation(readImageOrientation(info()));
@@ -333,6 +363,13 @@ public:
             if (m_decoder->willDownSample() && turboSwizzled(m_info.out_color_space))
                 m_info.out_color_space = JCS_RGB;
 #endif
+            // Allow color management of the decoded RGBA pixels if possible.
+            if (!m_decoder->ignoresGammaAndColorProfile()) {
+                ColorProfile rgbInputDeviceColorProfile = readColorProfile(info());
+                if (!rgbInputDeviceColorProfile.isEmpty())
+                    m_decoder->setColorProfile(rgbInputDeviceColorProfile);
+            }
+
             // Don't allocate a giant and superfluous memory buffer when the
             // image is a sequential JPEG.
             m_info.buffered_image = jpeg_has_multiple_scans(&m_info);
@@ -501,7 +538,8 @@ void term_source(j_decompress_ptr jd)
     src->decoder->decoder()->jpegComplete();
 }
 
-JPEGImageDecoder::JPEGImageDecoder(AlphaOption alphaOption, GammaAndColorProfileOption gammaAndColorProfileOption)
+JPEGImageDecoder::JPEGImageDecoder(ImageSource::AlphaOption alphaOption,
+                                   ImageSource::GammaAndColorProfileOption gammaAndColorProfileOption)
     : ImageDecoder(alphaOption, gammaAndColorProfileOption)
 {
 }
@@ -518,9 +556,9 @@ bool JPEGImageDecoder::isSizeAvailable()
     return ImageDecoder::isSizeAvailable();
 }
 
-bool JPEGImageDecoder::setSize(const IntSize& size)
+bool JPEGImageDecoder::setSize(unsigned width, unsigned height)
 {
-    if (!ImageDecoder::setSize(size))
+    if (!ImageDecoder::setSize(width, height))
         return false;
 
     prepareScaleDataIfNecessary();
@@ -532,11 +570,13 @@ ImageFrame* JPEGImageDecoder::frameBufferAtIndex(size_t index)
     if (index)
         return 0;
 
-    if (m_frameBufferCache.isEmpty())
+    if (m_frameBufferCache.isEmpty()) {
         m_frameBufferCache.resize(1);
+        m_frameBufferCache[0].setPremultiplyAlpha(m_premultiplyAlpha);
+    }
 
     ImageFrame& frame = m_frameBufferCache[0];
-    if (!frame.isComplete())
+    if (frame.status() != ImageFrame::FrameComplete)
         decode(false);
     return &frame;
 }
@@ -548,13 +588,13 @@ bool JPEGImageDecoder::setFailed()
 }
 
 template <J_COLOR_SPACE colorSpace>
-void setPixel(ImageFrame& buffer, RGBA32* currentAddress, JSAMPARRAY samples, int column)
+void setPixel(ImageFrame& buffer, ImageFrame::PixelData* currentAddress, JSAMPARRAY samples, int column)
 {
     JSAMPLE* jsample = *samples + column * (colorSpace == JCS_RGB ? 3 : 4);
 
     switch (colorSpace) {
     case JCS_RGB:
-        buffer.backingStore()->setPixel(currentAddress, jsample[0], jsample[1], jsample[2], 0xFF);
+        buffer.setRGBA(currentAddress, jsample[0], jsample[1], jsample[2], 0xFF);
         break;
     case JCS_CMYK:
         // Source is 'Inverted CMYK', output is RGB.
@@ -567,7 +607,7 @@ void setPixel(ImageFrame& buffer, RGBA32* currentAddress, JSAMPARRAY samples, in
         // From CMY (0..1) to RGB (0..1):
         // R = 1 - C => 1 - (1 - iC*iK) => iC*iK  [G and B similar]
         unsigned k = jsample[3];
-        buffer.backingStore()->setPixel(currentAddress, jsample[0] * k / 255, jsample[1] * k / 255, jsample[2] * k / 255, 0xFF);
+        buffer.setRGBA(currentAddress, jsample[0] * k / 255, jsample[1] * k / 255, jsample[2] * k / 255, 0xFF);
         break;
     }
 }
@@ -591,7 +631,7 @@ bool JPEGImageDecoder::outputScanlines(ImageFrame& buffer)
         if (destY < 0)
             continue;
 
-        RGBA32* currentAddress = buffer.backingStore()->pixelAt(0, destY);
+        ImageFrame::PixelData* currentAddress = buffer.getAddr(0, destY);
         for (int x = 0; x < width; ++x) {
             setPixel<colorSpace>(buffer, currentAddress, samples, isScaled ? m_scaledColumns[x] : x);
             ++currentAddress;
@@ -613,13 +653,17 @@ bool JPEGImageDecoder::outputScanlines()
 
     // Initialize the framebuffer if needed.
     ImageFrame& buffer = m_frameBufferCache[0];
-    if (buffer.isEmpty()) {
-        if (!buffer.initialize(scaledSize(), m_premultiplyAlpha))
+    if (buffer.status() == ImageFrame::FrameEmpty) {
+        if (!buffer.setSize(scaledSize().width(), scaledSize().height()))
             return setFailed();
-        buffer.setDecoding(ImageFrame::Decoding::Partial);
+        buffer.setStatus(ImageFrame::FramePartial);
         // The buffer is transparent outside the decoded area while the image is
         // loading. The completed image will be marked fully opaque in jpegComplete().
         buffer.setHasAlpha(true);
+        buffer.setColorProfile(m_colorProfile);
+
+        // For JPEGs, the frame always fills the entire image.
+        buffer.setOriginalFrameRect(IntRect(IntPoint(), size()));
     }
 
     jpeg_decompress_struct* info = m_reader->info();
@@ -627,7 +671,7 @@ bool JPEGImageDecoder::outputScanlines()
 #if defined(TURBO_JPEG_RGB_SWIZZLE)
     if (!m_scaled && turboSwizzled(info->out_color_space)) {
         while (info->output_scanline < info->output_height) {
-            unsigned char* row = reinterpret_cast<unsigned char*>(buffer.backingStore()->pixelAt(0, info->output_scanline));
+            unsigned char* row = reinterpret_cast<unsigned char*>(buffer.getAddr(0, info->output_scanline));
             if (jpeg_read_scanlines(info, &row, 1) != 1)
                 return false;
          }
@@ -660,7 +704,7 @@ void JPEGImageDecoder::jpegComplete()
     // empty.
     ImageFrame& buffer = m_frameBufferCache[0];
     buffer.setHasAlpha(false);
-    buffer.setDecoding(ImageFrame::Decoding::Complete);
+    buffer.setStatus(ImageFrame::FrameComplete);
 }
 
 void JPEGImageDecoder::decode(bool onlySize)
@@ -677,7 +721,7 @@ void JPEGImageDecoder::decode(bool onlySize)
         setFailed();
     // If we're done decoding the image, we don't need the JPEGImageReader
     // anymore.  (If we failed, |m_reader| has already been cleared.)
-    else if (!m_frameBufferCache.isEmpty() && (m_frameBufferCache[0].isComplete()))
+    else if (!m_frameBufferCache.isEmpty() && (m_frameBufferCache[0].status() == ImageFrame::FrameComplete))
         m_reader = nullptr;
 }
 
diff --git a/Source/WebCore/platform/image-decoders/jpeg/JPEGImageDecoder.h b/Source/WebCore/platform/image-decoders/jpeg/JPEGImageDecoder.h
index 2d79532af92..b14e9ca7751 100644
--- a/Source/WebCore/platform/image-decoders/jpeg/JPEGImageDecoder.h
+++ b/Source/WebCore/platform/image-decoders/jpeg/JPEGImageDecoder.h
@@ -24,7 +24,8 @@
  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
  */
 
-#pragma once
+#ifndef JPEGImageDecoder_h
+#define JPEGImageDecoder_h
 
 #include "ImageDecoder.h"
 #include <stdio.h> // Needed by jpeglib.h for FILE.
@@ -41,20 +42,20 @@ namespace WebCore {
     class JPEGImageReader;
 
     // This class decodes the JPEG image format.
-    class JPEGImageDecoder final : public ImageDecoder {
+    class JPEGImageDecoder : public ImageDecoder {
     public:
-        JPEGImageDecoder(AlphaOption, GammaAndColorProfileOption);
+        JPEGImageDecoder(ImageSource::AlphaOption, ImageSource::GammaAndColorProfileOption);
         virtual ~JPEGImageDecoder();
 
         // ImageDecoder
-        String filenameExtension() const override { return "jpg"; }
-        bool isSizeAvailable() override;
-        bool setSize(const IntSize&) override;
-        ImageFrame* frameBufferAtIndex(size_t index) override;
+        virtual String filenameExtension() const { return "jpg"; }
+        virtual bool isSizeAvailable();
+        virtual bool setSize(unsigned width, unsigned height);
+        virtual ImageFrame* frameBufferAtIndex(size_t index);
         // CAUTION: setFailed() deletes |m_reader|.  Be careful to avoid
         // accessing deleted memory, especially when calling this from inside
         // JPEGImageReader!
-        bool setFailed() override;
+        virtual bool setFailed();
 
         bool willDownSample()
         {
@@ -65,6 +66,7 @@ namespace WebCore {
         bool outputScanlines();
         void jpegComplete();
 
+        void setColorProfile(const ColorProfile& colorProfile) { m_colorProfile = colorProfile; }
         void setOrientation(ImageOrientation orientation) { m_orientation = orientation; }
 
     private:
@@ -83,3 +85,5 @@ namespace WebCore {
     };
 
 } // namespace WebCore
+
+#endif
diff --git a/Source/WebCore/platform/image-decoders/png/PNGImageDecoder.cpp b/Source/WebCore/platform/image-decoders/png/PNGImageDecoder.cpp
index 1c53b2d5b86..e644a7110ef 100644
--- a/Source/WebCore/platform/image-decoders/png/PNGImageDecoder.cpp
+++ b/Source/WebCore/platform/image-decoders/png/PNGImageDecoder.cpp
@@ -193,7 +193,7 @@ private:
     png_bytep m_interlaceBuffer;
 };
 
-PNGImageDecoder::PNGImageDecoder(AlphaOption alphaOption, GammaAndColorProfileOption gammaAndColorProfileOption)
+PNGImageDecoder::PNGImageDecoder(ImageSource::AlphaOption alphaOption, ImageSource::GammaAndColorProfileOption gammaAndColorProfileOption)
     : ImageDecoder(alphaOption, gammaAndColorProfileOption)
     , m_doNothingOnFailure(false)
     , m_currentFrame(0)
@@ -235,9 +235,9 @@ bool PNGImageDecoder::isSizeAvailable()
     return ImageDecoder::isSizeAvailable();
 }
 
-bool PNGImageDecoder::setSize(const IntSize& size)
+bool PNGImageDecoder::setSize(unsigned width, unsigned height)
 {
-    if (!ImageDecoder::setSize(size))
+    if (!ImageDecoder::setSize(width, height))
         return false;
 
     prepareScaleDataIfNecessary();
@@ -257,11 +257,13 @@ ImageFrame* PNGImageDecoder::frameBufferAtIndex(size_t index)
         return nullptr;
 #endif
 
-    if (m_frameBufferCache.isEmpty())
+    if (m_frameBufferCache.isEmpty()) {
         m_frameBufferCache.resize(1);
+        m_frameBufferCache[0].setPremultiplyAlpha(m_premultiplyAlpha);
+    }
 
     ImageFrame& frame = m_frameBufferCache[index];
-    if (!frame.isComplete())
+    if (frame.status() != ImageFrame::FrameComplete)
         decode(false, index);
     return &frame;
 }
@@ -274,6 +276,37 @@ bool PNGImageDecoder::setFailed()
     return ImageDecoder::setFailed();
 }
 
+static void readColorProfile(png_structp png, png_infop info, ColorProfile& colorProfile)
+{
+    ASSERT(colorProfile.isEmpty());
+
+#ifdef PNG_iCCP_SUPPORTED
+    char* profileName;
+    int compressionType;
+#if (PNG_LIBPNG_VER < 10500)
+    png_charp profile;
+#else
+    png_bytep profile;
+#endif
+    png_uint_32 profileLength;
+    if (!png_get_iCCP(png, info, &profileName, &compressionType, &profile, &profileLength))
+        return;
+
+    // Only accept RGB color profiles from input class devices.
+    bool ignoreProfile = false;
+    char* profileData = reinterpret_cast<char*>(profile);
+    if (profileLength < ImageDecoder::iccColorProfileHeaderLength)
+        ignoreProfile = true;
+    else if (!ImageDecoder::rgbColorProfile(profileData, profileLength))
+        ignoreProfile = true;
+    else if (!ImageDecoder::inputDeviceColorProfile(profileData, profileLength))
+        ignoreProfile = true;
+
+    if (!ignoreProfile)
+        colorProfile.append(profileData, profileLength);
+#endif
+}
+
 void PNGImageDecoder::headerAvailable()
 {
     png_structp png = m_reader->pngPtr();
@@ -293,7 +326,7 @@ void PNGImageDecoder::headerAvailable()
     // will cease to exist.  Note that we'll still properly set the failure flag
     // in this case as soon as we longjmp().
     m_doNothingOnFailure = true;
-    bool result = setSize(IntSize(width, height));
+    bool result = setSize(width, height);
     m_doNothingOnFailure = false;
     if (!result) {
         longjmp(JMPBUF(png), 1);
@@ -372,6 +405,16 @@ void PNGImageDecoder::headerAvailable()
     if (colorType == PNG_COLOR_TYPE_GRAY || colorType == PNG_COLOR_TYPE_GRAY_ALPHA)
         png_set_gray_to_rgb(png);
 
+    if ((colorType & PNG_COLOR_MASK_COLOR) && !m_ignoreGammaAndColorProfile) {
+        // We only support color profiles for color PALETTE and RGB[A] PNG. Supporting
+        // color profiles for gray-scale images is slightly tricky, at least using the
+        // CoreGraphics ICC library, because we expand gray-scale images to RGB but we
+        // do not similarly transform the color profile. We'd either need to transform
+        // the color profile or we'd need to decode into a gray-scale image buffer and
+        // hand that to CoreGraphics.
+        readColorProfile(png, info, m_colorProfile);
+    }
+
     // Deal with gamma and keep it under our control.
     double gamma;
     if (!m_ignoreGammaAndColorProfile && png_get_gAMA(png, info, &gamma)) {
@@ -409,6 +452,29 @@ void PNGImageDecoder::headerAvailable()
     }
 }
 
+static inline void setPixelRGB(ImageFrame::PixelData* dest, png_bytep pixel)
+{
+    *dest = 0xFF000000U | pixel[0] << 16 | pixel[1] << 8 | pixel[2];
+}
+
+static inline void setPixelRGBA(ImageFrame::PixelData* dest, png_bytep pixel, unsigned char& nonTrivialAlphaMask)
+{
+    unsigned char a = pixel[3];
+    *dest = a << 24 | pixel[0] << 16 | pixel[1] << 8 | pixel[2];
+    nonTrivialAlphaMask |= (255 - a);
+}
+
+static inline void setPixelPremultipliedRGBA(ImageFrame::PixelData* dest, png_bytep pixel, unsigned char& nonTrivialAlphaMask)
+{
+    unsigned char a = pixel[3];
+    unsigned char r = fastDivideBy255(pixel[0] * a);
+    unsigned char g = fastDivideBy255(pixel[1] * a);
+    unsigned char b = fastDivideBy255(pixel[2] * a);
+
+    *dest = a << 24 | r << 16 | g << 8 | b;
+    nonTrivialAlphaMask |= (255 - a);
+}
+
 void PNGImageDecoder::rowAvailable(unsigned char* rowBuffer, unsigned rowIndex, int)
 {
     if (m_frameBufferCache.isEmpty())
@@ -420,9 +486,9 @@ void PNGImageDecoder::rowAvailable(unsigned char* rowBuffer, unsigned rowIndex,
         return;
 #endif
     ImageFrame& buffer = m_frameBufferCache[m_currentFrame];
-    if (buffer.isEmpty()) {
+    if (buffer.status() == ImageFrame::FrameEmpty) {
         png_structp png = m_reader->pngPtr();
-        if (!buffer.initialize(scaledSize(), m_premultiplyAlpha)) {
+        if (!buffer.setSize(scaledSize().width(), scaledSize().height())) {
             longjmp(JMPBUF(png), 1);
             return;
         }
@@ -438,13 +504,17 @@ void PNGImageDecoder::rowAvailable(unsigned char* rowBuffer, unsigned rowIndex,
             }
         }
 
-        buffer.setDecoding(ImageFrame::Decoding::Partial);
+        buffer.setStatus(ImageFrame::FramePartial);
         buffer.setHasAlpha(false);
+        buffer.setColorProfile(m_colorProfile);
 
 #if ENABLE(APNG)
         if (m_currentFrame)
             initFrameBuffer(m_currentFrame);
+        else
 #endif
+        // For PNGs, the frame always fills the entire image.
+        buffer.setOriginalFrameRect(IntRect(IntPoint(), size()));
     }
 
     /* libpng comments (here to explain what follows).
@@ -503,16 +573,16 @@ void PNGImageDecoder::rowAvailable(unsigned char* rowBuffer, unsigned rowIndex,
     }
 
     // Write the decoded row pixels to the frame buffer.
-    RGBA32* address = buffer.backingStore()->pixelAt(0, y);
+    ImageFrame::PixelData* address = buffer.getAddr(0, y);
     int width = scaledSize().width();
     unsigned char nonTrivialAlphaMask = 0;
 
 #if ENABLE(IMAGE_DECODER_DOWN_SAMPLING)
     if (m_scaled) {
-        for (int x = 0; x < width; ++x, ++address) {
+        for (int x = 0; x < width; ++x) {
             png_bytep pixel = row + m_scaledColumns[x] * colorChannels;
             unsigned alpha = hasAlpha ? pixel[3] : 255;
-            buffer.backingStore()->setPixel(address, pixel[0], pixel[1], pixel[2], alpha);
+            buffer.setRGBA(address++, pixel[0], pixel[1], pixel[2], alpha);
             nonTrivialAlphaMask |= (255 - alpha);
         }
     } else
@@ -520,17 +590,20 @@ void PNGImageDecoder::rowAvailable(unsigned char* rowBuffer, unsigned rowIndex,
     {
         png_bytep pixel = row;
         if (hasAlpha) {
-            for (int x = 0; x < width; ++x, pixel += 4, ++address) {
-                unsigned alpha = pixel[3];
-                buffer.backingStore()->setPixel(address, pixel[0], pixel[1], pixel[2], alpha);
-                nonTrivialAlphaMask |= (255 - alpha);
+            if (buffer.premultiplyAlpha()) {
+                for (int x = 0; x < width; ++x, pixel += 4)
+                    setPixelPremultipliedRGBA(address++, pixel, nonTrivialAlphaMask);
+            } else {
+                for (int x = 0; x < width; ++x, pixel += 4)
+                    setPixelRGBA(address++, pixel, nonTrivialAlphaMask);
             }
         } else {
-            for (int x = 0; x < width; ++x, pixel += 3, ++address)
-                *address = makeRGB(pixel[0], pixel[1], pixel[2]);
+            for (int x = 0; x < width; ++x, pixel += 3)
+                setPixelRGB(address++, pixel);
         }
     }
 
+
     if (nonTrivialAlphaMask && !buffer.hasAlpha())
         buffer.setHasAlpha(true);
 }
@@ -546,7 +619,7 @@ void PNGImageDecoder::pngComplete()
     }
 #endif
     if (!m_frameBufferCache.isEmpty())
-        m_frameBufferCache.first().setDecoding(ImageFrame::Decoding::Complete);
+        m_frameBufferCache.first().setStatus(ImageFrame::FrameComplete);
 }
 
 void PNGImageDecoder::decode(bool onlySize, unsigned haltAtFrame)
@@ -590,6 +663,8 @@ void PNGImageDecoder::readChunks(png_unknown_chunkp chunk)
             return;
 
         m_frameBufferCache.resize(m_frameCount);
+        for (auto& imageFrame : m_frameBufferCache)
+            imageFrame.setPremultiplyAlpha(m_premultiplyAlpha);
     } else if (!memcmp(chunk->name, "fcTL", 4) && chunk->size == 26) {
         if (m_hasInfo && !m_isAnimated)
             return;
@@ -631,8 +706,10 @@ void PNGImageDecoder::readChunks(png_unknown_chunkp chunk)
             return;
         }
 
-        if (m_frameBufferCache.isEmpty())
+        if (m_frameBufferCache.isEmpty()) {
             m_frameBufferCache.resize(1);
+            m_frameBufferCache[0].setPremultiplyAlpha(m_premultiplyAlpha);
+        }
 
         if (m_currentFrame < m_frameBufferCache.size()) {
             ImageFrame& buffer = m_frameBufferCache[m_currentFrame];
@@ -643,11 +720,11 @@ void PNGImageDecoder::readChunks(png_unknown_chunkp chunk)
                 buffer.setDuration(m_delayNumerator * 1000 / m_delayDenominator);
 
             if (m_dispose == 2)
-                buffer.setDisposalMethod(ImageFrame::DisposalMethod::RestoreToPrevious);
+                buffer.setDisposalMethod(ImageFrame::DisposeOverwritePrevious);
             else if (m_dispose == 1)
-                buffer.setDisposalMethod(ImageFrame::DisposalMethod::RestoreToBackground);
+                buffer.setDisposalMethod(ImageFrame::DisposeOverwriteBgcolor);
             else
-                buffer.setDisposalMethod(ImageFrame::DisposalMethod::DoNotDispose);
+                buffer.setDisposalMethod(ImageFrame::DisposeKeep);
         }
 
         m_frameInfo = true;
@@ -730,16 +807,16 @@ void PNGImageDecoder::clearFrameBufferCache(size_t clearBeforeFrame)
     const Vector<ImageFrame>::iterator end(m_frameBufferCache.begin() + clearBeforeFrame);
 
     Vector<ImageFrame>::iterator i(end);
-    for (; (i != m_frameBufferCache.begin()) && (i->isEmpty() || (i->disposalMethod() == ImageFrame::DisposalMethod::RestoreToPrevious)); --i) {
-        if (i->isComplete() && (i != end))
-            i->clear();
+    for (; (i != m_frameBufferCache.begin()) && ((i->status() == ImageFrame::FrameEmpty) || (i->disposalMethod() == ImageFrame::DisposeOverwritePrevious)); --i) {
+        if ((i->status() == ImageFrame::FrameComplete) && (i != end))
+            i->clearPixelData();
     }
 
     // Now |i| holds the last frame we need to preserve; clear prior frames.
     for (Vector<ImageFrame>::iterator j(m_frameBufferCache.begin()); j != i; ++j) {
-        ASSERT(!j->isPartial());
-        if (j->isEmpty())
-            j->clear();
+        ASSERT(j->status() != ImageFrame::FramePartial);
+        if (j->status() != ImageFrame::FrameEmpty)
+            j->clearPixelData();
     }
 }
 
@@ -748,63 +825,54 @@ void PNGImageDecoder::initFrameBuffer(size_t frameIndex)
     if (frameIndex >= frameCount())
         return;
 
+    IntRect frameRect(m_xOffset, m_yOffset, m_width, m_height);
+
+    // Make sure the frameRect doesn't extend outside the buffer.
+    if (frameRect.maxX() > size().width())
+        frameRect.setWidth(size().width() - m_xOffset);
+    if (frameRect.maxY() > size().height())
+        frameRect.setHeight(size().height() - m_yOffset);
+
     ImageFrame& buffer = m_frameBufferCache[frameIndex];
+    int left = upperBoundScaledX(frameRect.x());
+    int right = lowerBoundScaledX(frameRect.maxX(), left);
+    int top = upperBoundScaledY(frameRect.y());
+    int bottom = lowerBoundScaledY(frameRect.maxY(), top);
+    buffer.setOriginalFrameRect(IntRect(left, top, right - left, bottom - top));
 
     // The starting state for this frame depends on the previous frame's
     // disposal method.
     //
-    // Frames that use the DisposalMethod::RestoreToPrevious method are effectively
+    // Frames that use the DisposeOverwritePrevious method are effectively
     // no-ops in terms of changing the starting state of a frame compared to
     // the starting state of the previous frame, so skip over them.  (If the
     // first frame specifies this method, it will get treated like
     // DisposeOverwriteBgcolor below and reset to a completely empty image.)
     const ImageFrame* prevBuffer = &m_frameBufferCache[--frameIndex];
-    ImageFrame::DisposalMethod prevMethod = prevBuffer->disposalMethod();
-    while (frameIndex && (prevMethod == ImageFrame::DisposalMethod::RestoreToPrevious)) {
+    ImageFrame::FrameDisposalMethod prevMethod = prevBuffer->disposalMethod();
+    while (frameIndex && (prevMethod == ImageFrame::DisposeOverwritePrevious)) {
         prevBuffer = &m_frameBufferCache[--frameIndex];
         prevMethod = prevBuffer->disposalMethod();
     }
+    ASSERT(prevBuffer->status() == ImageFrame::FrameComplete);
 
-    png_structp png = m_reader->pngPtr();
-    ASSERT(prevBuffer->isComplete());
-
-    if (prevMethod == ImageFrame::DisposalMethod::DoNotDispose) {
+    if (prevMethod == ImageFrame::DisposeKeep) {
         // Preserve the last frame as the starting state for this frame.
-        if (!prevBuffer->backingStore() || !buffer.initialize(*prevBuffer->backingStore()))
-            longjmp(JMPBUF(png), 1);
+        buffer.copyBitmapData(*prevBuffer);
     } else {
         // We want to clear the previous frame to transparent, without
         // affecting pixels in the image outside of the frame.
-        IntRect prevRect = prevBuffer->backingStore()->frameRect();
+        const IntRect& prevRect = prevBuffer->originalFrameRect();
         if (!frameIndex || prevRect.contains(IntRect(IntPoint(), scaledSize()))) {
             // Clearing the first frame, or a frame the size of the whole
             // image, results in a completely empty image.
-            buffer.backingStore()->clear();
-            buffer.setHasAlpha(true);
+            buffer.zeroFillPixelData();
         } else {
             // Copy the whole previous buffer, then clear just its frame.
-            if (!prevBuffer->backingStore() || !buffer.initialize(*prevBuffer->backingStore())) {
-                longjmp(JMPBUF(png), 1);
-                return;
-            }
-            buffer.backingStore()->clearRect(prevRect);
-            buffer.setHasAlpha(true);
+            buffer.copyBitmapData(*prevBuffer);
+            buffer.zeroFillFrameRect(prevRect);
         }
     }
-    
-    IntRect frameRect(m_xOffset, m_yOffset, m_width, m_height);
-
-    // Make sure the frameRect doesn't extend outside the buffer.
-    if (frameRect.maxX() > size().width())
-        frameRect.setWidth(size().width() - m_xOffset);
-    if (frameRect.maxY() > size().height())
-        frameRect.setHeight(size().height() - m_yOffset);
-
-    int left = upperBoundScaledX(frameRect.x());
-    int right = lowerBoundScaledX(frameRect.maxX(), left);
-    int top = upperBoundScaledY(frameRect.y());
-    int bottom = lowerBoundScaledY(frameRect.maxY(), top);
-    buffer.backingStore()->setFrameRect(IntRect(left, top, right - left, bottom - top));
 }
 
 void PNGImageDecoder::frameComplete()
@@ -813,12 +881,12 @@ void PNGImageDecoder::frameComplete()
         return;
 
     ImageFrame& buffer = m_frameBufferCache[m_currentFrame];
-    buffer.setDecoding(ImageFrame::Decoding::Complete);
+    buffer.setStatus(ImageFrame::FrameComplete);
 
     png_bytep interlaceBuffer = m_reader->interlaceBuffer();
 
     if (m_currentFrame && interlaceBuffer) {
-        IntRect rect = buffer.backingStore()->frameRect();
+        const IntRect& rect = buffer.originalFrameRect();
         bool hasAlpha = m_reader->hasAlpha();
         unsigned colorChannels = hasAlpha ? 4 : 3;
         bool nonTrivialAlpha = false;
@@ -828,15 +896,15 @@ void PNGImageDecoder::frameComplete()
 #if ENABLE(IMAGE_DECODER_DOWN_SAMPLING)
         for (int y = 0; y < rect.maxY() - rect.y(); ++y) {
             png_bytep row = interlaceBuffer + (m_scaled ? m_scaledRows[y] : y) * colorChannels * size().width();
-            RGBA32* address = buffer.backingStore()->pixelAt(rect.x(), y + rect.y());
+            ImageFrame::PixelData* address = buffer.getAddr(rect.x(), y + rect.y());
             for (int x = 0; x < rect.maxX() - rect.x(); ++x) {
                 png_bytep pixel = row + (m_scaled ? m_scaledColumns[x] : x) * colorChannels;
                 unsigned alpha = hasAlpha ? pixel[3] : 255;
                 nonTrivialAlpha |= alpha < 255;
                 if (!m_blend)
-                    buffer.backingStore()->setPixel(address++, pixel[0], pixel[1], pixel[2], alpha);
+                    buffer.setRGBA(address++, pixel[0], pixel[1], pixel[2], alpha);
                 else
-                    buffer.backingStore()->blendPixel(address++, pixel[0], pixel[1], pixel[2], alpha);
+                    buffer.overRGBA(address++, pixel[0], pixel[1], pixel[2], alpha);
             }
         }
 #else
@@ -844,30 +912,28 @@ void PNGImageDecoder::frameComplete()
         png_bytep row = interlaceBuffer;
         for (int y = rect.y(); y < rect.maxY(); ++y, row += colorChannels * size().width()) {
             png_bytep pixel = row;
-            RGBA32* address = buffer.backingStore()->pixelAt(rect.x(), y);
+            ImageFrame::PixelData* address = buffer.getAddr(rect.x(), y);
             for (int x = rect.x(); x < rect.maxX(); ++x, pixel += colorChannels) {
                 unsigned alpha = hasAlpha ? pixel[3] : 255;
                 nonTrivialAlpha |= alpha < 255;
                 if (!m_blend)
-                    buffer.backingStore()->setPixel(address++, pixel[0], pixel[1], pixel[2], alpha);
+                    buffer.setRGBA(address++, pixel[0], pixel[1], pixel[2], alpha);
                 else
-                    buffer.backingStore()->blendPixel(address++, pixel[0], pixel[1], pixel[2], alpha);
+                    buffer.overRGBA(address++, pixel[0], pixel[1], pixel[2], alpha);
             }
         }
 #endif
 
         if (!nonTrivialAlpha) {
-            IntRect rect = buffer.backingStore()->frameRect();
-            if (rect.contains(IntRect(IntPoint(), scaledSize())))
+            if (buffer.originalFrameRect().contains(IntRect(IntPoint(), scaledSize())))
                 buffer.setHasAlpha(false);
             else {
                 size_t frameIndex = m_currentFrame;
                 const ImageFrame* prevBuffer = &m_frameBufferCache[--frameIndex];
-                while (frameIndex && (prevBuffer->disposalMethod() == ImageFrame::DisposalMethod::RestoreToPrevious))
+                while (frameIndex && (prevBuffer->disposalMethod() == ImageFrame::DisposeOverwritePrevious))
                     prevBuffer = &m_frameBufferCache[--frameIndex];
-
-                IntRect prevRect = prevBuffer->backingStore()->frameRect();
-                if ((prevBuffer->disposalMethod() == ImageFrame::DisposalMethod::RestoreToBackground) && !prevBuffer->hasAlpha() && rect.contains(prevRect))
+                if ((prevBuffer->disposalMethod() == ImageFrame::DisposeOverwriteBgcolor)
+                    && !prevBuffer->hasAlpha() && buffer.originalFrameRect().contains(prevBuffer->originalFrameRect()))
                     buffer.setHasAlpha(false);
             }
         } else if (!m_blend && !buffer.hasAlpha())
diff --git a/Source/WebCore/platform/image-decoders/png/PNGImageDecoder.h b/Source/WebCore/platform/image-decoders/png/PNGImageDecoder.h
index 113ff2e3b7a..f9e5696caa4 100644
--- a/Source/WebCore/platform/image-decoders/png/PNGImageDecoder.h
+++ b/Source/WebCore/platform/image-decoders/png/PNGImageDecoder.h
@@ -23,7 +23,8 @@
  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
  */
 
-#pragma once
+#ifndef PNGImageDecoder_h
+#define PNGImageDecoder_h
 
 #include "ImageDecoder.h"
 #if ENABLE(APNG)
@@ -35,19 +36,19 @@ namespace WebCore {
     class PNGImageReader;
 
     // This class decodes the PNG image format.
-    class PNGImageDecoder final : public ImageDecoder {
+    class PNGImageDecoder : public ImageDecoder {
     public:
-        PNGImageDecoder(AlphaOption, GammaAndColorProfileOption);
+        PNGImageDecoder(ImageSource::AlphaOption, ImageSource::GammaAndColorProfileOption);
         virtual ~PNGImageDecoder();
 
         // ImageDecoder
         String filenameExtension() const override { return "png"; }
 #if ENABLE(APNG)
-        size_t frameCount() const override { return m_frameCount; }
-        RepetitionCount repetitionCount() const override { return m_playCount-1; }
+        size_t frameCount() override { return m_frameCount; }
+        int repetitionCount() const override { return m_playCount-1; }
 #endif
         bool isSizeAvailable() override;
-        bool setSize(const IntSize&) override;
+        bool setSize(unsigned width, unsigned height) override;
         ImageFrame* frameBufferAtIndex(size_t index) override;
         // CAUTION: setFailed() deletes |m_reader|.  Be careful to avoid
         // accessing deleted memory, especially when calling this from inside
@@ -72,7 +73,7 @@ namespace WebCore {
                 return false;
 
             for (auto& imageFrame : m_frameBufferCache) {
-                if (!imageFrame.isComplete())
+                if (imageFrame.status() != ImageFrame::FrameComplete)
                     return false;
             }
 
@@ -81,7 +82,7 @@ namespace WebCore {
 
         bool isCompleteAtIndex(size_t index)
         {
-            return (index < m_frameBufferCache.size() && m_frameBufferCache[index].isComplete());
+            return (index < m_frameBufferCache.size() && m_frameBufferCache[index].status() == ImageFrame::FrameComplete);
         }
 
     private:
@@ -129,3 +130,5 @@ namespace WebCore {
     };
 
 } // namespace WebCore
+
+#endif
diff --git a/Source/WebCore/platform/image-decoders/webp/WEBPImageDecoder.cpp b/Source/WebCore/platform/image-decoders/webp/WEBPImageDecoder.cpp
index 4a38f580b20..124a1b2f199 100644
--- a/Source/WebCore/platform/image-decoders/webp/WEBPImageDecoder.cpp
+++ b/Source/WebCore/platform/image-decoders/webp/WEBPImageDecoder.cpp
@@ -45,7 +45,8 @@ inline WEBP_CSP_MODE outputMode(bool hasAlpha) { return hasAlpha ? MODE_bgrA : M
 
 namespace WebCore {
 
-WEBPImageDecoder::WEBPImageDecoder(AlphaOption alphaOption, GammaAndColorProfileOption gammaAndColorProfileOption)
+WEBPImageDecoder::WEBPImageDecoder(ImageSource::AlphaOption alphaOption,
+                                   ImageSource::GammaAndColorProfileOption gammaAndColorProfileOption)
     : ImageDecoder(alphaOption, gammaAndColorProfileOption)
     , m_decoder(0)
     , m_hasAlpha(false)
@@ -77,11 +78,13 @@ ImageFrame* WEBPImageDecoder::frameBufferAtIndex(size_t index)
     if (index)
         return 0;
 
-    if (m_frameBufferCache.isEmpty())
+    if (m_frameBufferCache.isEmpty()) {
         m_frameBufferCache.resize(1);
+        m_frameBufferCache[0].setPremultiplyAlpha(m_premultiplyAlpha);
+    }
 
     ImageFrame& frame = m_frameBufferCache[0];
-    if (!frame.isComplete())
+    if (frame.status() != ImageFrame::FrameComplete)
         decode(false);
     return &frame;
 }
@@ -112,7 +115,7 @@ bool WEBPImageDecoder::decode(bool onlySize)
             return setFailed();
         m_hasAlpha = false;
 #endif
-        if (!setSize(IntSize(width, height)))
+        if (!setSize(width, height))
             return setFailed();
     }
 
@@ -122,21 +125,22 @@ bool WEBPImageDecoder::decode(bool onlySize)
 
     ASSERT(!m_frameBufferCache.isEmpty());
     ImageFrame& buffer = m_frameBufferCache[0];
-    ASSERT(!buffer.isComplete());
+    ASSERT(buffer.status() != ImageFrame::FrameComplete);
 
-    if (buffer.isEmpty()) {
-        if (!buffer.initialize(size(), m_premultiplyAlpha))
+    if (buffer.status() == ImageFrame::FrameEmpty) {
+        if (!buffer.setSize(size().width(), size().height()))
             return setFailed();
-        buffer.setDecoding(ImageFrame::Decoding::Partial);
+        buffer.setStatus(ImageFrame::FramePartial);
         buffer.setHasAlpha(m_hasAlpha);
+        buffer.setOriginalFrameRect(IntRect(IntPoint(), size()));
     }
 
     if (!m_decoder) {
         WEBP_CSP_MODE mode = outputMode(m_hasAlpha);
         if (!m_premultiplyAlpha)
             mode = outputMode(false);
-        int rowStride = size().width() * sizeof(RGBA32);
-        uint8_t* output = reinterpret_cast<uint8_t*>(buffer.backingStore()->pixelAt(0, 0));
+        int rowStride = size().width() * sizeof(ImageFrame::PixelData);
+        uint8_t* output = reinterpret_cast<uint8_t*>(buffer.getAddr(0, 0));
         int outputSize = size().height() * rowStride;
         m_decoder = WebPINewRGB(mode, output, outputSize, rowStride);
         if (!m_decoder)
@@ -145,7 +149,7 @@ bool WEBPImageDecoder::decode(bool onlySize)
 
     switch (WebPIUpdate(m_decoder, dataBytes, dataSize)) {
     case VP8_STATUS_OK:
-        buffer.setDecoding(ImageFrame::Decoding::Complete);
+        buffer.setStatus(ImageFrame::FrameComplete);
         clear();
         return true;
     case VP8_STATUS_SUSPENDED:
diff --git a/Source/WebCore/platform/image-decoders/webp/WEBPImageDecoder.h b/Source/WebCore/platform/image-decoders/webp/WEBPImageDecoder.h
index e282b227691..f9e614e7831 100644
--- a/Source/WebCore/platform/image-decoders/webp/WEBPImageDecoder.h
+++ b/Source/WebCore/platform/image-decoders/webp/WEBPImageDecoder.h
@@ -26,7 +26,8 @@
  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-#pragma once
+#ifndef WEBPImageDecoder_h
+#define WEBPImageDecoder_h
 
 #include "ImageDecoder.h"
 
@@ -36,14 +37,14 @@
 
 namespace WebCore {
 
-class WEBPImageDecoder final : public ImageDecoder {
+class WEBPImageDecoder : public ImageDecoder {
 public:
-    WEBPImageDecoder(AlphaOption, GammaAndColorProfileOption);
+    WEBPImageDecoder(ImageSource::AlphaOption, ImageSource::GammaAndColorProfileOption);
     virtual ~WEBPImageDecoder();
 
-    String filenameExtension() const override { return "webp"; }
-    bool isSizeAvailable() override;
-    ImageFrame* frameBufferAtIndex(size_t index) override;
+    virtual String filenameExtension() const { return "webp"; }
+    virtual bool isSizeAvailable();
+    virtual ImageFrame* frameBufferAtIndex(size_t index);
 
 private:
     bool decode(bool onlySize);
@@ -58,3 +59,5 @@ private:
 } // namespace WebCore
 
 #endif
+
+#endif
diff --git a/Source/WebCore/platform/mac/CursorMac.mm b/Source/WebCore/platform/mac/CursorMac.mm
index 85cc7c5fdd2..3b848e2af55 100644
--- a/Source/WebCore/platform/mac/CursorMac.mm
+++ b/Source/WebCore/platform/mac/CursorMac.mm
@@ -48,9 +48,9 @@ static RetainPtr<NSCursor> createCustomCursor(Image* image, const IntPoint& hotS
 #endif
 {
     // FIXME: The cursor won't animate.  Not sure if that's a big deal.
-    auto nsImage = image->snapshotNSImage();
+    NSImage* nsImage = image->getNSImage();
     if (!nsImage)
-        return nullptr;
+        return 0;
     BEGIN_BLOCK_OBJC_EXCEPTIONS;
 
 #if ENABLE(MOUSE_CURSOR_SCALE)
@@ -75,7 +75,7 @@ static RetainPtr<NSCursor> createCustomCursor(Image* image, const IntPoint& hotS
     [[[nsImage representations] objectAtIndex:0] setSize:expandedSize];
 #endif
 
-    return adoptNS([[NSCursor alloc] initWithImage:nsImage.get() hotSpot:hotSpot]);
+    return adoptNS([[NSCursor alloc] initWithImage:nsImage hotSpot:hotSpot]);
     END_BLOCK_OBJC_EXCEPTIONS;
     return nullptr;
 }
diff --git a/Source/WebCore/platform/mac/DragImageMac.mm b/Source/WebCore/platform/mac/DragImageMac.mm
index d2f8f70803c..ab2cbaaff2e 100644
--- a/Source/WebCore/platform/mac/DragImageMac.mm
+++ b/Source/WebCore/platform/mac/DragImageMac.mm
@@ -88,7 +88,7 @@ RetainPtr<NSImage> createDragImageFromImage(Image* image, ImageOrientationDescri
     if (is<BitmapImage>(*image)) {
         ImageOrientation orientation;
         BitmapImage& bitmapImage = downcast<BitmapImage>(*image);
-        IntSize sizeRespectingOrientation = bitmapImage.sizeRespectingOrientation();
+        IntSize sizeRespectingOrientation = bitmapImage.sizeRespectingOrientation(description);
 
         if (description.respectImageOrientation() == RespectImageOrientation)
             orientation = bitmapImage.orientationForCurrentFrame();
diff --git a/Source/WebCore/platform/mac/PasteboardMac.mm b/Source/WebCore/platform/mac/PasteboardMac.mm
index ba92a0ead69..dba0b81d3e5 100644
--- a/Source/WebCore/platform/mac/PasteboardMac.mm
+++ b/Source/WebCore/platform/mac/PasteboardMac.mm
@@ -262,7 +262,7 @@ static void writeFileWrapperAsRTFDAttachment(NSFileWrapper *wrapper, const Strin
 
 void Pasteboard::write(const PasteboardImage& pasteboardImage)
 {
-    CFDataRef imageData = pasteboardImage.image->tiffRepresentation();
+    CFDataRef imageData = pasteboardImage.image->getTIFFRepresentation();
     if (!imageData)
         return;
 
diff --git a/Source/WebCore/platform/mac/ThemeMac.mm b/Source/WebCore/platform/mac/ThemeMac.mm
index 2bc262d806e..57afe90f362 100644
--- a/Source/WebCore/platform/mac/ThemeMac.mm
+++ b/Source/WebCore/platform/mac/ThemeMac.mm
@@ -661,7 +661,7 @@ bool ThemeMac::drawCellOrFocusRingWithViewIntoContext(NSCell *cell, GraphicsCont
     bool needsRepaint = false;
     if (useImageBuffer) {
         NSRect imageBufferDrawRect = NSRect(FloatRect(buttonFocusRectOutlineWidth, buttonFocusRectOutlineWidth, rect.width(), rect.height()));
-        auto imageBuffer = ImageBuffer::createCompatibleBuffer(rect.size() + 2 * FloatSize(buttonFocusRectOutlineWidth, buttonFocusRectOutlineWidth), deviceScaleFactor, ColorSpaceSRGB, context);
+        auto imageBuffer = ImageBuffer::createCompatibleBuffer(rect.size() + 2 * FloatSize(buttonFocusRectOutlineWidth, buttonFocusRectOutlineWidth), deviceScaleFactor, ColorSpaceSRGB, context, false);
         if (!imageBuffer)
             return needsRepaint;
         {
diff --git a/Source/WebCore/platform/mediastream/mac/MockRealtimeVideoSourceMac.mm b/Source/WebCore/platform/mediastream/mac/MockRealtimeVideoSourceMac.mm
index fb4cfa8b5e2..94d08b73ffe 100644
--- a/Source/WebCore/platform/mediastream/mac/MockRealtimeVideoSourceMac.mm
+++ b/Source/WebCore/platform/mediastream/mac/MockRealtimeVideoSourceMac.mm
@@ -153,7 +153,7 @@ void MockRealtimeVideoSourceMac::updatePlatformLayer() const
         if (!image)
             break;
 
-        m_previewImage = image->nativeImage();
+        m_previewImage = image->getCGImageRef();
         if (!m_previewImage)
             break;
 
@@ -165,7 +165,7 @@ void MockRealtimeVideoSourceMac::updatePlatformLayer() const
 
 void MockRealtimeVideoSourceMac::updateSampleBuffer()
 {
-    auto pixelBuffer = pixelBufferFromCGImage(imageBuffer()->copyImage()->nativeImage().get());
+    auto pixelBuffer = pixelBufferFromCGImage(imageBuffer()->copyImage()->getCGImageRef());
     auto sampleBuffer = CMSampleBufferFromPixelBuffer(pixelBuffer.get());
     
     mediaDataUpdated(MediaSampleAVFObjC::create(sampleBuffer.get()));
diff --git a/Source/WebCore/platform/spi/cg/CoreGraphicsSPI.h b/Source/WebCore/platform/spi/cg/CoreGraphicsSPI.h
index df943314614..f0ed814b17f 100644
--- a/Source/WebCore/platform/spi/cg/CoreGraphicsSPI.h
+++ b/Source/WebCore/platform/spi/cg/CoreGraphicsSPI.h
@@ -199,7 +199,6 @@ CGColorSpaceRef CGIOSurfaceContextGetColorSpace(CGContextRef);
 CGSRegionEnumeratorObj CGSRegionEnumerator(CGRegionRef);
 CGRect* CGSNextRect(const CGSRegionEnumeratorObj);
 CGError CGSReleaseRegionEnumerator(const CGSRegionEnumeratorObj);
-CGColorSpaceRef CGContextCopyDeviceColorSpace(CGContextRef);
 #endif
 
 #if PLATFORM(WIN)
diff --git a/Source/WebCore/platform/win/DragImageCGWin.cpp b/Source/WebCore/platform/win/DragImageCGWin.cpp
index 2289b8f2f3c..d07b7bf57c4 100644
--- a/Source/WebCore/platform/win/DragImageCGWin.cpp
+++ b/Source/WebCore/platform/win/DragImageCGWin.cpp
@@ -138,9 +138,9 @@ DragImageRef createDragImageFromImage(Image* img, ImageOrientationDescription)
     CGContextScaleCTM(drawContext, 1, -1);
     CGContextSetFillColor(drawContext, white);
     CGContextFillRect(drawContext, rect);
-    if (auto srcImage = img->nativeImage()) {
+    if (auto srcImage = img->getCGImageRef()) {
         CGContextSetBlendMode(drawContext, kCGBlendModeNormal);
-        CGContextDrawImage(drawContext, rect, srcImage.get());
+        CGContextDrawImage(drawContext, rect, srcImage);
     }
     CGContextRelease(drawContext);
 
diff --git a/Source/WebCore/rendering/FilterEffectRenderer.cpp b/Source/WebCore/rendering/FilterEffectRenderer.cpp
index 4378dceac3d..37b53fcb83c 100644
--- a/Source/WebCore/rendering/FilterEffectRenderer.cpp
+++ b/Source/WebCore/rendering/FilterEffectRenderer.cpp
@@ -45,10 +45,6 @@
 #include <algorithm>
 #include <wtf/MathExtras.h>
 
-#if USE(DIRECT2D)
-#include <d2d1.h>
-#endif
-
 namespace WebCore {
 
 static inline void endMatrixRow(Vector<float>& parameters)
@@ -314,21 +310,15 @@ bool FilterEffectRenderer::updateBackingStoreRect(const FloatRect& filterRect)
     return true;
 }
 
-void FilterEffectRenderer::allocateBackingStoreIfNeeded(const GraphicsContext& targetContext)
+void FilterEffectRenderer::allocateBackingStoreIfNeeded()
 {
     // At this point the effect chain has been built, and the
     // source image sizes set. We just need to attach the graphic
     // buffer if we have not yet done so.
     if (!m_graphicsBufferAttached) {
         IntSize logicalSize(m_sourceDrawingRegion.width(), m_sourceDrawingRegion.height());
-        if (!sourceImage() || sourceImage()->logicalSize() != logicalSize) {
-#if USE(DIRECT2D)
-            setSourceImage(ImageBuffer::create(logicalSize, renderingMode(), &targetContext, filterScale()));
-#else
-            UNUSED_PARAM(targetContext);
+        if (!sourceImage() || sourceImage()->logicalSize() != logicalSize)
             setSourceImage(ImageBuffer::create(logicalSize, renderingMode(), filterScale()));
-#endif
-        }
         m_graphicsBufferAttached = true;
     }
 }
@@ -403,7 +393,7 @@ bool FilterEffectRendererHelper::beginFilterEffect()
     ASSERT(m_renderLayer);
     
     FilterEffectRenderer* filter = m_renderLayer->filterRenderer();
-    filter->allocateBackingStoreIfNeeded(m_targetContext);
+    filter->allocateBackingStoreIfNeeded();
     // Paint into the context that represents the SourceGraphic of the filter.
     GraphicsContext* sourceGraphicsContext = filter->inputContext();
     if (!sourceGraphicsContext || filter->filterRegion().isEmpty() || ImageBuffer::sizeNeedsClamping(filter->filterRegion().size())) {
diff --git a/Source/WebCore/rendering/FilterEffectRenderer.h b/Source/WebCore/rendering/FilterEffectRenderer.h
index 14ef904fc2e..c3cf21440e4 100644
--- a/Source/WebCore/rendering/FilterEffectRenderer.h
+++ b/Source/WebCore/rendering/FilterEffectRenderer.h
@@ -55,9 +55,8 @@ enum FilterConsumer {
 class FilterEffectRendererHelper {
     WTF_MAKE_FAST_ALLOCATED;
 public:
-    FilterEffectRendererHelper(bool haveFilterEffect, GraphicsContext& targetContext)
-        : m_targetContext(targetContext)
-        , m_haveFilterEffect(haveFilterEffect)
+    FilterEffectRendererHelper(bool haveFilterEffect)
+        : m_haveFilterEffect(haveFilterEffect)
     {
     }
     
@@ -76,7 +75,6 @@ private:
     RenderLayer* m_renderLayer { nullptr }; // FIXME: this is mainly used to get the FilterEffectRenderer. FilterEffectRendererHelper should be weaned off it.
     LayoutPoint m_paintOffset;
     LayoutRect m_repaintRect;
-    const GraphicsContext& m_targetContext;
     bool m_haveFilterEffect { false };
     bool m_startedFilterEffect { false };
 };
@@ -107,7 +105,7 @@ public:
     bool build(RenderElement*, const FilterOperations&, FilterConsumer);
     RefPtr<FilterEffect> buildReferenceFilter(RenderElement*, PassRefPtr<FilterEffect> previousEffect, ReferenceFilterOperation*);
     bool updateBackingStoreRect(const FloatRect& filterRect);
-    void allocateBackingStoreIfNeeded(const GraphicsContext&);
+    void allocateBackingStoreIfNeeded();
     void clearIntermediateResults();
     void apply();
     
diff --git a/Source/WebCore/rendering/RenderBoxModelObject.cpp b/Source/WebCore/rendering/RenderBoxModelObject.cpp
index ecd7b21884e..ad80cb017fd 100644
--- a/Source/WebCore/rendering/RenderBoxModelObject.cpp
+++ b/Source/WebCore/rendering/RenderBoxModelObject.cpp
@@ -756,7 +756,7 @@ void RenderBoxModelObject::paintFillLayerExtended(const PaintInfo& paintInfo, co
         maskRect.intersect(snappedIntRect(paintInfo.rect));
 
         // Now create the mask.
-        maskImage = ImageBuffer::createCompatibleBuffer(maskRect.size(), ColorSpaceSRGB, context);
+        maskImage = context.createCompatibleBuffer(maskRect.size());
         if (!maskImage)
             return;
         paintMaskForTextFillBox(maskImage.get(), maskRect, box, scrolledPaintRect);
diff --git a/Source/WebCore/rendering/RenderImageResource.cpp b/Source/WebCore/rendering/RenderImageResource.cpp
index b94f159a63e..0c6005200f9 100644
--- a/Source/WebCore/rendering/RenderImageResource.cpp
+++ b/Source/WebCore/rendering/RenderImageResource.cpp
@@ -56,10 +56,8 @@ void RenderImageResource::shutdown()
 {
     ASSERT(m_renderer);
 
-    if (m_cachedImage) {
-        image()->stopAnimation();
+    if (m_cachedImage)
         m_cachedImage->removeClient(*m_renderer);
-    }
 }
 
 void RenderImageResource::setCachedImage(CachedImage* newImage)
diff --git a/Source/WebCore/rendering/RenderImageResourceStyleImage.cpp b/Source/WebCore/rendering/RenderImageResourceStyleImage.cpp
index 28e36b19985..4046d5483af 100644
--- a/Source/WebCore/rendering/RenderImageResourceStyleImage.cpp
+++ b/Source/WebCore/rendering/RenderImageResourceStyleImage.cpp
@@ -57,10 +57,7 @@ void RenderImageResourceStyleImage::shutdown()
 {
     ASSERT(m_renderer);
     m_styleImage->removeClient(m_renderer);
-    if (m_cachedImage) {
-        image()->stopAnimation();
-        m_cachedImage = nullptr;
-    }
+    m_cachedImage = nullptr;
 }
 
 RefPtr<Image> RenderImageResourceStyleImage::image(int width, int height) const
diff --git a/Source/WebCore/rendering/RenderLayer.cpp b/Source/WebCore/rendering/RenderLayer.cpp
index 94ec673c472..a83bb9a44c7 100644
--- a/Source/WebCore/rendering/RenderLayer.cpp
+++ b/Source/WebCore/rendering/RenderLayer.cpp
@@ -4171,7 +4171,7 @@ bool RenderLayer::hasFilterThatIsPainting(GraphicsContext& context, PaintLayerFl
     if (!hasPaintedFilter)
         return false;
 
-    auto filterPainter = std::make_unique<FilterEffectRendererHelper>(hasPaintedFilter, context);
+    auto filterPainter = std::make_unique<FilterEffectRendererHelper>(hasPaintedFilter);
     if (!filterPainter->haveFilterEffect())
         return false;
 
@@ -4185,7 +4185,7 @@ std::unique_ptr<FilterEffectRendererHelper> RenderLayer::setupFilters(GraphicsCo
 
     FilterInfo* filterInfo = FilterInfo::getIfExists(*this);
     bool hasPaintedFilter = filterInfo && filterInfo->renderer() && paintsWithFilters();
-    auto filterPainter = std::make_unique<FilterEffectRendererHelper>(hasPaintedFilter, context);
+    auto filterPainter = std::make_unique<FilterEffectRendererHelper>(hasPaintedFilter);
 
     LayoutRect filterRepaintRect = filterInfo->dirtySourceRect();
     filterRepaintRect.move(offsetFromRoot);
diff --git a/Source/WebCore/rendering/RenderThemeMac.mm b/Source/WebCore/rendering/RenderThemeMac.mm
index 4c435d92d13..23c6fe651ae 100644
--- a/Source/WebCore/rendering/RenderThemeMac.mm
+++ b/Source/WebCore/rendering/RenderThemeMac.mm
@@ -1144,7 +1144,7 @@ bool RenderThemeMac::paintProgressBar(const RenderObject& renderObject, const Pa
     trackInfo.reserved = 0;
     trackInfo.filler1 = 0;
 
-    std::unique_ptr<ImageBuffer> imageBuffer = ImageBuffer::createCompatibleBuffer(inflatedRect.size(), deviceScaleFactor, ColorSpaceSRGB, paintInfo.context());
+    std::unique_ptr<ImageBuffer> imageBuffer = ImageBuffer::createCompatibleBuffer(inflatedRect.size(), deviceScaleFactor, ColorSpaceSRGB, paintInfo.context(), true);
     if (!imageBuffer)
         return true;
 
diff --git a/Source/WebCore/rendering/svg/RenderSVGImage.cpp b/Source/WebCore/rendering/svg/RenderSVGImage.cpp
index 104aa988e39..15847619a71 100644
--- a/Source/WebCore/rendering/svg/RenderSVGImage.cpp
+++ b/Source/WebCore/rendering/svg/RenderSVGImage.cpp
@@ -73,7 +73,7 @@ bool RenderSVGImage::updateImageViewport()
     // Images with preserveAspectRatio=none should force non-uniform scaling. This can be achieved
     // by setting the image's container size to its intrinsic size.
     // See: http://www.w3.org/TR/SVG/single-page.html, 7.8 The preserveAspectRatio attribute.
-    if (imageElement().preserveAspectRatio().align() == SVGPreserveAspectRatioValue::SVG_PRESERVEASPECTRATIO_NONE) {
+    if (imageElement().preserveAspectRatio().align() == SVGPreserveAspectRatio::SVG_PRESERVEASPECTRATIO_NONE) {
         if (CachedImage* cachedImage = imageResource().cachedImage()) {
             LayoutSize intrinsicSize = cachedImage->imageSizeForRenderer(0, style().effectiveZoom());
             if (intrinsicSize != imageResource().imageSize(style().effectiveZoom())) {
diff --git a/Source/WebCore/rendering/svg/RenderSVGImage.h b/Source/WebCore/rendering/svg/RenderSVGImage.h
index 34895be3bb9..8408470ef1e 100644
--- a/Source/WebCore/rendering/svg/RenderSVGImage.h
+++ b/Source/WebCore/rendering/svg/RenderSVGImage.h
@@ -26,6 +26,7 @@
 #include "AffineTransform.h"
 #include "FloatRect.h"
 #include "RenderSVGModelObject.h"
+#include "SVGPreserveAspectRatio.h"
 
 namespace WebCore {
 
diff --git a/Source/WebCore/rendering/svg/SVGRenderingContext.cpp b/Source/WebCore/rendering/svg/SVGRenderingContext.cpp
index 4f35ed9eaa0..b63d37e0684 100644
--- a/Source/WebCore/rendering/svg/SVGRenderingContext.cpp
+++ b/Source/WebCore/rendering/svg/SVGRenderingContext.cpp
@@ -353,7 +353,7 @@ bool SVGRenderingContext::bufferForeground(std::unique_ptr<ImageBuffer>& imageBu
 
     // Create a new buffer and paint the foreground into it.
     if (!imageBuffer) {
-        if ((imageBuffer = ImageBuffer::createCompatibleBuffer(expandedIntSize(boundingBox.size()), ColorSpaceSRGB, m_paintInfo->context()))) {
+        if ((imageBuffer = m_paintInfo->context().createCompatibleBuffer(expandedIntSize(boundingBox.size()), true))) {
             GraphicsContext& bufferedRenderingContext = imageBuffer->context();
             bufferedRenderingContext.translate(-boundingBox.x(), -boundingBox.y());
             PaintInfo bufferedInfo(*m_paintInfo);
diff --git a/Source/WebCore/svg/PatternAttributes.h b/Source/WebCore/svg/PatternAttributes.h
index ae6c594c339..d6223c1b478 100644
--- a/Source/WebCore/svg/PatternAttributes.h
+++ b/Source/WebCore/svg/PatternAttributes.h
@@ -55,7 +55,7 @@ struct PatternAttributes {
     SVGLength width() const { return m_width; }
     SVGLength height() const { return m_height; }
     FloatRect viewBox() const { return m_viewBox; }
-    SVGPreserveAspectRatioValue preserveAspectRatio() const { return m_preserveAspectRatio; }
+    SVGPreserveAspectRatio preserveAspectRatio() const { return m_preserveAspectRatio; }
     SVGUnitTypes::SVGUnitType patternUnits() const { return m_patternUnits; }
     SVGUnitTypes::SVGUnitType patternContentUnits() const { return m_patternContentUnits; }
     AffineTransform patternTransform() const { return m_patternTransform; }
@@ -91,7 +91,7 @@ struct PatternAttributes {
         m_viewBoxSet = true;
     }
 
-    void setPreserveAspectRatio(const SVGPreserveAspectRatioValue& value)
+    void setPreserveAspectRatio(const SVGPreserveAspectRatio& value)
     {
         m_preserveAspectRatio = value;
         m_preserveAspectRatioSet = true;
@@ -139,7 +139,7 @@ private:
     SVGLength m_width;
     SVGLength m_height;
     FloatRect m_viewBox;
-    SVGPreserveAspectRatioValue m_preserveAspectRatio;
+    SVGPreserveAspectRatio m_preserveAspectRatio;
     SVGUnitTypes::SVGUnitType m_patternUnits;
     SVGUnitTypes::SVGUnitType m_patternContentUnits;
     AffineTransform m_patternTransform;
diff --git a/Source/WebCore/svg/SVGAllInOne.cpp b/Source/WebCore/svg/SVGAllInOne.cpp
index 49fa35444b8..642203ac7b9 100644
--- a/Source/WebCore/svg/SVGAllInOne.cpp
+++ b/Source/WebCore/svg/SVGAllInOne.cpp
@@ -144,7 +144,7 @@
 #include "SVGPolyElement.cpp"
 #include "SVGPolygonElement.cpp"
 #include "SVGPolylineElement.cpp"
-#include "SVGPreserveAspectRatioValue.cpp"
+#include "SVGPreserveAspectRatio.cpp"
 #include "SVGRadialGradientElement.cpp"
 #include "SVGRectElement.cpp"
 #include "SVGSVGElement.cpp"
diff --git a/Source/WebCore/svg/SVGAngle.h b/Source/WebCore/svg/SVGAngle.h
index a4be5c4089d..14a2f343bdb 100644
--- a/Source/WebCore/svg/SVGAngle.h
+++ b/Source/WebCore/svg/SVGAngle.h
@@ -32,6 +32,16 @@ namespace WebCore {
 
 class SVGAngle : public SVGPropertyTearOff<SVGAngleValue> {
 public:
+    // FIXME: This is duplicated in SVGAngleValue. We should find someway to have
+    // only one copy, but for now, this one is needed to satisfy the bindings.
+    enum SVGAngleType {
+        SVG_ANGLETYPE_UNKNOWN = 0,
+        SVG_ANGLETYPE_UNSPECIFIED = 1,
+        SVG_ANGLETYPE_DEG = 2,
+        SVG_ANGLETYPE_RAD = 3,
+        SVG_ANGLETYPE_GRAD = 4
+    };
+
     static Ref<SVGAngle> create(SVGAnimatedProperty* animatedProperty, SVGPropertyRole role, SVGAngleValue& value)
     {
         ASSERT(animatedProperty);
diff --git a/Source/WebCore/svg/SVGAngle.idl b/Source/WebCore/svg/SVGAngle.idl
index 25b6345859e..1a1a16956f9 100644
--- a/Source/WebCore/svg/SVGAngle.idl
+++ b/Source/WebCore/svg/SVGAngle.idl
@@ -20,9 +20,7 @@
  * Boston, MA 02110-1301, USA.
  */
 
-[
-    ConstantsScope=SVGAngleValue
-] interface SVGAngle { 
+interface SVGAngle { 
     // Angle Unit Types
     const unsigned short SVG_ANGLETYPE_UNKNOWN = 0;
     const unsigned short SVG_ANGLETYPE_UNSPECIFIED = 1;
diff --git a/Source/WebCore/svg/SVGAnimatedPreserveAspectRatio.cpp b/Source/WebCore/svg/SVGAnimatedPreserveAspectRatio.cpp
index 801025b45fa..86f77ee58fe 100644
--- a/Source/WebCore/svg/SVGAnimatedPreserveAspectRatio.cpp
+++ b/Source/WebCore/svg/SVGAnimatedPreserveAspectRatio.cpp
@@ -31,7 +31,7 @@ SVGAnimatedPreserveAspectRatioAnimator::SVGAnimatedPreserveAspectRatioAnimator(S
 
 std::unique_ptr<SVGAnimatedType> SVGAnimatedPreserveAspectRatioAnimator::constructFromString(const String& string)
 {
-    auto animatedType = SVGAnimatedType::createPreserveAspectRatio(std::make_unique<SVGPreserveAspectRatioValue>());
+    auto animatedType = SVGAnimatedType::createPreserveAspectRatio(std::make_unique<SVGPreserveAspectRatio>());
     animatedType->preserveAspectRatio().parse(string);
     return animatedType;
 }
@@ -71,11 +71,11 @@ void SVGAnimatedPreserveAspectRatioAnimator::calculateAnimatedValue(float percen
     ASSERT(m_animationElement);
     ASSERT(m_contextElement);
 
-    const auto& fromPreserveAspectRatio = m_animationElement->animationMode() == ToAnimation ? animated->preserveAspectRatio() : from->preserveAspectRatio();
-    const auto& toPreserveAspectRatio = to->preserveAspectRatio();
-    auto& animatedPreserveAspectRatio = animated->preserveAspectRatio();
+    const SVGPreserveAspectRatio& fromPreserveAspectRatio = m_animationElement->animationMode() == ToAnimation ? animated->preserveAspectRatio() : from->preserveAspectRatio();
+    const SVGPreserveAspectRatio& toPreserveAspectRatio = to->preserveAspectRatio();
+    SVGPreserveAspectRatio& animatedPreserveAspectRatio = animated->preserveAspectRatio();
 
-    m_animationElement->animateDiscreteType<SVGPreserveAspectRatioValue>(percentage, fromPreserveAspectRatio, toPreserveAspectRatio, animatedPreserveAspectRatio);
+    m_animationElement->animateDiscreteType<SVGPreserveAspectRatio>(percentage, fromPreserveAspectRatio, toPreserveAspectRatio, animatedPreserveAspectRatio);
 }
 
 float SVGAnimatedPreserveAspectRatioAnimator::calculateDistance(const String&, const String&)
diff --git a/Source/WebCore/svg/SVGAnimatedPreserveAspectRatio.h b/Source/WebCore/svg/SVGAnimatedPreserveAspectRatio.h
index 8f9e76b0858..409bea22c21 100644
--- a/Source/WebCore/svg/SVGAnimatedPreserveAspectRatio.h
+++ b/Source/WebCore/svg/SVGAnimatedPreserveAspectRatio.h
@@ -28,11 +28,11 @@ namespace WebCore {
 template<typename T> 
 class SVGPropertyTearOff;
 
-using SVGAnimatedPreserveAspectRatio = SVGAnimatedPropertyTearOff<SVGPreserveAspectRatio>;
+using SVGAnimatedPreserveAspectRatio = SVGAnimatedPropertyTearOff<SVGPropertyTearOff<SVGPreserveAspectRatio>>;
 
 // Helper macros to declare/define a SVGAnimatedPreserveAspectRatio object
 #define DECLARE_ANIMATED_PRESERVEASPECTRATIO(UpperProperty, LowerProperty) \
-DECLARE_ANIMATED_PROPERTY(SVGAnimatedPreserveAspectRatio, SVGPreserveAspectRatioValue, UpperProperty, LowerProperty, )
+DECLARE_ANIMATED_PROPERTY(SVGAnimatedPreserveAspectRatio, SVGPreserveAspectRatio, UpperProperty, LowerProperty, )
 
 #define DEFINE_ANIMATED_PRESERVEASPECTRATIO(OwnerType, DOMAttribute, UpperProperty, LowerProperty) \
 DEFINE_ANIMATED_PROPERTY(AnimatedPreserveAspectRatio, OwnerType, DOMAttribute, DOMAttribute.localName(), UpperProperty, LowerProperty)
diff --git a/Source/WebCore/svg/SVGAnimatedType.cpp b/Source/WebCore/svg/SVGAnimatedType.cpp
index 553d081a689..fbf09f90f7f 100644
--- a/Source/WebCore/svg/SVGAnimatedType.cpp
+++ b/Source/WebCore/svg/SVGAnimatedType.cpp
@@ -194,7 +194,7 @@ std::unique_ptr<SVGAnimatedType> SVGAnimatedType::createPointList(std::unique_pt
     return animatedType;
 }
 
-std::unique_ptr<SVGAnimatedType> SVGAnimatedType::createPreserveAspectRatio(std::unique_ptr<SVGPreserveAspectRatioValue> preserveAspectRatio)
+std::unique_ptr<SVGAnimatedType> SVGAnimatedType::createPreserveAspectRatio(std::unique_ptr<SVGPreserveAspectRatio> preserveAspectRatio)
 {
     ASSERT(preserveAspectRatio);
     auto animatedType = std::make_unique<SVGAnimatedType>(AnimatedPreserveAspectRatio);
diff --git a/Source/WebCore/svg/SVGAnimatedType.h b/Source/WebCore/svg/SVGAnimatedType.h
index 80af132561a..7ae6b15e67f 100644
--- a/Source/WebCore/svg/SVGAnimatedType.h
+++ b/Source/WebCore/svg/SVGAnimatedType.h
@@ -26,7 +26,7 @@
 #include "SVGLengthList.h"
 #include "SVGNumberList.h"
 #include "SVGPointList.h"
-#include "SVGPreserveAspectRatioValue.h"
+#include "SVGPreserveAspectRatio.h"
 #include "SVGPropertyInfo.h"
 #include "SVGTransformList.h"
 
@@ -53,7 +53,7 @@ public:
     static std::unique_ptr<SVGAnimatedType> createNumberOptionalNumber(std::unique_ptr<std::pair<float, float>>);
     static std::unique_ptr<SVGAnimatedType> createPath(std::unique_ptr<SVGPathByteStream>);
     static std::unique_ptr<SVGAnimatedType> createPointList(std::unique_ptr<SVGPointList>);
-    static std::unique_ptr<SVGAnimatedType> createPreserveAspectRatio(std::unique_ptr<SVGPreserveAspectRatioValue>);
+    static std::unique_ptr<SVGAnimatedType> createPreserveAspectRatio(std::unique_ptr<SVGPreserveAspectRatio>);
     static std::unique_ptr<SVGAnimatedType> createRect(std::unique_ptr<FloatRect>);
     static std::unique_ptr<SVGAnimatedType> createString(std::unique_ptr<String>);
     static std::unique_ptr<SVGAnimatedType> createTransformList(std::unique_ptr<SVGTransformList>);
@@ -140,7 +140,7 @@ public:
         return *m_data.pointList;
     }
 
-    const SVGPreserveAspectRatioValue& preserveAspectRatio() const
+    const SVGPreserveAspectRatio& preserveAspectRatio() const
     {
         ASSERT(m_type == AnimatedPreserveAspectRatio);
         return *m_data.preserveAspectRatio;
@@ -243,7 +243,7 @@ public:
         return *m_data.pointList;
     }
 
-    SVGPreserveAspectRatioValue& preserveAspectRatio()
+    SVGPreserveAspectRatio& preserveAspectRatio()
     {
         ASSERT(m_type == AnimatedPreserveAspectRatio);
         return *m_data.preserveAspectRatio;
@@ -291,7 +291,7 @@ private:
         SVGNumberList* numberList;
         std::pair<float, float>* numberOptionalNumber;
         SVGPathByteStream* path;
-        SVGPreserveAspectRatioValue* preserveAspectRatio;
+        SVGPreserveAspectRatio* preserveAspectRatio;
         SVGPointList* pointList;
         FloatRect* rect;
         String* string;
diff --git a/Source/WebCore/svg/SVGFEImageElement.cpp b/Source/WebCore/svg/SVGFEImageElement.cpp
index 0b32710b6fa..eb6bbae487e 100644
--- a/Source/WebCore/svg/SVGFEImageElement.cpp
+++ b/Source/WebCore/svg/SVGFEImageElement.cpp
@@ -30,7 +30,7 @@
 #include "RenderObject.h"
 #include "RenderSVGResource.h"
 #include "SVGNames.h"
-#include "SVGPreserveAspectRatioValue.h"
+#include "SVGPreserveAspectRatio.h"
 #include "XLinkNames.h"
 
 namespace WebCore {
@@ -122,7 +122,7 @@ void SVGFEImageElement::buildPendingResource()
 void SVGFEImageElement::parseAttribute(const QualifiedName& name, const AtomicString& value)
 {
     if (name == SVGNames::preserveAspectRatioAttr) {
-        SVGPreserveAspectRatioValue preserveAspectRatio;
+        SVGPreserveAspectRatio preserveAspectRatio;
         preserveAspectRatio.parse(value);
         setPreserveAspectRatioBaseValue(preserveAspectRatio);
         return;
diff --git a/Source/WebCore/svg/SVGFitToViewBox.cpp b/Source/WebCore/svg/SVGFitToViewBox.cpp
index 770f1f41966..632b4627e55 100644
--- a/Source/WebCore/svg/SVGFitToViewBox.cpp
+++ b/Source/WebCore/svg/SVGFitToViewBox.cpp
@@ -27,7 +27,7 @@
 #include "SVGDocumentExtensions.h"
 #include "SVGNames.h"
 #include "SVGParserUtilities.h"
-#include "SVGPreserveAspectRatioValue.h"
+#include "SVGPreserveAspectRatio.h"
 #include <wtf/text/StringView.h>
 
 namespace WebCore {
@@ -77,7 +77,7 @@ bool SVGFitToViewBox::parseViewBox(Document* doc, const UChar*& c, const UChar*
     return true;
 }
 
-AffineTransform SVGFitToViewBox::viewBoxToViewTransform(const FloatRect& viewBoxRect, const SVGPreserveAspectRatioValue& preserveAspectRatio, float viewWidth, float viewHeight)
+AffineTransform SVGFitToViewBox::viewBoxToViewTransform(const FloatRect& viewBoxRect, const SVGPreserveAspectRatio& preserveAspectRatio, float viewWidth, float viewHeight)
 {
     if (!viewBoxRect.width() || !viewBoxRect.height() || !viewWidth || !viewHeight)
         return AffineTransform();
diff --git a/Source/WebCore/svg/SVGFitToViewBox.h b/Source/WebCore/svg/SVGFitToViewBox.h
index 10cd608f58e..b255b27bc26 100644
--- a/Source/WebCore/svg/SVGFitToViewBox.h
+++ b/Source/WebCore/svg/SVGFitToViewBox.h
@@ -33,7 +33,7 @@ class Document;
 
 class SVGFitToViewBox {
 public:
-    static AffineTransform viewBoxToViewTransform(const FloatRect& viewBoxRect, const SVGPreserveAspectRatioValue&, float viewWidth, float viewHeight);
+    static AffineTransform viewBoxToViewTransform(const FloatRect& viewBoxRect, const SVGPreserveAspectRatio&, float viewWidth, float viewHeight);
 
     static bool isKnownAttribute(const QualifiedName&);
     static void addSupportedAttributes(HashSet<QualifiedName>&);
@@ -50,7 +50,7 @@ public:
         }
 
         if (name == SVGNames::preserveAspectRatioAttr) {
-            SVGPreserveAspectRatioValue preserveAspectRatio;
+            SVGPreserveAspectRatio preserveAspectRatio;
             preserveAspectRatio.parse(value);
             target->setPreserveAspectRatioBaseValue(preserveAspectRatio);
             return true;
diff --git a/Source/WebCore/svg/SVGImageElement.cpp b/Source/WebCore/svg/SVGImageElement.cpp
index c9db807fefa..b5c075f8cab 100644
--- a/Source/WebCore/svg/SVGImageElement.cpp
+++ b/Source/WebCore/svg/SVGImageElement.cpp
@@ -97,7 +97,7 @@ bool SVGImageElement::isSupportedAttribute(const QualifiedName& attrName)
 void SVGImageElement::parseAttribute(const QualifiedName& name, const AtomicString& value)
 {
     if (name == SVGNames::preserveAspectRatioAttr) {
-        SVGPreserveAspectRatioValue preserveAspectRatio;
+        SVGPreserveAspectRatio preserveAspectRatio;
         preserveAspectRatio.parse(value);
         setPreserveAspectRatioBaseValue(preserveAspectRatio);
         return;
diff --git a/Source/WebCore/svg/SVGPreserveAspectRatioValue.cpp b/Source/WebCore/svg/SVGPreserveAspectRatio.cpp
similarity index 80%
rename from Source/WebCore/svg/SVGPreserveAspectRatioValue.cpp
rename to Source/WebCore/svg/SVGPreserveAspectRatio.cpp
index d5d393eafa5..8a8b3d2c7e2 100644
--- a/Source/WebCore/svg/SVGPreserveAspectRatioValue.cpp
+++ b/Source/WebCore/svg/SVGPreserveAspectRatio.cpp
@@ -20,7 +20,7 @@
  */
 
 #include "config.h"
-#include "SVGPreserveAspectRatioValue.h"
+#include "SVGPreserveAspectRatio.h"
 
 #include "AffineTransform.h"
 #include "ExceptionCode.h"
@@ -30,13 +30,13 @@
 
 namespace WebCore {
 
-SVGPreserveAspectRatioValue::SVGPreserveAspectRatioValue()
+SVGPreserveAspectRatio::SVGPreserveAspectRatio()
     : m_align(SVG_PRESERVEASPECTRATIO_XMIDYMID)
     , m_meetOrSlice(SVG_MEETORSLICE_MEET)
 {
 }
 
-ExceptionOr<void> SVGPreserveAspectRatioValue::setAlign(unsigned short align)
+ExceptionOr<void> SVGPreserveAspectRatio::setAlign(unsigned short align)
 {
     if (align == SVG_PRESERVEASPECTRATIO_UNKNOWN || align > SVG_PRESERVEASPECTRATIO_XMAXYMAX)
         return Exception { NOT_SUPPORTED_ERR };
@@ -45,7 +45,7 @@ ExceptionOr<void> SVGPreserveAspectRatioValue::setAlign(unsigned short align)
     return { };
 }
 
-ExceptionOr<void> SVGPreserveAspectRatioValue::setMeetOrSlice(unsigned short meetOrSlice)
+ExceptionOr<void> SVGPreserveAspectRatio::setMeetOrSlice(unsigned short meetOrSlice)
 {
     if (meetOrSlice == SVG_MEETORSLICE_UNKNOWN || meetOrSlice > SVG_MEETORSLICE_SLICE)
         return Exception { NOT_SUPPORTED_ERR };
@@ -54,19 +54,19 @@ ExceptionOr<void> SVGPreserveAspectRatioValue::setMeetOrSlice(unsigned short mee
     return { };
 }
 
-void SVGPreserveAspectRatioValue::parse(const String& value)
+void SVGPreserveAspectRatio::parse(const String& value)
 {
     auto upconvertedCharacters = StringView(value).upconvertedCharacters();
     const UChar* begin = upconvertedCharacters;
     parseInternal(begin, begin + value.length(), true);
 }
 
-bool SVGPreserveAspectRatioValue::parse(const UChar*& currParam, const UChar* end, bool validate)
+bool SVGPreserveAspectRatio::parse(const UChar*& currParam, const UChar* end, bool validate)
 {
     return parseInternal(currParam, end, validate);
 }
 
-bool SVGPreserveAspectRatioValue::parseInternal(const UChar*& currParam, const UChar* end, bool validate)
+bool SVGPreserveAspectRatio::parseInternal(const UChar*& currParam, const UChar* end, bool validate)
 {
     SVGPreserveAspectRatioType align = SVG_PRESERVEASPECTRATIO_XMIDYMID;
     SVGMeetOrSliceType meetOrSlice = SVG_MEETORSLICE_MEET;
@@ -176,7 +176,7 @@ bool SVGPreserveAspectRatioValue::parseInternal(const UChar*& currParam, const U
     return true;
 }
 
-void SVGPreserveAspectRatioValue::transformRect(FloatRect& destRect, FloatRect& srcRect)
+void SVGPreserveAspectRatio::transformRect(FloatRect& destRect, FloatRect& srcRect)
 {
     if (m_align == SVG_PRESERVEASPECTRATIO_NONE)
         return;
@@ -185,21 +185,21 @@ void SVGPreserveAspectRatioValue::transformRect(FloatRect& destRect, FloatRect&
     float origDestWidth = destRect.width();
     float origDestHeight = destRect.height();
     switch (m_meetOrSlice) {
-    case SVGPreserveAspectRatioValue::SVG_MEETORSLICE_UNKNOWN:
+    case SVGPreserveAspectRatio::SVG_MEETORSLICE_UNKNOWN:
         break;
-    case SVGPreserveAspectRatioValue::SVG_MEETORSLICE_MEET: {
+    case SVGPreserveAspectRatio::SVG_MEETORSLICE_MEET: {
         float widthToHeightMultiplier = srcRect.height() / srcRect.width();
         if (origDestHeight > origDestWidth * widthToHeightMultiplier) {
             destRect.setHeight(origDestWidth * widthToHeightMultiplier);
             switch (m_align) {
-            case SVGPreserveAspectRatioValue::SVG_PRESERVEASPECTRATIO_XMINYMID:
-            case SVGPreserveAspectRatioValue::SVG_PRESERVEASPECTRATIO_XMIDYMID:
-            case SVGPreserveAspectRatioValue::SVG_PRESERVEASPECTRATIO_XMAXYMID:
+            case SVGPreserveAspectRatio::SVG_PRESERVEASPECTRATIO_XMINYMID:
+            case SVGPreserveAspectRatio::SVG_PRESERVEASPECTRATIO_XMIDYMID:
+            case SVGPreserveAspectRatio::SVG_PRESERVEASPECTRATIO_XMAXYMID:
                 destRect.setY(destRect.y() + origDestHeight / 2 - destRect.height() / 2);
                 break;
-            case SVGPreserveAspectRatioValue::SVG_PRESERVEASPECTRATIO_XMINYMAX:
-            case SVGPreserveAspectRatioValue::SVG_PRESERVEASPECTRATIO_XMIDYMAX:
-            case SVGPreserveAspectRatioValue::SVG_PRESERVEASPECTRATIO_XMAXYMAX:
+            case SVGPreserveAspectRatio::SVG_PRESERVEASPECTRATIO_XMINYMAX:
+            case SVGPreserveAspectRatio::SVG_PRESERVEASPECTRATIO_XMIDYMAX:
+            case SVGPreserveAspectRatio::SVG_PRESERVEASPECTRATIO_XMAXYMAX:
                 destRect.setY(destRect.y() + origDestHeight - destRect.height());
                 break;
             default:
@@ -209,14 +209,14 @@ void SVGPreserveAspectRatioValue::transformRect(FloatRect& destRect, FloatRect&
         if (origDestWidth > origDestHeight / widthToHeightMultiplier) {
             destRect.setWidth(origDestHeight / widthToHeightMultiplier);
             switch (m_align) {
-            case SVGPreserveAspectRatioValue::SVG_PRESERVEASPECTRATIO_XMIDYMIN:
-            case SVGPreserveAspectRatioValue::SVG_PRESERVEASPECTRATIO_XMIDYMID:
-            case SVGPreserveAspectRatioValue::SVG_PRESERVEASPECTRATIO_XMIDYMAX:
+            case SVGPreserveAspectRatio::SVG_PRESERVEASPECTRATIO_XMIDYMIN:
+            case SVGPreserveAspectRatio::SVG_PRESERVEASPECTRATIO_XMIDYMID:
+            case SVGPreserveAspectRatio::SVG_PRESERVEASPECTRATIO_XMIDYMAX:
                 destRect.setX(destRect.x() + origDestWidth / 2 - destRect.width() / 2);
                 break;
-            case SVGPreserveAspectRatioValue::SVG_PRESERVEASPECTRATIO_XMAXYMIN:
-            case SVGPreserveAspectRatioValue::SVG_PRESERVEASPECTRATIO_XMAXYMID:
-            case SVGPreserveAspectRatioValue::SVG_PRESERVEASPECTRATIO_XMAXYMAX:
+            case SVGPreserveAspectRatio::SVG_PRESERVEASPECTRATIO_XMAXYMIN:
+            case SVGPreserveAspectRatio::SVG_PRESERVEASPECTRATIO_XMAXYMID:
+            case SVGPreserveAspectRatio::SVG_PRESERVEASPECTRATIO_XMAXYMAX:
                 destRect.setX(destRect.x() + origDestWidth - destRect.width());
                 break;
             default:
@@ -225,21 +225,21 @@ void SVGPreserveAspectRatioValue::transformRect(FloatRect& destRect, FloatRect&
         }
         break;
     }
-    case SVGPreserveAspectRatioValue::SVG_MEETORSLICE_SLICE: {
+    case SVGPreserveAspectRatio::SVG_MEETORSLICE_SLICE: {
         float widthToHeightMultiplier = srcRect.height() / srcRect.width();
         // if the destination height is less than the height of the image we'll be drawing
         if (origDestHeight < origDestWidth * widthToHeightMultiplier) {
             float destToSrcMultiplier = srcRect.width() / destRect.width();
             srcRect.setHeight(destRect.height() * destToSrcMultiplier);
             switch (m_align) {
-            case SVGPreserveAspectRatioValue::SVG_PRESERVEASPECTRATIO_XMINYMID:
-            case SVGPreserveAspectRatioValue::SVG_PRESERVEASPECTRATIO_XMIDYMID:
-            case SVGPreserveAspectRatioValue::SVG_PRESERVEASPECTRATIO_XMAXYMID:
+            case SVGPreserveAspectRatio::SVG_PRESERVEASPECTRATIO_XMINYMID:
+            case SVGPreserveAspectRatio::SVG_PRESERVEASPECTRATIO_XMIDYMID:
+            case SVGPreserveAspectRatio::SVG_PRESERVEASPECTRATIO_XMAXYMID:
                 srcRect.setY(srcRect.y() + imageSize.height() / 2 - srcRect.height() / 2);
                 break;
-            case SVGPreserveAspectRatioValue::SVG_PRESERVEASPECTRATIO_XMINYMAX:
-            case SVGPreserveAspectRatioValue::SVG_PRESERVEASPECTRATIO_XMIDYMAX:
-            case SVGPreserveAspectRatioValue::SVG_PRESERVEASPECTRATIO_XMAXYMAX:
+            case SVGPreserveAspectRatio::SVG_PRESERVEASPECTRATIO_XMINYMAX:
+            case SVGPreserveAspectRatio::SVG_PRESERVEASPECTRATIO_XMIDYMAX:
+            case SVGPreserveAspectRatio::SVG_PRESERVEASPECTRATIO_XMAXYMAX:
                 srcRect.setY(srcRect.y() + imageSize.height() - srcRect.height());
                 break;
             default:
@@ -251,14 +251,14 @@ void SVGPreserveAspectRatioValue::transformRect(FloatRect& destRect, FloatRect&
             float destToSrcMultiplier = srcRect.height() / destRect.height();
             srcRect.setWidth(destRect.width() * destToSrcMultiplier);
             switch (m_align) {
-            case SVGPreserveAspectRatioValue::SVG_PRESERVEASPECTRATIO_XMIDYMIN:
-            case SVGPreserveAspectRatioValue::SVG_PRESERVEASPECTRATIO_XMIDYMID:
-            case SVGPreserveAspectRatioValue::SVG_PRESERVEASPECTRATIO_XMIDYMAX:
+            case SVGPreserveAspectRatio::SVG_PRESERVEASPECTRATIO_XMIDYMIN:
+            case SVGPreserveAspectRatio::SVG_PRESERVEASPECTRATIO_XMIDYMID:
+            case SVGPreserveAspectRatio::SVG_PRESERVEASPECTRATIO_XMIDYMAX:
                 srcRect.setX(srcRect.x() + imageSize.width() / 2 - srcRect.width() / 2);
                 break;
-            case SVGPreserveAspectRatioValue::SVG_PRESERVEASPECTRATIO_XMAXYMIN:
-            case SVGPreserveAspectRatioValue::SVG_PRESERVEASPECTRATIO_XMAXYMID:
-            case SVGPreserveAspectRatioValue::SVG_PRESERVEASPECTRATIO_XMAXYMAX:
+            case SVGPreserveAspectRatio::SVG_PRESERVEASPECTRATIO_XMAXYMIN:
+            case SVGPreserveAspectRatio::SVG_PRESERVEASPECTRATIO_XMAXYMID:
+            case SVGPreserveAspectRatio::SVG_PRESERVEASPECTRATIO_XMAXYMAX:
                 srcRect.setX(srcRect.x() + imageSize.width() - srcRect.width());
                 break;
             default:
@@ -270,7 +270,7 @@ void SVGPreserveAspectRatioValue::transformRect(FloatRect& destRect, FloatRect&
     }
 }
 
-AffineTransform SVGPreserveAspectRatioValue::getCTM(float logicalX, float logicalY, float logicalWidth, float logicalHeight, float physicalWidth, float physicalHeight) const
+AffineTransform SVGPreserveAspectRatio::getCTM(float logicalX, float logicalY, float logicalWidth, float logicalHeight, float physicalWidth, float physicalHeight) const
 {
     AffineTransform transform;
     if (!logicalWidth || !logicalHeight || !physicalWidth || !physicalHeight) {
@@ -321,7 +321,7 @@ AffineTransform SVGPreserveAspectRatioValue::getCTM(float logicalX, float logica
     return transform;
 }
 
-String SVGPreserveAspectRatioValue::valueAsString() const
+String SVGPreserveAspectRatio::valueAsString() const
 {
     String alignType;
 
diff --git a/Source/WebCore/svg/SVGPreserveAspectRatio.h b/Source/WebCore/svg/SVGPreserveAspectRatio.h
index 7f7ae2274d0..747c8f78b04 100644
--- a/Source/WebCore/svg/SVGPreserveAspectRatio.h
+++ b/Source/WebCore/svg/SVGPreserveAspectRatio.h
@@ -1,111 +1,83 @@
 /*
- * Copyright (C) 2016 Apple Inc. All rights reserved.
+ * Copyright (C) 2004, 2005, 2008 Nikolas Zimmermann <zimmermann@kde.org>
+ * Copyright (C) 2004, 2005, 2006, 2007 Rob Buis <buis@kde.org>
  *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
  *
- * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS''
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
- * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
- * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE.
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public License
+ * along with this library; see the file COPYING.LIB.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
  */
+
 #pragma once
 
-#include "ExceptionCode.h"
-#include "SVGPreserveAspectRatioValue.h"
-#include "SVGPropertyTearOff.h"
+#include "ExceptionOr.h"
+#include "SVGPropertyTraits.h"
 
 namespace WebCore {
 
-class SVGPreserveAspectRatio : public SVGPropertyTearOff<SVGPreserveAspectRatioValue> {
+class AffineTransform;
+class FloatRect;
+
+class SVGPreserveAspectRatio {
+    WTF_MAKE_FAST_ALLOCATED;
 public:
-    static Ref<SVGPreserveAspectRatio> create(SVGAnimatedProperty* animatedProperty, SVGPropertyRole role, SVGPreserveAspectRatioValue& value)
-    {
-        ASSERT(animatedProperty);
-        return adoptRef(*new SVGPreserveAspectRatio(animatedProperty, role, value));
-    }
-
-    static Ref<SVGPreserveAspectRatio> create(const SVGPreserveAspectRatioValue& initialValue = { })
-    {
-        return adoptRef(*new SVGPreserveAspectRatio(initialValue));
-    }
-
-    static Ref<SVGPreserveAspectRatio> create(const SVGPreserveAspectRatioValue* initialValue)
-    {
-        return adoptRef(*new SVGPreserveAspectRatio(initialValue));
-    }
-
-    template<typename T> static ExceptionOr<Ref<SVGPreserveAspectRatio>> create(ExceptionOr<T>&& initialValue)
-    {
-        if (initialValue.hasException())
-            return initialValue.releaseException();
-        return create(initialValue.releaseReturnValue());
-    }
-
-    unsigned short align()
-    {
-        return propertyReference().align();
-    }
-
-    ExceptionOr<void> setAlign(float value)
-    {
-        if (isReadOnly())
-            return Exception { NO_MODIFICATION_ALLOWED_ERR };
-
-        auto result = propertyReference().setAlign(value);
-        if (result.hasException())
-            return result;
-
-        commitChange();
-        return result;
-    }
-
-    unsigned short meetOrSlice()
-    {
-        return propertyReference().meetOrSlice();
-    }
-
-    ExceptionOr<void> setMeetOrSlice(float value)
-    {
-        if (isReadOnly())
-            return Exception { NO_MODIFICATION_ALLOWED_ERR };
-
-        auto result = propertyReference().setMeetOrSlice(value);
-        if (result.hasException())
-            return result;
-
-        commitChange();
-        return result;
-    }
+    enum SVGPreserveAspectRatioType {
+        SVG_PRESERVEASPECTRATIO_UNKNOWN = 0,
+        SVG_PRESERVEASPECTRATIO_NONE = 1,
+        SVG_PRESERVEASPECTRATIO_XMINYMIN = 2,
+        SVG_PRESERVEASPECTRATIO_XMIDYMIN = 3,
+        SVG_PRESERVEASPECTRATIO_XMAXYMIN = 4,
+        SVG_PRESERVEASPECTRATIO_XMINYMID = 5,
+        SVG_PRESERVEASPECTRATIO_XMIDYMID = 6,
+        SVG_PRESERVEASPECTRATIO_XMAXYMID = 7,
+        SVG_PRESERVEASPECTRATIO_XMINYMAX = 8,
+        SVG_PRESERVEASPECTRATIO_XMIDYMAX = 9,
+        SVG_PRESERVEASPECTRATIO_XMAXYMAX = 10
+    };
+
+    enum SVGMeetOrSliceType {
+        SVG_MEETORSLICE_UNKNOWN = 0,
+        SVG_MEETORSLICE_MEET = 1,
+        SVG_MEETORSLICE_SLICE = 2
+    };
+
+    SVGPreserveAspectRatio();
+
+    ExceptionOr<void> setAlign(unsigned short);
+    unsigned short align() const { return m_align; }
+
+    ExceptionOr<void> setMeetOrSlice(unsigned short);
+    unsigned short meetOrSlice() const { return m_meetOrSlice; }
+
+    void transformRect(FloatRect& destRect, FloatRect& srcRect);
+
+    AffineTransform getCTM(float logicalX, float logicalY, float logicalWidth, float logicalHeight, float physicalWidth, float physicalHeight) const;
+
+    void parse(const String&);
+    bool parse(const UChar*& currParam, const UChar* end, bool validate);
+
+    String valueAsString() const;
 
 private:
-    SVGPreserveAspectRatio(SVGAnimatedProperty* animatedProperty, SVGPropertyRole role, SVGPreserveAspectRatioValue& value)
-        : SVGPropertyTearOff<SVGPreserveAspectRatioValue>(animatedProperty, role, value)
-    {
-    }
-
-    explicit SVGPreserveAspectRatio(const SVGPreserveAspectRatioValue& initialValue)
-        : SVGPropertyTearOff<SVGPreserveAspectRatioValue>(initialValue)
-    {
-    }
-
-    explicit SVGPreserveAspectRatio(const SVGPreserveAspectRatioValue* initialValue)
-        : SVGPropertyTearOff<SVGPreserveAspectRatioValue>(initialValue)
-    {
-    }
+    SVGPreserveAspectRatioType m_align;
+    SVGMeetOrSliceType m_meetOrSlice;
+
+    bool parseInternal(const UChar*& currParam, const UChar* end, bool validate);
+};
+
+template<> struct SVGPropertyTraits<SVGPreserveAspectRatio> {
+    static SVGPreserveAspectRatio initialValue() { return SVGPreserveAspectRatio(); }
+    static String toString(const SVGPreserveAspectRatio& type) { return type.valueAsString(); }
 };
 
 } // namespace WebCore
diff --git a/Source/WebCore/svg/SVGPreserveAspectRatio.idl b/Source/WebCore/svg/SVGPreserveAspectRatio.idl
index 03399c21fb5..407a7f881a0 100644
--- a/Source/WebCore/svg/SVGPreserveAspectRatio.idl
+++ b/Source/WebCore/svg/SVGPreserveAspectRatio.idl
@@ -23,9 +23,7 @@
  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
  */
 
-[
-    ConstantsScope=SVGPreserveAspectRatioValue
-] interface SVGPreserveAspectRatio {
+interface SVGPreserveAspectRatio {
     // Alignment Types
     const unsigned short SVG_PRESERVEASPECTRATIO_UNKNOWN = 0;
     const unsigned short SVG_PRESERVEASPECTRATIO_NONE = 1;
diff --git a/Source/WebCore/svg/SVGPreserveAspectRatioValue.h b/Source/WebCore/svg/SVGPreserveAspectRatioValue.h
deleted file mode 100644
index a1fc114f6c4..00000000000
--- a/Source/WebCore/svg/SVGPreserveAspectRatioValue.h
+++ /dev/null
@@ -1,83 +0,0 @@
-/*
- * Copyright (C) 2004, 2005, 2008 Nikolas Zimmermann <zimmermann@kde.org>
- * Copyright (C) 2004, 2005, 2006, 2007 Rob Buis <buis@kde.org>
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Library General Public
- * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Library General Public License for more details.
- *
- * You should have received a copy of the GNU Library General Public License
- * along with this library; see the file COPYING.LIB.  If not, write to
- * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA 02110-1301, USA.
- */
-
-#pragma once
-
-#include "ExceptionOr.h"
-#include "SVGPropertyTraits.h"
-
-namespace WebCore {
-
-class AffineTransform;
-class FloatRect;
-
-class SVGPreserveAspectRatioValue {
-    WTF_MAKE_FAST_ALLOCATED;
-public:
-    enum SVGPreserveAspectRatioType {
-        SVG_PRESERVEASPECTRATIO_UNKNOWN = 0,
-        SVG_PRESERVEASPECTRATIO_NONE = 1,
-        SVG_PRESERVEASPECTRATIO_XMINYMIN = 2,
-        SVG_PRESERVEASPECTRATIO_XMIDYMIN = 3,
-        SVG_PRESERVEASPECTRATIO_XMAXYMIN = 4,
-        SVG_PRESERVEASPECTRATIO_XMINYMID = 5,
-        SVG_PRESERVEASPECTRATIO_XMIDYMID = 6,
-        SVG_PRESERVEASPECTRATIO_XMAXYMID = 7,
-        SVG_PRESERVEASPECTRATIO_XMINYMAX = 8,
-        SVG_PRESERVEASPECTRATIO_XMIDYMAX = 9,
-        SVG_PRESERVEASPECTRATIO_XMAXYMAX = 10
-    };
-
-    enum SVGMeetOrSliceType {
-        SVG_MEETORSLICE_UNKNOWN = 0,
-        SVG_MEETORSLICE_MEET = 1,
-        SVG_MEETORSLICE_SLICE = 2
-    };
-
-    SVGPreserveAspectRatioValue();
-
-    ExceptionOr<void> setAlign(unsigned short);
-    unsigned short align() const { return m_align; }
-
-    ExceptionOr<void> setMeetOrSlice(unsigned short);
-    unsigned short meetOrSlice() const { return m_meetOrSlice; }
-
-    void transformRect(FloatRect& destRect, FloatRect& srcRect);
-
-    AffineTransform getCTM(float logicalX, float logicalY, float logicalWidth, float logicalHeight, float physicalWidth, float physicalHeight) const;
-
-    void parse(const String&);
-    bool parse(const UChar*& currParam, const UChar* end, bool validate);
-
-    String valueAsString() const;
-
-private:
-    SVGPreserveAspectRatioType m_align;
-    SVGMeetOrSliceType m_meetOrSlice;
-
-    bool parseInternal(const UChar*& currParam, const UChar* end, bool validate);
-};
-
-template<> struct SVGPropertyTraits<SVGPreserveAspectRatioValue> {
-    static SVGPreserveAspectRatioValue initialValue() { return SVGPreserveAspectRatioValue(); }
-    static String toString(const SVGPreserveAspectRatioValue& type) { return type.valueAsString(); }
-};
-
-} // namespace WebCore
diff --git a/Source/WebCore/svg/SVGViewSpec.cpp b/Source/WebCore/svg/SVGViewSpec.cpp
index c5edbb0b9b2..d2cc6f744de 100644
--- a/Source/WebCore/svg/SVGViewSpec.cpp
+++ b/Source/WebCore/svg/SVGViewSpec.cpp
@@ -117,7 +117,7 @@ String SVGViewSpec::viewBoxString() const
 
 String SVGViewSpec::preserveAspectRatioString() const
 {
-    return SVGPropertyTraits<SVGPreserveAspectRatioValue>::toString(m_preserveAspectRatio);
+    return SVGPropertyTraits<SVGPreserveAspectRatio>::toString(m_preserveAspectRatio);
 }
 
 SVGElement* SVGViewSpec::viewTarget() const
@@ -163,7 +163,7 @@ Ref<SVGAnimatedProperty> SVGViewSpec::lookupOrCreatePreserveAspectRatioWrapper(S
 {
     ASSERT(ownerType);
     ASSERT(ownerType->m_contextElement);
-    return SVGAnimatedProperty::lookupOrCreateWrapper<SVGElement, SVGAnimatedPreserveAspectRatio, SVGPreserveAspectRatioValue>(ownerType->m_contextElement, preserveAspectRatioPropertyInfo(), ownerType->m_preserveAspectRatio);
+    return SVGAnimatedProperty::lookupOrCreateWrapper<SVGElement, SVGAnimatedPreserveAspectRatio, SVGPreserveAspectRatio>(ownerType->m_contextElement, preserveAspectRatioPropertyInfo(), ownerType->m_preserveAspectRatio);
 }
 
 Ref<SVGAnimatedProperty> SVGViewSpec::lookupOrCreateTransformWrapper(SVGViewSpec* ownerType)
@@ -178,7 +178,7 @@ void SVGViewSpec::reset()
     m_zoomAndPan = SVGZoomAndPanMagnify;
     m_transform.clear();
     m_viewBox = FloatRect();
-    m_preserveAspectRatio = SVGPreserveAspectRatioValue();
+    m_preserveAspectRatio = SVGPreserveAspectRatio();
     m_viewTargetString = emptyString();
 }
 
@@ -247,7 +247,7 @@ bool SVGViewSpec::parseViewSpec(const String& viewSpec)
             if (currViewSpec >= end || *currViewSpec != '(')
                 return false;
             currViewSpec++;
-            SVGPreserveAspectRatioValue preserveAspectRatio;
+            SVGPreserveAspectRatio preserveAspectRatio;
             if (!preserveAspectRatio.parse(currViewSpec, end, false))
                 return false;
             setPreserveAspectRatioBaseValue(preserveAspectRatio);
diff --git a/Source/WebCore/svg/SVGViewSpec.h b/Source/WebCore/svg/SVGViewSpec.h
index 79081c92f61..de109b704f9 100644
--- a/Source/WebCore/svg/SVGViewSpec.h
+++ b/Source/WebCore/svg/SVGViewSpec.h
@@ -64,8 +64,8 @@ public:
 
     // Custom animated 'preserveAspectRatio' property.
     RefPtr<SVGAnimatedPreserveAspectRatio> preserveAspectRatioAnimated();
-    SVGPreserveAspectRatioValue& preserveAspectRatio() { return m_preserveAspectRatio; }
-    void setPreserveAspectRatioBaseValue(const SVGPreserveAspectRatioValue& preserveAspectRatio) { m_preserveAspectRatio = preserveAspectRatio; }
+    SVGPreserveAspectRatio& preserveAspectRatio() { return m_preserveAspectRatio; }
+    void setPreserveAspectRatioBaseValue(const SVGPreserveAspectRatio& preserveAspectRatio) { m_preserveAspectRatio = preserveAspectRatio; }
 
 private:
     explicit SVGViewSpec(SVGElement&);
@@ -86,7 +86,7 @@ private:
     SVGZoomAndPanType m_zoomAndPan { SVGZoomAndPanMagnify };
     SVGTransformList m_transform;
     FloatRect m_viewBox;
-    SVGPreserveAspectRatioValue m_preserveAspectRatio;
+    SVGPreserveAspectRatio m_preserveAspectRatio;
     String m_viewTargetString;
 };
 
diff --git a/Source/WebCore/svg/graphics/SVGImage.cpp b/Source/WebCore/svg/graphics/SVGImage.cpp
index ef934420a0b..d69d2f6245e 100644
--- a/Source/WebCore/svg/graphics/SVGImage.cpp
+++ b/Source/WebCore/svg/graphics/SVGImage.cpp
@@ -1,6 +1,6 @@
 /*
  * Copyright (C) 2006 Eric Seidel <eric@webkit.org>
- * Copyright (C) 2008-2009, 2015-2016 Apple Inc. All rights reserved.
+ * Copyright (C) 2008, 2009, 2015 Apple Inc. All rights reserved.
  * Copyright (C) Research In Motion Limited 2011. All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -54,11 +54,6 @@
 #include <runtime/JSCInlines.h>
 #include <runtime/JSLock.h>
 
-#if USE(DIRECT2D)
-#include "COMPtr.h"
-#include <d2d1.h>
-#endif
-
 namespace WebCore {
 
 SVGImage::SVGImage(ImageObserver& observer, const URL& url)
@@ -192,7 +187,7 @@ void SVGImage::drawForContainer(GraphicsContext& context, const FloatSize contai
 #if USE(CAIRO)
 // Passes ownership of the native image to the caller so NativeImagePtr needs
 // to be a smart pointer type.
-NativeImagePtr SVGImage::nativeImageForCurrentFrame(const GraphicsContext*)
+NativeImagePtr SVGImage::nativeImageForCurrentFrame()
 {
     if (!m_page)
         return nullptr;
@@ -209,33 +204,6 @@ NativeImagePtr SVGImage::nativeImageForCurrentFrame(const GraphicsContext*)
 }
 #endif
 
-#if USE(DIRECT2D)
-NativeImagePtr SVGImage::nativeImage(const GraphicsContext* targetContext)
-{
-    ASSERT(targetContext);
-    if (!m_page || !targetContext)
-        return nullptr;
-
-    auto platformContext = targetContext->platformContext();
-    ASSERT(platformContext);
-
-    // Draw the SVG into a bitmap.
-    COMPtr<ID2D1BitmapRenderTarget> nativeImageTarget;
-    HRESULT hr = platformContext->CreateCompatibleRenderTarget(IntSize(rect().size()), &nativeImageTarget);
-    ASSERT(SUCCEEDED(hr));
-
-    GraphicsContext localContext(nativeImageTarget.get());
-
-    draw(localContext, rect(), rect(), CompositeSourceOver, BlendModeNormal, ImageOrientationDescription());
-
-    COMPtr<ID2D1Bitmap> nativeImage;
-    hr = nativeImageTarget->GetBitmap(&nativeImage);
-    ASSERT(SUCCEEDED(hr));
-
-    return nativeImage;
-}
-#endif
-
 void SVGImage::drawPatternForContainer(GraphicsContext& context, const FloatSize& containerSize, float zoom, const FloatRect& srcRect,
     const AffineTransform& patternTransform, const FloatPoint& phase, const FloatSize& spacing, CompositeOperator compositeOp, const FloatRect& dstRect, BlendMode blendMode)
 {
@@ -251,7 +219,7 @@ void SVGImage::drawPatternForContainer(GraphicsContext& context, const FloatSize
     FloatRect imageBufferSize = zoomedContainerRect;
     imageBufferSize.scale(imageBufferScale.width(), imageBufferScale.height());
 
-    std::unique_ptr<ImageBuffer> buffer = ImageBuffer::createCompatibleBuffer(expandedIntSize(imageBufferSize.size()), 1, ColorSpaceSRGB, context);
+    std::unique_ptr<ImageBuffer> buffer = ImageBuffer::createCompatibleBuffer(expandedIntSize(imageBufferSize.size()), 1, ColorSpaceSRGB, context, true);
     if (!buffer) // Failed to allocate buffer.
         return;
     drawForContainer(buffer->context(), containerSize, zoom, imageBufferSize, zoomedContainerRect, CompositeSourceOver, BlendModeNormal);
@@ -269,7 +237,7 @@ void SVGImage::drawPatternForContainer(GraphicsContext& context, const FloatSize
     unscaledPatternTransform.scale(1 / imageBufferScale.width(), 1 / imageBufferScale.height());
 
     context.setDrawLuminanceMask(false);
-    image->drawPattern(context, dstRect, scaledSrcRect, unscaledPatternTransform, phase, spacing, compositeOp, blendMode);
+    image->drawPattern(context, scaledSrcRect, unscaledPatternTransform, phase, spacing, compositeOp, dstRect, blendMode);
 }
 
 void SVGImage::draw(GraphicsContext& context, const FloatRect& dstRect, const FloatRect& srcRect, CompositeOperator compositeOp, BlendMode blendMode, ImageOrientationDescription)
@@ -359,7 +327,7 @@ void SVGImage::computeIntrinsicDimensions(Length& intrinsicWidth, Length& intrin
 
     intrinsicWidth = rootElement->intrinsicWidth();
     intrinsicHeight = rootElement->intrinsicHeight();
-    if (rootElement->preserveAspectRatio().align() == SVGPreserveAspectRatioValue::SVG_PRESERVEASPECTRATIO_NONE)
+    if (rootElement->preserveAspectRatio().align() == SVGPreserveAspectRatio::SVG_PRESERVEASPECTRATIO_NONE)
         return;
 
     intrinsicRatio = rootElement->viewBox().size();
@@ -367,7 +335,8 @@ void SVGImage::computeIntrinsicDimensions(Length& intrinsicWidth, Length& intrin
         intrinsicRatio = FloatSize(floatValueForLength(intrinsicWidth, 0), floatValueForLength(intrinsicHeight, 0));
 }
 
-void SVGImage::startAnimation()
+// FIXME: support catchUpIfNecessary.
+void SVGImage::startAnimation(CatchUpAnimation)
 {
     SVGSVGElement* rootElement = this->rootElement();
     if (!rootElement)
diff --git a/Source/WebCore/svg/graphics/SVGImage.h b/Source/WebCore/svg/graphics/SVGImage.h
index 13f9ed87e00..8d04dc8411c 100644
--- a/Source/WebCore/svg/graphics/SVGImage.h
+++ b/Source/WebCore/svg/graphics/SVGImage.h
@@ -60,15 +60,12 @@ public:
     bool hasRelativeWidth() const final;
     bool hasRelativeHeight() const final;
 
-    void startAnimation() final;
+    void startAnimation(CatchUpAnimation = CatchUp) final;
     void stopAnimation() final;
     void resetAnimation() final;
 
 #if USE(CAIRO)
-    NativeImagePtr nativeImageForCurrentFrame(const GraphicsContext* = nullptr) final;
-#endif
-#if USE(DIRECT2D)
-    NativeImagePtr nativeImage(const GraphicsContext* = nullptr) final;
+    NativeImagePtr nativeImageForCurrentFrame() final;
 #endif
 
 private:
@@ -91,7 +88,7 @@ private:
     void destroyDecodedData(bool) final { }
 
     // FIXME: Implement this to be less conservative.
-    bool currentFrameKnownToBeOpaque() const final { return false; }
+    bool currentFrameKnownToBeOpaque() final { return false; }
 
     void dump(TextStream&) const final;
 
diff --git a/Source/WebCore/svg/graphics/SVGImageClients.h b/Source/WebCore/svg/graphics/SVGImageClients.h
index bee03d5068c..0dbadb74160 100644
--- a/Source/WebCore/svg/graphics/SVGImageClients.h
+++ b/Source/WebCore/svg/graphics/SVGImageClients.h
@@ -53,7 +53,7 @@ private:
     {
         // If m_image->m_page is null, we're being destructed, don't fire changedInRect() in that case.
         if (m_image && m_image->imageObserver() && m_image->m_page)
-            m_image->imageObserver()->changedInRect(m_image, &r);
+            m_image->imageObserver()->changedInRect(m_image, r);
     }
     
     SVGImage* m_image;
diff --git a/Source/WebCore/svg/graphics/SVGImageForContainer.cpp b/Source/WebCore/svg/graphics/SVGImageForContainer.cpp
index 482c3941514..7e143ded2d6 100644
--- a/Source/WebCore/svg/graphics/SVGImageForContainer.cpp
+++ b/Source/WebCore/svg/graphics/SVGImageForContainer.cpp
@@ -40,15 +40,15 @@ void SVGImageForContainer::draw(GraphicsContext& context, const FloatRect& dstRe
     m_image->drawForContainer(context, m_containerSize, m_zoom, dstRect, srcRect, compositeOp, blendMode);
 }
 
-void SVGImageForContainer::drawPattern(GraphicsContext& context, const FloatRect& dstRect, const FloatRect& srcRect, const AffineTransform& patternTransform,
-    const FloatPoint& phase, const FloatSize& spacing, CompositeOperator compositeOp, BlendMode blendMode)
+void SVGImageForContainer::drawPattern(GraphicsContext& context, const FloatRect& srcRect, const AffineTransform& patternTransform,
+    const FloatPoint& phase, const FloatSize& spacing, CompositeOperator compositeOp, const FloatRect& dstRect, BlendMode blendMode)
 {
     m_image->drawPatternForContainer(context, m_containerSize, m_zoom, srcRect, patternTransform, phase, spacing, compositeOp, dstRect, blendMode);
 }
 
-NativeImagePtr SVGImageForContainer::nativeImageForCurrentFrame(const GraphicsContext* targetContext)
+NativeImagePtr SVGImageForContainer::nativeImageForCurrentFrame()
 {
-    return m_image->nativeImageForCurrentFrame(targetContext);
+    return m_image->nativeImageForCurrentFrame();
 }
 
 } // namespace WebCore
diff --git a/Source/WebCore/svg/graphics/SVGImageForContainer.h b/Source/WebCore/svg/graphics/SVGImageForContainer.h
index aa1988a00b6..dba315f890b 100644
--- a/Source/WebCore/svg/graphics/SVGImageForContainer.h
+++ b/Source/WebCore/svg/graphics/SVGImageForContainer.h
@@ -57,12 +57,12 @@ public:
 
     void draw(GraphicsContext&, const FloatRect&, const FloatRect&, CompositeOperator, BlendMode, ImageOrientationDescription) final;
 
-    void drawPattern(GraphicsContext&, const FloatRect&, const FloatRect&, const AffineTransform&, const FloatPoint&, const FloatSize&, CompositeOperator, BlendMode) final;
+    void drawPattern(GraphicsContext&, const FloatRect&, const AffineTransform&, const FloatPoint&, const FloatSize&, CompositeOperator, const FloatRect&, BlendMode) final;
 
     // FIXME: Implement this to be less conservative.
-    bool currentFrameKnownToBeOpaque() const final { return false; }
+    bool currentFrameKnownToBeOpaque() final { return false; }
 
-    NativeImagePtr nativeImageForCurrentFrame(const GraphicsContext* = nullptr) final;
+    NativeImagePtr nativeImageForCurrentFrame() final;
 
 private:
     SVGImageForContainer(SVGImage* image, const FloatSize& containerSize, float zoom)
diff --git a/Source/WebCore/svg/graphics/filters/SVGFEImage.cpp b/Source/WebCore/svg/graphics/filters/SVGFEImage.cpp
index d25893e2a62..922fd34db32 100644
--- a/Source/WebCore/svg/graphics/filters/SVGFEImage.cpp
+++ b/Source/WebCore/svg/graphics/filters/SVGFEImage.cpp
@@ -29,13 +29,14 @@
 #include "RenderElement.h"
 #include "RenderTreeAsText.h"
 #include "SVGElement.h"
+#include "SVGPreserveAspectRatio.h"
 #include "SVGRenderingContext.h"
 #include "SVGURIReference.h"
 #include "TextStream.h"
 
 namespace WebCore {
 
-FEImage::FEImage(Filter& filter, RefPtr<Image> image, const SVGPreserveAspectRatioValue& preserveAspectRatio)
+FEImage::FEImage(Filter& filter, RefPtr<Image> image, const SVGPreserveAspectRatio& preserveAspectRatio)
     : FilterEffect(filter)
     , m_image(image)
     , m_document(nullptr)
@@ -43,7 +44,7 @@ FEImage::FEImage(Filter& filter, RefPtr<Image> image, const SVGPreserveAspectRat
 {
 }
 
-FEImage::FEImage(Filter& filter, Document& document, const String& href, const SVGPreserveAspectRatioValue& preserveAspectRatio)
+FEImage::FEImage(Filter& filter, Document& document, const String& href, const SVGPreserveAspectRatio& preserveAspectRatio)
     : FilterEffect(filter)
     , m_document(&document)
     , m_href(href)
@@ -51,12 +52,12 @@ FEImage::FEImage(Filter& filter, Document& document, const String& href, const S
 {
 }
 
-Ref<FEImage> FEImage::createWithImage(Filter& filter, RefPtr<Image> image, const SVGPreserveAspectRatioValue& preserveAspectRatio)
+Ref<FEImage> FEImage::createWithImage(Filter& filter, RefPtr<Image> image, const SVGPreserveAspectRatio& preserveAspectRatio)
 {
     return adoptRef(*new FEImage(filter, image, preserveAspectRatio));
 }
 
-Ref<FEImage> FEImage::createWithIRIReference(Filter& filter, Document& document, const String& href, const SVGPreserveAspectRatioValue& preserveAspectRatio)
+Ref<FEImage> FEImage::createWithIRIReference(Filter& filter, Document& document, const String& href, const SVGPreserveAspectRatio& preserveAspectRatio)
 {
     return adoptRef(*new FEImage(filter, document, href, preserveAspectRatio));
 }
diff --git a/Source/WebCore/svg/graphics/filters/SVGFEImage.h b/Source/WebCore/svg/graphics/filters/SVGFEImage.h
index 45d8a1be9cb..85b02b48a52 100644
--- a/Source/WebCore/svg/graphics/filters/SVGFEImage.h
+++ b/Source/WebCore/svg/graphics/filters/SVGFEImage.h
@@ -23,7 +23,7 @@
 #pragma once
 
 #include "FilterEffect.h"
-#include "SVGPreserveAspectRatioValue.h"
+#include "SVGPreserveAspectRatio.h"
 
 namespace WebCore {
 
@@ -33,8 +33,8 @@ class RenderElement;
 
 class FEImage final : public FilterEffect {
 public:
-    static Ref<FEImage> createWithImage(Filter&, RefPtr<Image>, const SVGPreserveAspectRatioValue&);
-    static Ref<FEImage> createWithIRIReference(Filter&, Document&, const String&, const SVGPreserveAspectRatioValue&);
+    static Ref<FEImage> createWithImage(Filter&, RefPtr<Image>, const SVGPreserveAspectRatio&);
+    static Ref<FEImage> createWithIRIReference(Filter&, Document&, const String&, const SVGPreserveAspectRatio&);
 
     void platformApplySoftware() final;
     void dump() final;
@@ -47,8 +47,8 @@ public:
     
 private:
     virtual ~FEImage() { }
-    FEImage(Filter&, RefPtr<Image>, const SVGPreserveAspectRatioValue&);
-    FEImage(Filter&, Document&, const String&, const SVGPreserveAspectRatioValue&);
+    FEImage(Filter&, RefPtr<Image>, const SVGPreserveAspectRatio&);
+    FEImage(Filter&, Document&, const String&, const SVGPreserveAspectRatio&);
     RenderElement* referencedRenderer() const;
 
     RefPtr<Image> m_image;
@@ -56,7 +56,7 @@ private:
     // m_document will never be a dangling reference. See https://bugs.webkit.org/show_bug.cgi?id=99243
     Document* m_document;
     String m_href;
-    SVGPreserveAspectRatioValue m_preserveAspectRatio;
+    SVGPreserveAspectRatio m_preserveAspectRatio;
 };
 
 } // namespace WebCore
diff --git a/Source/WebCore/testing/Internals.cpp b/Source/WebCore/testing/Internals.cpp
index b7c29258fff..d6e3a2428b0 100644
--- a/Source/WebCore/testing/Internals.cpp
+++ b/Source/WebCore/testing/Internals.cpp
@@ -649,19 +649,6 @@ unsigned Internals::imageFrameIndex(HTMLImageElement& element)
     return is<BitmapImage>(image) ? downcast<BitmapImage>(*image).currentFrame() : 0;
 }
 
-void Internals::setImageFrameDecodingDuration(HTMLImageElement& element, float duration)
-{
-    auto* cachedImage = element.cachedImage();
-    if (!cachedImage)
-        return;
-    
-    auto* image = cachedImage->image();
-    if (!is<BitmapImage>(image))
-        return;
-    
-    downcast<BitmapImage>(*image).setFrameDecodingDurationForTesting(duration);
-}
-
 void Internals::clearPageCache()
 {
     PageCache::singleton().pruneToSizeNow(0, PruningReason::None);
diff --git a/Source/WebCore/testing/Internals.h b/Source/WebCore/testing/Internals.h
index 9421cd42059..4d20f9f8121 100644
--- a/Source/WebCore/testing/Internals.h
+++ b/Source/WebCore/testing/Internals.h
@@ -103,7 +103,6 @@ public:
     unsigned memoryCacheSize() const;
 
     unsigned imageFrameIndex(HTMLImageElement&);
-    void setImageFrameDecodingDuration(HTMLImageElement&, float duration);
 
     void clearPageCache();
     unsigned pageCacheSize() const;
diff --git a/Source/WebCore/testing/Internals.idl b/Source/WebCore/testing/Internals.idl
index 266b91e63ae..89612d224e8 100644
--- a/Source/WebCore/testing/Internals.idl
+++ b/Source/WebCore/testing/Internals.idl
@@ -221,7 +221,6 @@ enum UserInterfaceLayoutDirection {
     [MayThrowException] boolean isPageBoxVisible(long pageNumber);
 
     unsigned long imageFrameIndex(HTMLImageElement element);
-    void setImageFrameDecodingDuration(HTMLImageElement element, unrestricted float duration);
 
     readonly attribute InternalSettings settings;
     readonly attribute unsigned long workerThreadCount;
diff --git a/Source/WebKit/mac/DOM/DOM.mm b/Source/WebKit/mac/DOM/DOM.mm
index 91efc93b429..a151454b103 100644
--- a/Source/WebKit/mac/DOM/DOM.mm
+++ b/Source/WebKit/mac/DOM/DOM.mm
@@ -561,7 +561,7 @@ id <DOMEventTarget> kit(EventTarget* eventTarget)
 
     if (textIndicator) {
         if (Image* image = textIndicator->contentImage())
-            *cgImage = image->nativeImage().autorelease();
+            *cgImage = (CGImageRef)CFAutorelease(CGImageRetain(image->getCGImageRef()));
     }
 
     RetainPtr<NSMutableArray> rectArray = adoptNS([[NSMutableArray alloc] init]);
@@ -670,7 +670,7 @@ id <DOMEventTarget> kit(EventTarget* eventTarget)
     auto* cachedImage = downcast<RenderImage>(*renderer).cachedImage();
     if (!cachedImage || cachedImage->errorOccurred())
         return nil;
-    return cachedImage->imageForRenderer(renderer)->nsImage();
+    return cachedImage->imageForRenderer(renderer)->getNSImage();
 }
 
 #endif
@@ -698,7 +698,7 @@ id <DOMEventTarget> kit(EventTarget* eventTarget)
     auto* cachedImage = downcast<RenderImage>(*renderer).cachedImage();
     if (!cachedImage || cachedImage->errorOccurred())
         return nil;
-    return (NSData *)cachedImage->imageForRenderer(renderer)->tiffRepresentation();
+    return (NSData *)cachedImage->imageForRenderer(renderer)->getTIFFRepresentation();
 }
 
 #endif
diff --git a/Source/WebKit/mac/Misc/WebCache.mm b/Source/WebKit/mac/Misc/WebCache.mm
index 7c5ed210ddb..b659d6dbf9a 100644
--- a/Source/WebKit/mac/Misc/WebCache.mm
+++ b/Source/WebKit/mac/Misc/WebCache.mm
@@ -204,7 +204,7 @@
     WebCore::CachedImage& cachedImage = downcast<WebCore::CachedImage>(*cachedResource);
     if (!cachedImage.hasImage())
         return nullptr;
-    return cachedImage.image()->nativeImage().get();
+    return cachedImage.image()->getCGImageRef();
 }
 
 #endif // PLATFORM(IOS)
diff --git a/Source/WebKit/mac/Misc/WebElementDictionary.mm b/Source/WebKit/mac/Misc/WebElementDictionary.mm
index de09aa67b9d..2126f756093 100644
--- a/Source/WebKit/mac/Misc/WebElementDictionary.mm
+++ b/Source/WebKit/mac/Misc/WebElementDictionary.mm
@@ -204,7 +204,7 @@ static NSString* NSStringOrNil(String coreString)
 - (NSImage *)_image
 {
     Image* image = _result->image();
-    return image ? image->nsImage() : nil;
+    return image ? image->getNSImage() : nil;
 }
 
 - (NSValue *)_imageRect
diff --git a/Source/WebKit/mac/Misc/WebIconDatabase.mm b/Source/WebKit/mac/Misc/WebIconDatabase.mm
index 862db48203e..30b9b7e5cc7 100644
--- a/Source/WebKit/mac/Misc/WebIconDatabase.mm
+++ b/Source/WebKit/mac/Misc/WebIconDatabase.mm
@@ -163,7 +163,7 @@ static WebIconDatabaseClient* defaultClient()
     ASSERT(size.height);
     
     Image* image = iconDatabase().defaultIcon(IntSize(size));
-    return image ? image->snapshotNSImage().autorelease() : nil;
+    return image ? image->getNSImage() : nil;
 }
 
 - (NSImage *)defaultIconForURL:(NSString *)URL withSize:(NSSize)size
@@ -470,7 +470,7 @@ NSImage *webGetNSImage(Image* image, NSSize size)
     // to WebCore::Image at some point.
     if (!image)
         return nil;
-    NSImage* nsImage = image->nsImage();
+    NSImage* nsImage = image->getNSImage();
     if (!nsImage)
         return nil;
     if (!NSEqualSizes([nsImage size], size)) {
diff --git a/Source/WebKit/mac/WebCoreSupport/WebContextMenuClient.mm b/Source/WebKit/mac/WebCoreSupport/WebContextMenuClient.mm
index 24e80410317..5f87792924a 100644
--- a/Source/WebKit/mac/WebCoreSupport/WebContextMenuClient.mm
+++ b/Source/WebKit/mac/WebCoreSupport/WebContextMenuClient.mm
@@ -226,7 +226,7 @@ RetainPtr<NSImage> WebContextMenuClient::imageForCurrentSharingServicePickerItem
     if (!image)
         return nil;
 
-    return image->snapshotNSImage();
+    return [[image->getNSImage() retain] autorelease];
 }
 #endif
 
@@ -242,7 +242,7 @@ NSMenu *WebContextMenuClient::contextMenuForEvent(NSEvent *event, NSView *view,
     if (Image* image = page->contextMenuController().context().controlledImage()) {
         ASSERT(page->contextMenuController().context().hitTestResult().innerNode());
 
-        RetainPtr<NSItemProvider> itemProvider = adoptNS([[NSItemProvider alloc] initWithItem:image->snapshotNSImage().autorelease() typeIdentifier:@"public.image"]);
+        RetainPtr<NSItemProvider> itemProvider = adoptNS([[NSItemProvider alloc] initWithItem:image->getNSImage() typeIdentifier:@"public.image"]);
 
         bool isContentEditable = page->contextMenuController().context().hitTestResult().innerNode()->isContentEditable();
         m_sharingServicePickerController = adoptNS([[WebSharingServicePickerController alloc] initWithItems:@[ itemProvider.get() ] includeEditorServices:isContentEditable client:this style:NSSharingServicePickerStyleRollover]);
diff --git a/Source/WebKit/mac/WebView/WebHTMLView.mm b/Source/WebKit/mac/WebView/WebHTMLView.mm
index 6359b028f17..0fc1cd1d73f 100644
--- a/Source/WebKit/mac/WebView/WebHTMLView.mm
+++ b/Source/WebKit/mac/WebView/WebHTMLView.mm
@@ -2187,7 +2187,7 @@ static bool mouseEventIsPartOfClickOrDrag(NSEvent *event)
         [archive release];
     } else if ([type isEqual:NSTIFFPboardType] && [self promisedDragTIFFDataSource]) {
         if (Image* image = [self promisedDragTIFFDataSource]->image())
-            [pasteboard setData:(NSData *)image->tiffRepresentation() forType:NSTIFFPboardType];
+            [pasteboard setData:(NSData *)image->getTIFFRepresentation() forType:NSTIFFPboardType];
         [self setPromisedDragTIFFDataSource:0];
     }
 }
diff --git a/Source/WebKit2/Shared/ShareableBitmap.cpp b/Source/WebKit2/Shared/ShareableBitmap.cpp
index bb912ea9d06..8db0411d82f 100644
--- a/Source/WebKit2/Shared/ShareableBitmap.cpp
+++ b/Source/WebKit2/Shared/ShareableBitmap.cpp
@@ -33,13 +33,6 @@
 using namespace WebCore;
 
 namespace WebKit {
-    
-static unsigned calculateBytesPerPixel(ShareableBitmap::Flags flags)
-{
-    if (flags & ShareableBitmap::SupportsExtendedColor)
-        return 8; // for extended color, we are using half-float representations
-    return 4;
-}
 
 ShareableBitmap::Handle::Handle()
     : m_flags(0)
@@ -61,7 +54,6 @@ bool ShareableBitmap::Handle::decode(IPC::Decoder& decoder, Handle& handle)
         return false;
     if (!decoder.decode(handle.m_flags))
         return false;
-    handle.m_bytesPerPixel = calculateBytesPerPixel(handle.m_flags);
     return true;
 }
 
@@ -70,13 +62,11 @@ void ShareableBitmap::Handle::clear()
     m_handle.clear();
     m_size = IntSize();
     m_flags = Flag::NoFlags;
-    m_bytesPerPixel = calculateBytesPerPixel(m_flags);
 }
 
 RefPtr<ShareableBitmap> ShareableBitmap::create(const IntSize& size, Flags flags)
 {
-    unsigned bytesPerPixel = calculateBytesPerPixel(flags);
-    auto numBytes = numBytesForSize(size, bytesPerPixel);
+    auto numBytes = numBytesForSize(size);
     if (numBytes.hasOverflowed())
         return nullptr;
 
@@ -89,8 +79,7 @@ RefPtr<ShareableBitmap> ShareableBitmap::create(const IntSize& size, Flags flags
 
 RefPtr<ShareableBitmap> ShareableBitmap::createShareable(const IntSize& size, Flags flags)
 {
-    unsigned bytesPerPixel = calculateBytesPerPixel(flags);
-    auto numBytes = numBytesForSize(size, bytesPerPixel);
+    auto numBytes = numBytesForSize(size);
     if (numBytes.hasOverflowed())
         return nullptr;
 
@@ -105,15 +94,14 @@ RefPtr<ShareableBitmap> ShareableBitmap::create(const IntSize& size, Flags flags
 {
     ASSERT(sharedMemory);
 
-    unsigned bytesPerPixel = calculateBytesPerPixel(flags);
-    auto numBytes = numBytesForSize(size, bytesPerPixel);
+    auto numBytes = numBytesForSize(size);
     if (numBytes.hasOverflowed())
         return nullptr;
     if (sharedMemory->size() < numBytes.unsafeGet()) {
         ASSERT_NOT_REACHED();
         return nullptr;
     }
-    
+
     return adoptRef(new ShareableBitmap(size, flags, sharedMemory));
 }
 
@@ -135,7 +123,6 @@ bool ShareableBitmap::createHandle(Handle& handle, SharedMemory::Protection prot
         return false;
     handle.m_size = m_size;
     handle.m_flags = m_flags;
-    handle.m_bytesPerPixel = m_bytesPerPixel;
     return true;
 }
 
@@ -144,7 +131,6 @@ ShareableBitmap::ShareableBitmap(const IntSize& size, Flags flags, void* data)
     , m_flags(flags)
     , m_data(data)
 {
-    m_bytesPerPixel = calculateBytesPerPixel(flags);
 }
 
 ShareableBitmap::ShareableBitmap(const IntSize& size, Flags flags, RefPtr<SharedMemory> sharedMemory)
@@ -153,7 +139,6 @@ ShareableBitmap::ShareableBitmap(const IntSize& size, Flags flags, RefPtr<Shared
     , m_sharedMemory(sharedMemory)
     , m_data(0)
 {
-    m_bytesPerPixel = calculateBytesPerPixel(flags);
 }
 
 ShareableBitmap::~ShareableBitmap()
diff --git a/Source/WebKit2/Shared/ShareableBitmap.h b/Source/WebKit2/Shared/ShareableBitmap.h
index 5b1d433d225..923aa1f957b 100644
--- a/Source/WebKit2/Shared/ShareableBitmap.h
+++ b/Source/WebKit2/Shared/ShareableBitmap.h
@@ -51,7 +51,6 @@ public:
     enum Flag {
         NoFlags = 0,
         SupportsAlpha = 1 << 0,
-        SupportsExtendedColor = 1 << 1,
     };
     typedef unsigned Flags;
 
@@ -73,7 +72,6 @@ public:
         mutable SharedMemory::Handle m_handle;
         WebCore::IntSize m_size;
         Flags m_flags;
-        unsigned m_bytesPerPixel;
     };
 
     // Create a shareable bitmap that uses malloced memory.
@@ -128,9 +126,8 @@ private:
 
 #if USE(CAIRO)
     static Checked<unsigned, RecordOverflow> numBytesForSize(const WebCore::IntSize&);
-    static Checked<unsigned, RecordOverflow> numBytesForSize(const WebCore::IntSize& size, unsigned bytesPerPixel) { return numBytesForSize(size); }
 #else
-    static Checked<unsigned, RecordOverflow> numBytesForSize(const WebCore::IntSize& size, unsigned bytesPerPixel) { return size.area<RecordOverflow>() * bytesPerPixel; }
+    static Checked<unsigned, RecordOverflow> numBytesForSize(const WebCore::IntSize& size) { return size.area<RecordOverflow>() * 4; }
 #endif
 
 #if USE(CG)
@@ -144,15 +141,10 @@ private:
 #endif
 
     void* data() const;
-#if USE(CAIRO)
     size_t sizeInBytes() const { return numBytesForSize(m_size).unsafeGet(); }
-#else
-    size_t sizeInBytes() const { return numBytesForSize(m_size, m_bytesPerPixel).unsafeGet(); }
-#endif
-    
+
     WebCore::IntSize m_size;
     Flags m_flags;
-    unsigned m_bytesPerPixel;
 
     // If the shareable bitmap is backed by shared memory, this points to the shared memory object.
     RefPtr<SharedMemory> m_sharedMemory;
diff --git a/Source/WebKit2/Shared/mac/RemoteLayerBackingStore.mm b/Source/WebKit2/Shared/mac/RemoteLayerBackingStore.mm
index d5719dda12b..3dc1750ba26 100644
--- a/Source/WebKit2/Shared/mac/RemoteLayerBackingStore.mm
+++ b/Source/WebKit2/Shared/mac/RemoteLayerBackingStore.mm
@@ -153,7 +153,7 @@ bool RemoteLayerBackingStore::decode(IPC::Decoder& decoder, RemoteLayerBackingSt
         MachSendRight sendRight;
         if (!decoder.decode(sendRight))
             return false;
-        result.m_frontBuffer.surface = WebCore::IOSurface::createFromSendRight(sendRight, sRGBColorSpaceRef());
+        result.m_frontBuffer.surface = WebCore::IOSurface::createFromSendRight(sendRight, ColorSpaceSRGB);
         return true;
     }
 #endif
@@ -213,7 +213,7 @@ void RemoteLayerBackingStore::swapToValidFrontBuffer()
         std::swap(m_frontBuffer, m_backBuffer);
 
         if (!m_frontBuffer.surface)
-            m_frontBuffer.surface = WebCore::IOSurface::create(expandedScaledSize, sRGBColorSpaceRef(), bufferFormat(m_isOpaque));
+            m_frontBuffer.surface = WebCore::IOSurface::create(expandedScaledSize, ColorSpaceSRGB, bufferFormat(m_isOpaque));
 
         setBufferVolatility(BufferType::Front, false);
         return;
diff --git a/Source/WebKit2/UIProcess/API/C/cg/WKIconDatabaseCG.cpp b/Source/WebKit2/UIProcess/API/C/cg/WKIconDatabaseCG.cpp
index 3056336cb66..0f6de7a146a 100644
--- a/Source/WebKit2/UIProcess/API/C/cg/WKIconDatabaseCG.cpp
+++ b/Source/WebKit2/UIProcess/API/C/cg/WKIconDatabaseCG.cpp
@@ -37,23 +37,12 @@ using namespace WebCore;
 CGImageRef WKIconDatabaseTryGetCGImageForURL(WKIconDatabaseRef iconDatabaseRef, WKURLRef urlRef, WKSize size)
 {
     Image* image = toImpl(iconDatabaseRef)->imageForPageURL(toWTFString(urlRef));
-    return image ? image->nativeImageOfSize(IntSize(static_cast<int>(size.width), static_cast<int>(size.height))).get() : nullptr;
+    return image ? image->getFirstCGImageRefOfSize(IntSize(static_cast<int>(size.width), static_cast<int>(size.height))) : 0;
 }
 
 CFArrayRef WKIconDatabaseTryCopyCGImageArrayForURL(WKIconDatabaseRef iconDatabaseRef, WKURLRef urlRef)
 {
     Image* image = toImpl(iconDatabaseRef)->imageForPageURL(toWTFString(urlRef));
-    if (!image)
-        return nullptr;
-
-    auto nativeImages = image->framesNativeImages();
-    if (!nativeImages.size())
-        return nullptr;
-    
-    CFMutableArrayRef array = CFArrayCreateMutable(nullptr, nativeImages.size(), &kCFTypeArrayCallBacks);
-    for (auto nativeImage : nativeImages)
-        CFArrayAppendValue(array, nativeImage.get());
-    
-    return static_cast<CFArrayRef>(CFRetain(array));
+    return image ? image->getCGImageArray().leakRef() : 0;
 }
 
diff --git a/Source/WebKit2/UIProcess/API/efl/EwkView.cpp b/Source/WebKit2/UIProcess/API/efl/EwkView.cpp
index caf0d723f06..cafdd980ab8 100644
--- a/Source/WebKit2/UIProcess/API/efl/EwkView.cpp
+++ b/Source/WebKit2/UIProcess/API/efl/EwkView.cpp
@@ -450,9 +450,10 @@ void EwkView::setCursor(const Cursor& cursor)
         if (cursorImage == m_cursorIdentifier.image)
             return;
 
-        
-        Optional<IntPoint> hotSpot = cursorImage->hotSpot();
-        Ecore_X_Cursor customCursor = createCustomCursor(window, cursorImage, IntSize(cursorImage->size()), hotSpot ? hotSpot.value() : IntPoint());
+        IntPoint hotSpot;
+        cursorImage->getHotSpot(hotSpot);
+
+        Ecore_X_Cursor customCursor = createCustomCursor(window, cursorImage, IntSize(cursorImage->size()), hotSpot);
         if (!customCursor)
             return;
 
diff --git a/Source/WebKit2/UIProcess/Cocoa/WebViewImpl.mm b/Source/WebKit2/UIProcess/Cocoa/WebViewImpl.mm
index 41559c1e69e..a84a3139a0d 100644
--- a/Source/WebKit2/UIProcess/Cocoa/WebViewImpl.mm
+++ b/Source/WebKit2/UIProcess/Cocoa/WebViewImpl.mm
@@ -3714,7 +3714,7 @@ void WebViewImpl::provideDataForPasteboard(NSPasteboard *pasteboard, NSString *t
     // FIXME: need to support NSRTFDPboardType
 
     if ([type isEqual:NSTIFFPboardType] && m_promisedImage) {
-        [pasteboard setData:(NSData *)m_promisedImage->tiffRepresentation() forType:NSTIFFPboardType];
+        [pasteboard setData:(NSData *)m_promisedImage->getTIFFRepresentation() forType:NSTIFFPboardType];
         m_promisedImage = nullptr;
     }
 }
diff --git a/Source/WebKit2/UIProcess/WebIconDatabase.h b/Source/WebKit2/UIProcess/WebIconDatabase.h
index 8b70fe824cf..08397ee27e6 100644
--- a/Source/WebKit2/UIProcess/WebIconDatabase.h
+++ b/Source/WebKit2/UIProcess/WebIconDatabase.h
@@ -31,7 +31,7 @@
 #include "WebIconDatabaseClient.h"
 #include <WebCore/IconDatabaseClient.h>
 #include <WebCore/IntSize.h>
-#include <WebCore/NativeImage.h>
+#include <WebCore/NativeImagePtr.h>
 
 namespace API {
 class Data;
diff --git a/Source/WebKit2/UIProcess/ios/WKContentViewInteraction.mm b/Source/WebKit2/UIProcess/ios/WKContentViewInteraction.mm
index 20d904a3ddb..74b6eed5bf0 100644
--- a/Source/WebKit2/UIProcess/ios/WKContentViewInteraction.mm
+++ b/Source/WebKit2/UIProcess/ios/WKContentViewInteraction.mm
@@ -4149,7 +4149,7 @@ static NSString *previewIdentifierForElementAction(_WKElementAction *action)
 {
     if (!_positionInformation.linkIndicator.contentImage)
         return nullptr;
-    return [[[UIImage alloc] initWithCGImage:_positionInformation.linkIndicator.contentImage->nativeImage().get()] autorelease];
+    return [[[UIImage alloc] initWithCGImage:_positionInformation.linkIndicator.contentImage->getCGImageRef()] autorelease];
 }
 
 - (NSArray *)_presentationRectsForPreviewItemController:(UIPreviewItemController *)controller
diff --git a/Source/WebKit2/WebProcess/Plugins/PluginView.cpp b/Source/WebKit2/WebProcess/Plugins/PluginView.cpp
index a0d8ab866fc..2931def666a 100644
--- a/Source/WebKit2/WebProcess/Plugins/PluginView.cpp
+++ b/Source/WebKit2/WebProcess/Plugins/PluginView.cpp
@@ -1717,7 +1717,7 @@ void PluginView::windowedPluginVisibilityDidChange(bool isVisible, uint64_t wind
 #if PLATFORM(COCOA)
 static bool isAlmostSolidColor(BitmapImage* bitmap)
 {
-    CGImageRef image = bitmap->nativeImage().get();
+    CGImageRef image = bitmap->getCGImageRef();
     ASSERT(CGImageGetBitsPerComponent(image) == 8);
 
     CGBitmapInfo imageInfo = CGImageGetBitmapInfo(image);
diff --git a/Source/WebKit2/WebProcess/WebPage/ios/WebPageIOS.mm b/Source/WebKit2/WebProcess/WebPage/ios/WebPageIOS.mm
index 0563c359e19..b1331f23d2a 100644
--- a/Source/WebKit2/WebProcess/WebPage/ios/WebPageIOS.mm
+++ b/Source/WebKit2/WebProcess/WebPage/ios/WebPageIOS.mm
@@ -2352,10 +2352,7 @@ void WebPage::getPositionInformation(const IntPoint& point, InteractionInformati
                                 screenSizeInPixels.scale(corePage()->deviceScaleFactor());
                                 FloatSize scaledSize = largestRectWithAspectRatioInsideRect(image->size().width() / image->size().height(), FloatRect(0, 0, screenSizeInPixels.width(), screenSizeInPixels.height())).size();
                                 FloatSize bitmapSize = scaledSize.width() < image->size().width() ? scaledSize : image->size();
-                                // FIXME: Only select ExtendedColor on images known to need wide gamut
-                                ShareableBitmap::Flags flags = ShareableBitmap::SupportsAlpha;
-                                flags |= screenSupportsExtendedColor() ? ShareableBitmap::SupportsExtendedColor : 0;
-                                if (RefPtr<ShareableBitmap> sharedBitmap = ShareableBitmap::createShareable(IntSize(bitmapSize), flags)) {
+                                if (RefPtr<ShareableBitmap> sharedBitmap = ShareableBitmap::createShareable(IntSize(bitmapSize), ShareableBitmap::SupportsAlpha)) {
                                     auto graphicsContext = sharedBitmap->createGraphicsContext();
                                     graphicsContext->drawImage(*image, FloatRect(0, 0, bitmapSize.width(), bitmapSize.height()));
                                     info.image = sharedBitmap;
