From c2779d5cddef36f74729dba9c59751596c0ad52c Mon Sep 17 00:00:00 2001
From: Wan-Teh Chang <wtc@google.com>
Date: Tue, 30 Dec 2025 12:09:35 -0600
Subject: [PATCH] Avoid integer overflow in (32-bit) int or unsigned int
 arithmetic operations

The idea of this patch is to assume the existence of integer overflow in
the code in avifImageRGBToYUV() and only enter the function when the
image width and height are not too big. We have a similar protection in
avifDecoder. Since avifImageRGBToYUV() is typically used to prepare the
input to avifEncoder, I didn't add this protection to
avifImageRGBToYUV().

2ded15b09 has some context for the image size (area) and dimension
limits. For this avifImageRGBToYUV() issue, the image size (area) limit
is sufficient. The image dimension limit is intended to avoid spending a
very long time decoding an image.

Link: https://github.com/AOMediaCodec/libavif/pull/2769#issuecomment-2907860473

CVE: CVE-2025-48175
Upstream-Status: Inappropriate [https://github.com/AOMediaCodec/libavif/pull/2769#issuecomment-2907860473]
Signed-off-by: Colin Pinnell McAllister <colin.mcallister@garmin.com>
---
 src/reformat.c | 5 +++++
 1 file changed, 5 insertions(+)

diff --git a/src/reformat.c b/src/reformat.c
index da6a73dc..57cc8853 100644
--- a/src/reformat.c
+++ b/src/reformat.c
@@ -198,6 +198,11 @@ static int avifReformatStateUVToUNorm(avifReformatState * state, float v)
 
 avifResult avifImageRGBToYUV(avifImage * image, const avifRGBImage * rgb)
 {
+    // Avoid integer overflow in (32-bit) int or unsigned int arithmetic operations.
+    if ((uint64_t)rgb->width * rgb->height > AVIF_DEFAULT_IMAGE_SIZE_LIMIT) {
+        return AVIF_RESULT_REFORMAT_FAILED;
+    }
+
     if (!rgb->pixels || rgb->format == AVIF_RGB_FORMAT_RGB_565) {
         return AVIF_RESULT_REFORMAT_FAILED;
     }
-- 
2.52.0

